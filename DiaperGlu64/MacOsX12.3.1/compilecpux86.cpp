// //////////////////////////////////////////////////////////////////////////////////////
//
//    Copyright 2022 James Patrick Norris
//
//    This file is part of DiaperGlu v5.7.
//
//    DiaperGlu v5.7 is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    DiaperGlu v5.7 is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with DiaperGlu v5.7; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// //////////////////////////////////////////////////////////////////////////////////////

// /////////////////////////////
// James Patrick Norris       //
// www.rainbarrel.com         //
// August 26, 2022            //
// version 5.7                //
// /////////////////////////////
// no frame//// frame using just rbp //  ( ENTER-FRAME, EXIT-FRAME, )//// diaperglu forth frame (has to have pBHarrayhead passed in)//  ( ENTER-DGLU-FORTH-FRAME, EXIT-DGLU-FORTH-FRAME, )//// call sub frame (rbp with locals marker)//  ( ENTER-CALL-SUBS-FRAME, EXIT-CALL-SUBS-FRAME, )//#include "../diapergluforth.h"// when do you need REX?//  only in 64 bit mode//  not using AH, BH, CH, DH//  data size is 64 bits and instruction is not push pop call or jump//  using [R+N] and base reg is R8-R15//  using [R+S*I+N] and base reg or index reg is R8-R15//  source or destination reg needs rex (so R8-R15 of any size or SIL, DIL, BPL, SPL, XMM8-XMM15)// AAA y// AAD y// AAM y// AAS y// ADC y// ADCX (ADX) y// ADD y// ADDPD (SSE2) y x128/m128 -> x128;     (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ADDPS (SSE)  y x128/m128 -> x128;     (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ADDSD (SSE2) y x128/m64 -> x128;      (AVX) x128/m64 x128 -> x128// ADDSS (SSE)  y x128/m32 -> x128;      (AVX) x128/m32 x128 -> x128// ADDSUBPD (SSE3) y x/128/m128 -> x128; (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ADDSUBPS (SSE3) y x/128/m128 -> x128; (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ADOX (ADX) y r32/m32 -> r32; r64/m64 -> r64// AESDEC     (AES) y x128/m128 -> x128;   (AES AVX) x128/m128 x128 -> x128// AESDECLAST (AES) y x128/m128 -> x128;   (AES AVX) x128/m128 x128 -> x128// AESENC     (AES) y x128/m128 -> x128;   (AES AVX) x128/m128 x128 -> x128// AESENCLAST (AES) y x128/m128 -> x128;   (AES AVX) x128/m128 x128 -> x128// AESIMC     (AES) y need test x128/m128 -> x128;   (AES AVX) x128/m128 -> x128// AESKEYGENASSIST (AES) y need test u8 x128/m128 -> x128; (AES AVX) u8 x128/m128 -> x128// AND y// ANDN (BMI1)  r/m32 r32 -> r32; r/m64 r64 -> r64// ANDPD (SSE2)  y x128/m128 -> x128; (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ANDPS (SSE)   y x128/m128 -> x128; (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ANDNPD (SSE2) y x128/m128 -> x128; (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ANDNPS (SSE)  y x128/m128 -> x128; (AVX) x128/m128 x128 -> x128; y256/m256 y256 -> y256// ARPL y    r16 -> r16/m16// BLENDPD (SSE4_1) y n8 x128/m128 -> x128; n8 x128/m128 x128 -> x128; n8 y256/m256 y256 -> y256// BEXTR (BMI1) r32 r32/m32 -> r32; r64 r64/m64 -> r64// BLENDPS (SSE4_1) y// BLENDVPD (SSE4_1)// BLENDVPS (SSE4_1)// BLSI (BMI1)// BLSMSK (BMI1)// BLSR (BMI1)// BOUND y// BSF y// BSR y// BSWAP y// BT y// BTC y// BTR y// BTS y// BZHI {BMI2}// CALL y// CBW/CWDE/CDQE y (CBW, CWDE, CDQE,)// CLAC y// CLC y// CLD y// CFLUSH y not tested {CLFSH flag} (introduced with SSE2 but not necessarily there)// CLI y// CLTS y not tested// CMC y// CMOVcc (CMOV,) y// CMP y// CMPPD {SSE2} y// CMPPS {SSE} y// CMPS/CMPSB/CMPSW/CMPSD/CMPSQ (CMPSB, CMPSW, CMPSD, CMPSQ, )// CMPSD {SSE2} ( CMPSD2, ) y// CMPSS {SSE} y// CMPXCHG y// CMPXCHG8B/CMPXCHG16B y// COMISD {SSE2} y// COMISS {SSE} y// CPUID y// CRC32 y// CVTDQ2PD {SSE2} y// CVTDQ2PS {SSE2} y// CVTPD2DQ {SSE2} y// CVTPD2PI y// CVTPD2PS {SSE2} y// CVTPI2PD y// CVTPI2PS y// CVTPS2DQ {SSE2} y// CVTPS2PD {SSE2} y// CVTPS2PI y// CVTSD2SI {SSE2} y// CVTSD2SS {SSE2} y// CVTSI2SD {SSE2} y// CVTSI2SS {SSE} y// CVTSS2SD {SSE2} y// CVTSS2SI {SSE} y// CVTTPD2DQ {SSE2} y// CVTTPD2PI y// CVTTPS2DQ {SSE2} y// CVTTPS2PI y// CVTTSD2SI {SSE2} y// CVTTSS2SI {SSE} y// CWD/CDQ/CQO (CDQ, CDQE, CWD, CWDE, CQO,)// DAA y// DAS y// DEC y// DIV y// DIVPD {SSE2} y// DIVPS {SSE} y// DIVSD {SSE2} y// DIVSS {SSE} y// DPPD {SSE4_1}// DPPS {SSE4_1}// EMMS y not tested// ENTER y// EXTRACTPS y {SSE4_1}// F2XM1 y// FABS y// FADD/FADDP/FIADD y ( FADD->ST0, FADDST0->, FADDPST0->, FIADD->ST0, )// FBLD y// FBSTP y// FCHS y// FCLEX/FNCLEX y// FCMOVcc y ( FCMOVB->ST0, FCMOVBE->ST0, FCMOVE->ST0, FCMOVU->ST0, )//           ( FCMOVNB->ST0, FCMOVNBE->ST0, FCMOVNE->ST0, FCMOVNU->ST0, )// FCOM/FCOMP/FCOMPP y ( FCOM->ST0, FCOMP->ST0, )// FCOMI/FCOMIP/FUCOMI/FUCOMIP y ( FCOMI->ST0, FCOMIP->ST0, FUCOMI->ST0, FUCOMIP->ST0, )// FCOS y// FDECSTP y// FDIV/FDIVP/FIDIV y ( FDIV->ST0, FDIVST0->, FDIVPST0->, FIDIV->ST0, )// FIDIVR/FDIVRP/FIDIVR y ( FDIVR->ST0, FDIVRST0->, FDIVRPST0->, FIDIVR->ST0, )// FFREE y// FICOM/FICOMP y ( FICOM->ST0, FICOMP->ST0, )// FILD y// FINCSTP y// FINIT/FNINIT y// FIST/FISTP y// FISTTP y// FLD y// FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ y// FLDCW y// FLDENV y// FMUL/FMULP/FIMUL y ( FMUL->ST0, FMULST0->, FMULPST0->, FIMUL->ST0, )// FNOP y// FPATAN y// FPREM y// FPREM1 y// FPTAN y// FRNDINT y// FRSTOR y// FSAVE/FNSAVE y// FSCALE y// FSIN y// FSINCOS y// FSQRT y// FST/FSTP y// FSTCW/FNSTCW y// FSTENV/FNSTENV y// FSTSW/FNSTSW y ( FNSTSW->AX, FSTSW->AX )// FSUB/FSUBP/FISUB y ( FSUB->ST0, FSUBST0->, FSUBPST0->, FISUB->ST0, )// FSUBR/FSUBRP/FISUBR y ( FSUBR->ST0, FSUBRST0->, FSUBRPST0->, FISUBR->ST0, )// FTST y// FUCOM/FUCOMP/FUCOMPP y ( FUCOM->ST0, FUCOMP->ST0, )// FXAM y// FXCH y ( FSWAP, FXCHST0->, )// FXRSTOR// FXSAVE// FXTRACT y// FYL2X y// FYL2XP1 y// HADDPD {SSE3} y// HADDPS {SSE3} y// HLT y// HSUBPD {SSE3} y// HSUBPS {SSE3} y// IDIV y// IMUL y// IN y (IN[N8]->AL, IN[N8]->AX, IN[N8]->EAX, IN[DX]->AL, IN[DX]->AX, IN[DX]->EAX)// INC y// INS/INSB/INSW/INSD y// INSERTPS {SSE4_1} y// INT n/INTO/INT 3 (INT,)// INVD y// INVLPG {0F 01/7} y// INVPCID {INVPCID} y// IRET/IRETD/IRETQ y (IRETD, IRETQ,)// Jcc need? {BRANCH,?)// JMP need? (BRANCH,?)// LAHF y// LAR y// LDDQU y// LDMXCSR y {SSE}// LDS/LES/LFS/LGS/LSS y// LEA y// LEAVE y// LFENCE y not tested// LGDT/LIDT y// LLDT y// LMSW y// LOCK y// LODS/LODSB/LODSW/LODSD/LODSQ y (LODSB, LODSW, LODSD, LODSQ,)// ?LOOP/LOOPcc ( LOOPNOTDONEWHILE, y NZORLOOPNOTDONEWHILE, y NEORLOOPNOTDONEWHILE, EQORLOOPNOTDONEWHILE, ZSORLOOPNOTDONEWHILE, y )// LSL y// LTR y// LZCNT y// MASKMOVDQU {SSE2} y// MASKMOVQ y// MAXPD {SSE2} y// MAXPS {SSE} y// MAXSD {SSE2} y// MAXSS {SSE} y// MFENCE y (not tested)// MINPD {SSE2} y// MINPS {SSE} y// MINSD {SSE2} y// MINSS {SSE} y// MONITOR y// MOV y ( MOV, )//   ( MOV[N]->AL, MOV[N]->AX, MOV[N]->EAX, MOV[N]->RAX, MOVAL->[N], MOVAX->[N], MOVEAX->[N], MOVRAX->[N], y )//   ( you can put REX.W in front of MOV[N]->AL and AL->MOV[N] but I have no//      idea what it does so I didn't include it 3/17/2020 )//   ( MOVCR, y )//   ( MOVDR, y )//   ( MOVSR, y )// MOVAPD {SSE2} y// MOVAPS {SSE} y// MOVBE {SSE3 I think...} Y// MOVD/MOVQ y {MMX} (MOVD, MOVQ2,)// MOVDDUP {SSE3} y// MOVDQA {SSE2} y// MOVDQU {SSE2} y// MOVDQ2Q y// MOVHLPS {SSE} y// MOVHPD y// MOVHPS y// MOVLHPS y// MOVLPD y// MOVLPS y// MOVMSKPD y// MOVMSKPS y// MOVNTDQA y// MOVNTDQ y// MOVNTI y (r32tom32only r64tom64only)// MOVNTPD y// MOVNTPS y// MOVNTQ y (fptom64only)// MOVQ y// MOVQ2DQ y (xmmtofponly)// MOVS/MOVSB/MOVSW/MOVSD/MOVSQ y (MOVSB, MOVSW, MOVSD, MOVSQ,)// MOVSD ( MOVSD2, y ) // MOVSHDUP y// MOVSLDUP y// MOVSS y// MOVSX y / MOVSXD y// MOVUPD y// MOVUPS y// MOVZX y// MPSADBW y// MUL y// MULPD y// MULPS y// MULSD y// MULSS y// MULX {BMI2}// MWAIT y// NEG y// NOP y// NOT y// OR y// ORPD y {SSE2}// ORPS y {SSE}// OUT y ( AL->OUT[N8], AX->OUT[N8], EAX->OUT[N8], OUTW, AL->OUT[DX], AX->OUT[DX], EAX->OUT[DX],)// OUTS/OUTSB/OUTSW/OUTSD y// PABSB/PABSW/PABSD y// PACKSSWB/PACKSSDW y// PACKUSDW y// PACKUSWB y// PADDB/PADDW/PADDD y// PADDQ y// PADDSB/PADDSW y// PADDUSB/PADDUSW y// PALIGNR y// PAND y {MMX}// PANDN y {MMX}// PAUSE y (not tested)// PAVGB/PAVGW y {SSE}// PBLENDVB y {SSE4_1}// PBLENDW y {SSE4_1}// PCLMULQDQ y {PCLMULQDQ flag}// PCMPEQB/PCMPEQW/PCMPEQD y {MMX}// PCMPEQQ y {SSE4_1}// PCMPESTRI y {SSE4_2}// PCMPESTRM y {SSE4_2}// PCMPGTB/PCMPGTW/PCMPGTD y {MMX}// PCMPGTQ y {SSE4_2}// PCMPISTRI y {SSE4_2}// PCMPISTRM y {SSE4_2}// PDEP {BMI2}// PEXT {BMI2}// PEXTRB/PEXTRD/PEXTRQ y {SSE4_1} (n8xmmtor/m)// PEXTRW y {SSE} (n8xmmtor/m n8fptor/m)// PHADDW/PHADDD y {SSE3}// PHADDSW y {SSE3}// PHMINPOSUW y// PHSUBW/PHSUBD y// PHSUBSW y// PINSRB/PINSRD/PINSRQ y (n8r/mtoxmm)// PINSRW y (n8r/mtofp n8r/mtoxmm)// PMADDUBSW y// PMADDWD y// PMAXSB y// PMAXSD y// PMAXSW y// PMAXUB y// PMAXUD y// PMAXUW y// PMINSB y// PMINSD y// PMINSW y// PMINUB y// PMINUD y// PMINUW y// PMOVMSKB y// PMOVSXBW PMOVSXBD PMOVSXBQ PMOVSXWD PMOVSXWQ PMOVSDQ y// PMOVZXBW PMOVZXBD PMOVZXBQ PMOVZXWD PMOVZXWQ PMOVZDQ y// PMULDQ y// PMULHRSW y// PMULHUW y// PMULHW y// PMULLD y// PMULLW y// PMULUDQ y// POP y// POPA/POPAD y// POPCNT y// POPF/POPFD/POPFQ y (used as part of CLAC, test and is used in dg_compileinitlocals)// POR y {MMX}// PREFETCHh y// PREFETCHW y {PREFETCHW flag}// PREFETCHWT1 y// PSADBW y {SSE}// PSHUFB y {SSSE3}// PSHUFD y {SSE2}// PSHUFHW y// PSHUFLW y// PSHUFW y// PSIGNB/PSIGNW/PSIGND y// PSLLW/PSLLD/PSLLQ y// PSRAW/PSRAD y {MMX}// PSRLDQ y {SSE2}// PSRLW/PSRLD/PSRLQ y// PSUBB/PSUBW/PSUBD y// PSUBQ y// PSUBSB/PSUBSW y// PSUBUSB/PSUBUSW y// PTEST y {SSE4_1}// PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ y// PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ y// PUSH y// PUSHA/PUSHAD y (PUSHAD,)// PUSHF/PUSHFD y (PUSHFD,)// PXOR y {MMX}// RCL/RCR/ROL/ROR y// RCPPS y {SSE}// RCPSS y {SSE}// RDFSBASE/RDGSBASE y// RDMSR y// RDPMC y// RDRAND y {RDRAND flag}// RDSEED y {RDSEED flag}// RDTSC y// RDTSCP y// REP/REPE/REPZ/REPNE/REPNZ y ( REP, REPE, REPNE, NZUNTILREP, ZSUNTILREP, )// RET y// RORX {BMI2}// ROUNDPD y {SSE4_1}// ROUNDPS y {SSE4_1}// ROUNDSD y {SSE4_1}// ROUNDSS y {SSE4_1}// RSM y (not tested)// RSQRTPS y {SSE}// RSQRTSS y {SSE}// SAHF y// SAL/SAR/SHL/SHR y// SARX/SHLX/SHRX {BMI2}// SBB y// ?SCAS/SCASB/SCASW/SCASD/SCASQ (SCASB, SCASW, SCASD, SCASQ,)// SETcc y// SFENCE y// SGDT y// SHLD y// SHRD y// SHUFPD y {SSE2}// SHUFPS y {SSE}// SIDT y// SLDT y (m16/r16 or m16/r64 only)// SMSW y (m16/r16 or m16/r32 or m16/r64 only)// SQRTPD y {SSE2}// SQRTPS y {SSE}// SQRTSD y {SSE2}// SQRTSS y {SSE}// STAC y ( not all processors support this )// STC y// STD y// STI y// STMXCSR y {SSE}// STOS/STOSB/STOSW/STOSD/STOSQ y (STOSB, STOSW, STOSD, STOSQ,)// STR y (r/m16)// SUB y// SUBPD y// SUBPS y// SUBSD y// SUBSS y// SWAPGS y// SYSCALL y// SYSENTER y// SYSEXIT y// SYSRET y not tested ( SYSRETTO32 SYSRETTO64 )// TEST y// TZCNT {BMI1}// UCOMISD y {SSE2}// UCOMISS y {SSES}// UD2 y not tested// UNPCKHPD y// UNPCKHPS y// UNPCKLDP y// UNPCKLPS y// VBROADCAST {AVX}// VCVTPH2PS// VCVTPS2PH// VERR/VERW need (r16/m16)// VEXTRACTF128// VEXTRACTI128// VFMADD132PD/VFMADD213PD/VFMADD231PD// VFMADD132PS/VFMADD213PS/VFMADD231PS// VFMADD132SD/VFMADD213SD/VFMADD231SD// VFMADD132SS/VFMADD213SS/VFMADD231SS// VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD// VFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS// VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD// VFMSUBADD132PS/VFMSUBADD213PD/VFMSUBADD231PS// VFMSUB132PD/VFMSUB213PD/VFMSUB231PD// VFMSUB132PS/VFMSUB213PS/VFMSUB231PS// VFMSUB132SD/VFMSUB213SD/VFMSUB231SD// VFMSUB132SS/VFMSUB213SS/VFMSUB231SS// VFNMADD132PD/VFNMADD213PD/VFNMADD231PD// VFNMADD132PS/VFNMADD213PS/VFNMADD231PS// VFNMADD132SD/VFNMADD213SD/VFNMADD231SD// VFNMADD132SS/VFNMADD213SS/VFNMADD231SS// VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD// VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS// VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD// VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS// VGATHERDPD/VGATHERQPD// VGATHERDPS/VGATHERQPS// VPGATHERDD/VPGATHERQD// VPGATHERDQ/VPGATHERQQ// VINSERTF128// VINSERTI128// VMASKMOV// VPBLENDD// VPBROADCAST// VPERMD// VPERMS// VPERMQ// VPERM2I128// VPERMILPD// VPERMILPS// VPERM2F128// VPMASKMOV// VPSLLVD/VPSLLVQ// VPSRAVD// VPSRLVD/VPSRLVQ// VTESTPD/VTESTPD// VZEROALL {AVX}// VZEROUPPER {AVX}// WAIT/FWAIT y ( WAIT, )// WBINVD y// WRFSBASE/WRGSBASE y {FSGSBASE} (r32 or r64)// WRMSR y// XACQUIRE/XRELEASE y {HLE}// XABORT y {RTM} (immediate 8bit only)// XADD y// XBEGIN y ( XBEGINN32, XBEGINN16, XBEGINBRANCH, ) {RTM}// XCHG y// XEND y {RTM}// XGETBV y// XLAT/XLATB ( y XLATB, )// XOR y// XORPD y {SSE2}// XORPS y {SSE}// XRSTOR/XRSTOR64 y// XRSTORS/XRSTORS64 y// XSAVE/XSAVE64 y// XSAVEC/XSAVEC64 y// XSAVEOPT/XSAVEOPT64 y {XSAVEOPT flag}// XSAVES/XSAVES64 y// XSETBV y// XTEST y {HLE or RTM}const char* dg_unknownsizeerror = " - unknown size error";const char* dg_valuetoobigerror = " - signed or unsigned value too big for size of data transfer";const char* dg_checkifvaluefitssizebaderror = " - error. size in memory > used size";const char* dg_checkifvaluefitsname = "dg_checkifvaluefits";const char* dg_checkifvaluefits(    UINT64 valuesizeinmem,  //    UINT64 usedvaluesize,   // sign extended to this size    UINT64 value){    if (valuesizeinmem > usedvaluesize)    {        return(dg_checkifvaluefitssizebaderror);    }        if (valuesizeinmem == usedvaluesize)    {        // not sign extending        switch (valuesizeinmem)        {            case sizeof(unsigned char):                if ((value + 0x80) >= 0x180)                {                    return (dg_valuetoobigerror);                }                break;                        case sizeof(UINT16):                if ((value + 0x8000) >= 0x18000)                {                    return (dg_valuetoobigerror);                }                break;                            case sizeof(UINT32):                if ((value + 0x80000000) >= 0x180000000)                {                    return (dg_valuetoobigerror);                }                break;                            case sizeof(UINT64):                break;                            default:                return (dg_unknownsizeerror);        }                return (dg_success);    }        //sign extending    // not sign extending    switch (valuesizeinmem)    {        case sizeof(unsigned char):            if ((value + 0x80) >= 0x100)            {                return (dg_signedvaluetoobigerror);            }            break;                    case sizeof(UINT16):            if ((value + 0x8000) >= 0x10000)            {                return (dg_signedvaluetoobigerror);            }            break;                    case sizeof(UINT32):            if ((value + 0x80000000) >= 0x100000000)            {                return (dg_signedvaluetoobigerror);            }            break;                    case sizeof(UINT64): // this case shouldn't happen....            break;                    default:            return (dg_unknownsizeerror);    }            return (dg_success);}UINT64 dg_ishighbytereg (UINT64 reg){    if (reg < dg_ah)    {        return (FORTH_FALSE);    }        if (reg <= dg_bh)    {        return (FORTH_TRUE);    }        return (FORTH_FALSE);}UINT64 dg_issildilbplorspl (UINT64 reg){    if (reg < dg_spl)    {        return (FORTH_FALSE);    }        if (reg <= dg_dil)    {        return (FORTH_TRUE);    }        return (FORTH_FALSE);}UINT64 dg_isrexbaseorindexreg (UINT64 reg){    if (reg < dg_r8)    {        return (FORTH_FALSE);    }        if (reg <= dg_r15)    {        return (FORTH_TRUE);    }        return (FORTH_FALSE);}UINT64 dg_isxvindexreg (UINT64 reg){    if (reg < dg_xmm8)    {        return (FORTH_FALSE);    }        if (reg <= dg_xmm15)    {        return (FORTH_TRUE);    }        if (reg < dg_ymm8)    {        return (FORTH_FALSE);    }        if (reg <= dg_ymm15)    {        return (FORTH_TRUE);    }        return (FORTH_FALSE);}UINT64 dg_isrexsrcordestreg (UINT64 reg){    if (reg < dg_r8l)    {        return (FORTH_FALSE);    }        if (reg < dg_rax)    {        return (FORTH_TRUE);    }    /*    if (reg <= dg_rdi)    {        return (FORTH_FALSE);    }        if (reg <= dg_dil)    {        return (FORTH_TRUE);    }    */        if (reg <= dg_xmm7)    {        return(FORTH_FALSE);    }        if (reg <= dg_xmm15)    {        return(FORTH_TRUE);    }        if (reg <= dg_ymm7)    {        return(FORTH_FALSE);    }        if (reg <= dg_ymm15)    {        return (FORTH_TRUE);    }        return (FORTH_FALSE);}UINT64 dg_isdefaultaddresssizeonetarget (struct Onetargetopcodestrings* popcodes){    if (0 == popcodes->r32.opcodestringlength)    {        return (FORTH_FALSE);    }        // checking to see if it's PUSH, or POP,    if ((char)0x50 == (popcodes->r32.popcodestring[0] & 0xf0))    {        return (FORTH_TRUE);    }        return (FORTH_FALSE);}const char* dg_isdatasizename = "DATASIZE";const char* dg_isforwardname = "->";const char* dg_isreversename = "<-";const char* dg_isimmediatename = "IMMEDIATE";const char* dg_isregname = "R";const char* dg_isfloatingpointstackregname = "FPSR";const char* dg_isxmmregname = "XMMR";const char* dg_isymmregname = "YMMR";const char* dg_iscontrolregname = "CR";const char* dg_isdebugregname = "DR";const char* dg_issegmentregname = "SR";const char* dg_isthreebytevexname = "3BYTEVEX";//const char* dg_useatleastmodrname = "MODR";const char* dg_usealteastmodmname = "[MOD]"; const char* dg_usealteastsibname  = "[SIB]";const char* dg_isvsibname  = "[VSIB]";const char* dg_isccbufferoffsetname       = "CURRENTCOMPILEBUFFEROFFSET";const char* dg_isccbufferoffset2name      = "O";const char* dg_isoimportcodelinkname      = "OIMPORTCODELINK";const char* dg_ishereplusdisplacementname = "EIP+N";const char* dg_ishereplusdisplacement64name = "RIP+N";const char* dg_isbufferoffsetname     = "BUFFEROFFSET"; // can I call this 'OB'?const char* dg_isbracketccbufferoffsetname = "[O]";// const char* dg_islocalname = "LOCAL";const char* dg_isparamusingframename = "FRAME-PARAM";const char* dg_isparamusingnoframename = "NO-FRAME-PARAM";const char* dg_isdgluforthframelocalname = "DGLU-FORTH-FRAME-LOCAL";const char dg_iscallsubsframelocalname[] = "CALL-SUBS-FRAME-LOCAL";// const char* dg_istointname = ">INT";// const char* dg_istofloatname = ">FLOAT";// const char* dg_isfromintname = "INT>";// const char* dg_isfromfloatname = "FLOAT>";// const char dg_iretparam[] = "IRETPARAM";// const char dg_irethiparam[] = "IRETHIPARAM";// const char dg_fretparam[] = "FRETPARAM";// const char dg_frethiparam[] = "FRETHIPARAM";const char* dg_alname = "AL";const char* dg_clname = "CL";const char* dg_dlname = "DL";const char* dg_blname = "BL";const char* dg_ahname = "AH";const char* dg_chname = "CH";const char* dg_dhname = "DH";const char* dg_bhname = "BH";const char* dg_axname = "AX";const char* dg_cxname = "CX";const char* dg_dxname = "DX";const char* dg_bxname = "BX";const char* dg_spname = "SP";const char* dg_bpname = "BP";const char* dg_siname = "SI";const char* dg_diname = "DI";const char* dg_eaxname = "EAX";const char* dg_ecxname = "ECX";const char* dg_edxname = "EDX";const char* dg_ebxname = "EBX";const char* dg_espname = "ESP";const char* dg_ebpname = "EBP";const char* dg_esiname = "ESI";const char* dg_ediname = "EDI";// 8 bit regs = 64 bit mode onlyconst char* dg_splname = "SPL";const char* dg_bplname = "BPL";const char* dg_silname = "SIL";const char* dg_dilname = "DIL";const char* dg_r8lname = "R8L";const char* dg_r9lname = "R9L";const char* dg_r10lname = "R10L";const char* dg_r11lname = "R11L";const char* dg_r12lname = "R12L";const char* dg_r13lname = "R13L";const char* dg_r14lname = "R14L";const char* dg_r15lname = "R15L";// 16 bit regs - 64 bit mode onlyconst char* dg_r8wname = "R8W";const char* dg_r9wname = "R9W";const char* dg_r10wname = "R10W";const char* dg_r11wname = "R11W";const char* dg_r12wname = "R12W";const char* dg_r13wname = "R13W";const char* dg_r14wname = "R14W";const char* dg_r15wname = "R15W";// 32 bit regs - 64 bit mode onlyconst char* dg_r8dname = "R8D";const char* dg_r9dname = "R9D";const char* dg_r10dname = "R10D";const char* dg_r11dname = "R11D";const char* dg_r12dname = "R12D";const char* dg_r13dname = "R13D";const char* dg_r14dname = "R14D";const char* dg_r15dname = "R15D";// 64 bit regs - 64 bit mode onlyconst char* dg_raxname = "RAX";const char* dg_rcxname = "RCX";const char* dg_rbxname = "RBX";const char* dg_rdxname = "RDX";const char* dg_rspname = "RSP";const char* dg_rbpname = "RBP";const char* dg_rsiname = "RSI";const char* dg_rdiname = "RDI";const char* dg_r8name  = "R8";const char* dg_r9name  = "R9";const char* dg_r10name = "R10";const char* dg_r11name = "R11";const char* dg_r12name = "R12";const char* dg_r13name = "R13";const char* dg_r14name = "R14";const char* dg_r15name = "R15";const char* dg_eipname = "EIP";const char* dg_ripname = "RIP";const char* dg_noregname = "NOREG";const char* dg_st0name = "ST0";const char* dg_st1name = "ST1";const char* dg_st2name = "ST2";const char* dg_st3name = "ST3";const char* dg_st4name = "ST4";const char* dg_st5name = "ST5";const char* dg_st6name = "ST6";const char* dg_st7name = "ST7";const char* dg_scale1name = "SCALE1*";const char* dg_scale2name = "SCALE2*";const char* dg_scale4name = "SCALE4*";const char* dg_scale8name = "SCALE8*";const char* dg_xmm0name = "XMM0";const char* dg_xmm1name = "XMM1";const char* dg_xmm2name = "XMM2";const char* dg_xmm3name = "XMM3";const char* dg_xmm4name = "XMM4";const char* dg_xmm5name = "XMM5";const char* dg_xmm6name = "XMM6";const char* dg_xmm7name = "XMM7";const char* dg_xmm8name = "XMM8";const char* dg_xmm9name = "XMM9";const char* dg_xmm10name = "XMM10";const char* dg_xmm11name = "XMM11";const char* dg_xmm12name = "XMM12";const char* dg_xmm13name = "XMM13";const char* dg_xmm14name = "XMM14";const char* dg_xmm15name = "XMM15";const char* dg_ymm0name = "YMM0";const char* dg_ymm1name = "YMM1";const char* dg_ymm2name = "YMM2";const char* dg_ymm3name = "YMM3";const char* dg_ymm4name = "YMM4";const char* dg_ymm5name = "YMM5";const char* dg_ymm6name = "YMM6";const char* dg_ymm7name = "YMM7";const char* dg_ymm8name = "YMM8";const char* dg_ymm9name = "YMM9";const char* dg_ymm10name = "YMM10";const char* dg_ymm11name = "YMM11";const char* dg_ymm12name = "YMM12";const char* dg_ymm13name = "YMM13";const char* dg_ymm14name = "YMM14";const char* dg_ymm15name = "YMM15";const char* dg_cr0name = "CR0";const char* dg_cr1name = "CR1";const char* dg_cr2name = "CR2";const char* dg_cr3name = "CR3";const char* dg_cr4name = "CR4";const char* dg_cr5name = "CR5";const char* dg_cr6name = "CR6";const char* dg_cr7name = "CR7";const char* dg_cr8name = "CR8";const char* dg_cr9name = "CR9";const char* dg_cr10name = "CR10";const char* dg_cr11name = "CR11";const char* dg_cr12name = "CR12";const char* dg_cr13name = "CR13";const char* dg_cr14name = "CR14";const char* dg_cr15name = "CR15";const char* dg_dr0name = "DR0";const char* dg_dr1name = "DR1";const char* dg_dr2name = "DR2";const char* dg_dr3name = "DR3";const char* dg_dr4name = "DR4";const char* dg_dr5name = "DR5";const char* dg_dr6name = "DR6";const char* dg_dr7name = "DR7";const char* dg_srcsname = "SRCS"; // using SRCS instead of CS because of name conflict with condition codesconst char* dg_srdsname = "SRDS";const char* dg_srssname = "SRSS";const char* dg_sresname = "SRES";const char* dg_srfsname = "SRFS";const char* dg_srgsname = "SRGS";// I did condition code names this way because CC and C names conflict with hexadecimal numbersconst char* dg_ccvsname = "VS";const char* dg_ccnvname = "NV";const char* dg_cccsname = "CS";const char* dg_ccncname = "NC";const char* dg_ccultname = "ULT";const char* dg_cculename = "ULE";const char* dg_ccugtname = "UGT";const char* dg_ccugename = "UGE";const char* dg_cczsname = "ZS";const char* dg_ccnzname = "NZ"; const char* dg_cceqname = "EQ"; // I'm used to this oneconst char* dg_ccnename = "NE"; // I'm used to this oneconst char* dg_ccssname = "SS";const char* dg_ccnsname = "NS";const char* dg_ccminame = "MI"; // I'm used to this oneconst char* dg_ccplname = "PL"; // I'm used to this oneconst char* dg_ccpsname = "PS";const char* dg_ccnpname = "NP";const char* dg_ccltname = "LT";const char* dg_ccgename = "GE";const char* dg_cclename = "LE";const char* dg_ccgtname = "GT";const char* dg_ccalwaysname = "ALWAYS";const char* dg_ccnevername = "NEVER";// 0f 80 of=1            overflow// 0f 81 of=0            no overflow// 0f 82 cf=1            u</cs// 0f 83 cf=0            u>=/cc// 0f 84 zf=1            =/z// 0f 85 zf=0            !=/nz// 0f 86 cf=1 or zf=1    u<=// 0f 87 cf=0 and zf=0   u>// 0f 88 sf=1            negative/minus// 0f 89 sf=0            positive/plus// 0f 8a pf=1            parity even// 0f 8b pf=0            parity odd// 0f 8c sf!=of          <// 0f 8D sf=of           >=// 0f 8e sf!of and zf=1  <=// 0f 8f zf=0 and sf=of  >// const UINT64 dg_regnottrashedduringaligment = dg_rax;void dg_compilemovntorax (    Bufferhandle* pBHarrayhead,    UINT64 n){    // movq nn->rax        unsigned char pbuf[11] = "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00";        *(UINT64*)(&(pbuf[2])) = n;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         10);    }/*void dg_compilecpuid(    Bufferhandle* pBHarrayhead,    UINT64 n){    unsigned char pbuf[3] = "\x0F\xA2";        dg_compilemovntorax (        pBHarrayhead,        n);        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         2);}*/void dg_compilemovntoeax (    Bufferhandle* pBHarrayhead,    UINT64 n){    // movq nn->rax        unsigned char pbuf[6] = "\xB8\x00\x00\x00\x00";        *(UINT32*)(&(pbuf[1])) = n;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         5);    }void dg_compileaddn32torax (    Bufferhandle* pBHarrayhead,    UINT64 n){    // movq nn->rax        unsigned char pbuf[8] = "\x48\x81\xC0\x00\x00\x00\x00";        *(INT32*)(&(pbuf[3])) = (INT32)(n & 0xFFFFFFFF);        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         7);    }void dg_compilemovntoreg(    Bufferhandle* pBHarrayhead,    UINT64 n,    UINT64 reg){    unsigned char pbuf[11] = "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00";        *(UINT64*)(&(pbuf[2])) = n;    pbuf[1] = 0xB8 | (reg & 7);        if (reg < dg_rax)    {        pbuf[1]++;    }        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         10);}void dg_compilemovregtoreg (    Bufferhandle* pBHarrayhead,    UINT64 srcreg,    UINT64 destreg){    unsigned char pbuf[4] = "\x48\x89\xC0"; // modr/m = 3.DEST.SRC                                             // 89 opcode is r to r/m so r is src, r/m is dest                                            // r/m = rex.b = 1  r = rex.r = 4        if (srcreg < dg_rax)    {        pbuf[0] = pbuf[0] | 4;    }        if (destreg < dg_rax)    {        pbuf[0] = pbuf[0] | 1;    }        pbuf[2] = pbuf[2] | (destreg & 7) | ((srcreg & 7) << 3);        dg_compilesegment(pBHarrayhead, (const char*)pbuf, 3);}void dg_compilemovbracketregtoreg (    Bufferhandle* pBHarrayhead,    UINT64 srcreg,    UINT64 destreg){    unsigned char pbuf[4] = "\x48\x8B\x00"; // modr/m = 0.DEST.SRC                                             // 8B opcode is r/m to r so r/m is src, r is dest                                            // r/m = rex.b = 1  r = rex.r = 4        if (srcreg < dg_rax)    {        pbuf[0] = pbuf[0] | 1;    }        if (destreg < dg_rax)    {        pbuf[0] = pbuf[0] | 4;    }        pbuf[2] = pbuf[2] | (destreg & 7) | ((srcreg & 7) << 3);        dg_compilesegment(pBHarrayhead, (const char*)pbuf, 3);}void dg_compilemovregtobracketreg (    Bufferhandle* pBHarrayhead,    UINT64 srcreg,    UINT64 destreg){    unsigned char pbuf[4] = "\x48\x89\x00"; // modr/m = 0.DEST.SRC                                             // 89 opcode is r to r/m so r is src, r/m is dest                                            // r/m = rex.b = 1  r = rex.r = 4        if (srcreg < dg_rax)    {        pbuf[0] = pbuf[0] | 4;    }        if (destreg < dg_rax)    {        pbuf[0] = pbuf[0] | 1;    }        pbuf[2] = pbuf[2] | (destreg & 7) | ((srcreg & 7) << 3);        dg_compilesegment(pBHarrayhead, (const char*)pbuf, 3);}void dg_compileaddregtoreg (    Bufferhandle* pBHarrayhead,    UINT64 srcreg,    UINT64 destreg){    unsigned char pbuf[4] = "\x48\x03\xC0"; // modr/m = 3.R.R/M                                              // 03 opcode is r/m to r so r/m is src, r is dest                                            // r/m = rex.b = 1  r = rex.r = 4        if (srcreg < dg_rax)      {        pbuf[0] = pbuf[0] | 1;    }        if (destreg < dg_rax)    {        pbuf[0] = pbuf[0] | 4;    }        pbuf[2] = pbuf[2] | (srcreg & 7) | ((destreg & 7) << 3);        dg_compilesegment(pBHarrayhead, (const char*)pbuf, 3);}// for moving frame values, local variables, and parameters to regsvoid dg_compilemovbracketrbpd8toreg (    Bufferhandle* pBHarrayhead,    UINT64 reg,    UINT64 displacement8){    // movq [rbp+d8] -> reg    0x48 0x8B 0x7D 0xF0    unsigned char pbuf[5] = "\x48\x8B\x45\xF0";        pbuf[3] = (unsigned char)(displacement8 & 0xFF);    pbuf[2] = pbuf[2] | (unsigned char)((reg & 7) << 3);        if (reg < dg_rax)    {        pbuf[0] = pbuf[0] | 1;    }        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         4);}// for moving frame values, local variables, and parameters to regs
void dg_compilemovbracketrbpd32toreg (
    Bufferhandle* pBHarrayhead,
    UINT64 reg,
    UINT64 displacement32)
{
    // movq [rbp+d32] -> reg    0x48 0x8B 0x85 0x00 0x00 0x00 0x00
    unsigned char pbuf[8] = "\x48\x8B\x85\x00\x00\x00\x00";
    
    *((UINT32*)(&(pbuf[3]))) = (UINT32)(displacement32 & 0xFFFFFFFF);
    pbuf[2] = pbuf[2] | (unsigned char)((reg & 7) << 3);
    
    if (reg < dg_rax)
    {
        pbuf[0] = pbuf[0] | 1;
    }
    
    dg_compilesegment (
        pBHarrayhead, 
        (const char*)pbuf, 
        7);
}


// for moving frame values, local variables, and parameters to regs
const char* dg_compilemovbracketrbpdtoregname = "dg_compilemovbracketrbpdtoreg";

void dg_compilemovbracketrbpdtoreg (
    Bufferhandle* pBHarrayhead,
    UINT64 reg,
    INT64 displacement)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);

    if (baderrorcount == olderrorcount)
    {
        return;
    }

    // if ( (displacement >= -0x80) &&
    //     (displacement < 0x80 ) )
    if (((UINT64)(displacement + 0x80)) < 0x100)
    {
        dg_compilemovbracketrbpd8toreg (
            pBHarrayhead,
            reg,
            (UINT64)displacement);
                
        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
        {
            dg_pusherror(pBHarrayhead, dg_compilemovbracketrbpdtoregname);
            return;
         }
    }
    else
    {
        if (((UINT64)displacement + 0x80000000) >= 0x100000000)
        {
            dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);
            dg_pusherror(pBHarrayhead, dg_compilemovbracketrbpdtoregname);
            return;
        }

        dg_compilemovbracketrbpd32toreg (
            pBHarrayhead,
            reg,
            (UINT64)displacement);
                
        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
        {
            dg_pusherror(pBHarrayhead, dg_compilemovbracketrbpdtoregname);
            return;
        }
    }
}void dg_compilemovregtobracketrbpd8 (    Bufferhandle* pBHarrayhead,    UINT64 reg,    UINT64 displacement8){    // movq [rbp+d8] -> reg    0x48 0x8B 0x7D 0xF0    unsigned char pbuf[5] = "\x48\x89\x45\xF0";        pbuf[3] = (unsigned char)(displacement8 & 0xFF);    pbuf[2] = pbuf[2] | (unsigned char)((reg & 7) << 3);        if (reg < dg_rax)    {        pbuf[0] = pbuf[0] | 1;    }        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         4);}// for moving frame values, local variables, and parameters to regs
void dg_compilemovregtobracketrbpd32 (
    Bufferhandle* pBHarrayhead,
    UINT64 reg,
    UINT64 displacement32)
{
    // movq [rbp+d32] -> reg    0x48 0x89 0x85 0x00 0x00 0x00 0x00
    unsigned char pbuf[8] = "\x48\x89\x85\x00\x00\x00\x00";
    
    *((INT32*)(&(pbuf[3]))) = (INT32)(displacement32 & 0xFFFFFFFF);
    pbuf[2] = pbuf[2] | (unsigned char)((reg & 7) << 3);
    
    if (reg < dg_rax)
    {
        pbuf[0] = pbuf[0] | 1;
    }
    
    dg_compilesegment (
        pBHarrayhead, 
        (const char*)pbuf, 
        7);
}


// for moving frame values, local variables, and parameters to regs
const char* dg_compilemovregtobracketrbpdname = "dg_compilemovregtobracketrbpd";

void dg_compilemovregtobracketrbpd (
    Bufferhandle* pBHarrayhead,
    UINT64 reg,
    INT64 displacement)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);

    if (baderrorcount == olderrorcount)
    {
        return;
    }

    // if ( (displacement >= -0x80) &&
    //      (displacement < 0x80 ) )
    if (((UINT64)(displacement + 0x80)) < 0x100)
    {
        dg_compilemovregtobracketrbpd8 (
            pBHarrayhead,
            reg,
            (UINT64)displacement);
                
        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
        {
            dg_pusherror(pBHarrayhead, dg_compilemovregtobracketrbpdname);
            return;
         }
    }
    else
    {
        if (((UINT64)displacement + 0x80000000) >= 0x100000000)
        {
            dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);
            dg_pusherror(pBHarrayhead, dg_compilemovregtobracketrbpdname);
            return;
        }

        dg_compilemovregtobracketrbpd32 (
            pBHarrayhead,
            reg,
            displacement);
                
        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
        {
            dg_pusherror(pBHarrayhead, dg_compilemovregtobracketrbpdname);
            return;
        }
    }
}const char* dg_compilebracketrbpdtodatastackname = "dg_compilebracketrbpdtodatastack";

void dg_compilebracketrbpdtodatastack (
    Bufferhandle* pBHarrayhead,
    INT64 displacement)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);

    if (baderrorcount == olderrorcount)
    {
        return;
    }

    dg_compilealignretstack(
        pBHarrayhead,
        2);
        
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilebracketrbpdtodatastackname);
        return;
    }

    dg_compilemovbracketrbpdtoreg (
        pBHarrayhead,
        dg_param2reg, // reg,
        displacement);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilebracketrbpdtodatastackname);
        return;
    }

    dg_compilepushpBHarrayheadtoret(pBHarrayhead);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilebracketrbpdtodatastackname);
        return;
    }

    dg_compilecalladdress(
        pBHarrayhead,
        (UINT64)&dg_pushdatastack);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilebracketrbpdtodatastackname);
        return;
    }
}

const char* dg_compiledatastacktobracketrbpdname = "dg_compiledatastacktobracketrbpd";

void dg_compiledatastacktobracketrbpd (
    Bufferhandle* pBHarrayhead,
    INT64 displacement)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);

    if (baderrorcount == olderrorcount)
    {
        return;
    }

    dg_compilealignretstack(
        pBHarrayhead,
        1);
        
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compiledatastacktobracketrbpdname);
        return;
    }

    dg_compilepushpBHarrayheadtoret(pBHarrayhead);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compiledatastacktobracketrbpdname);
        return;
    }

    dg_compilecalladdress(
        pBHarrayhead,
        (UINT64)&dg_popdatastack);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compiledatastacktobracketrbpdname);
        return;
    }

    dg_compilemovregtobracketrbpd (
        pBHarrayhead,
        dg_rax, // reg,
        displacement);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compiledatastacktobracketrbpdname);
        return;
    }

}// for pushing frame values, local variables, and parameters to return stackvoid dg_compilepushbracketrbpd8 (    Bufferhandle* pBHarrayhead,    UINT64 displacement8){    // pushq [rbp+d8]     0xFF 0x75 0x00    unsigned char pbuf[4] = "\xFF\x75\x00";        pbuf[2] = (unsigned char)(displacement8 & 0xFF);        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         3);}// for testingvoid dg_compilemovbracketripd32torax (    Bufferhandle* pBHarrayhead,    UINT64 displacement32){    // [rip+d32]->rax    unsigned char pbuf[8] = "\x48\x8B\x05\x00\x00\x00\x00";        pbuf[3] = (unsigned char)(displacement32 & 0xFFFFFFFF);        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        7);}// for testingvoid dg_compilecallbracketripd32 (    Bufferhandle* pBHarrayhead,    UINT64 displacement32){    // pushq rip+6; [rip+d32]->rip    unsigned char pbuf[7] = "\xFF\x15\x00\x00\x00\x00";        pbuf[2] = (unsigned char)(displacement32 & 0xFFFFFFFF);        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        6);}void dg_compiledatalink (    Bufferhandle* pBHarrayhead,    UINT64 n){    unsigned char pbuf[12] = "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\xC3";        *(UINT64*)(&(pbuf[2])) = n;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         11);}const char* dg_fortheaxjumpcommaname = "EAXJMP,";const char* dg_forthraxjumpcommaname = "RAXJMP,";void dg_compilejumptorax (Bufferhandle* pBHarrayhead){    // jump rax      0xFF 0xD0        unsigned char pbuf[3] = "\xFF\xE0";        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         2);}void dg_compilecalltorax (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xFF\xD0";        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         2);}void dg_compilereturn (Bufferhandle* pBHarrayhead){    // ret                0xC3    dg_compilesegment (        pBHarrayhead,         (const char*)"\xC3",         1);        }void dg_compileclc (Bufferhandle* pBHarrayhead){    // clc                0xF8    dg_compilesegment (        pBHarrayhead,        (const char*)"\xF8",        1);}void dg_compilestc (Bufferhandle* pBHarrayhead){    // sec                0xF9    dg_compilesegment (        pBHarrayhead,        (const char*)"\xF9",        1);}// for testing purposesconst char dg_compilenegateregname[] = "dg_compilenegatereg";void dg_compilenegatereg(    Bufferhandle* pBHarrayhead,    UINT64 reg){    unsigned char mycode[4] = "\x48\xF7\xD8";  // opcode extension is 3 so... // 11 011 reg    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return;    }    if (reg < dg_rax)    {        mycode[0] = mycode[0] | 1;    }    mycode[2] = mycode[2] | (unsigned char)(reg & 0x7); // assumes n is in range...    dg_compilesegment(        pBHarrayhead,        (const char*)mycode,        3);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilenegateregname);    }}const char* dg_compilesubn8fromrspname = "dg_compilesubn8fromrsp";void dg_compilesubn8fromrsp(    Bufferhandle* pBHarrayhead,    UINT64 n) // 0 to 255... it may get sign extended...              //  if so then -128 to 127{    // subq  rsp - 0x0n -> rsp                0x48 0x83 0xEC 0x00    unsigned char mycode[5] = "\x48\x83\xEC\x00";    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return;    }    mycode[3] = (unsigned char)(n & 0xff); // assumes n is in range...    dg_compilesegment(        pBHarrayhead,        (const char*)mycode,        4);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilesubn8fromrspname);    }}const char* dg_compileaddn8torspname = "dg_compileaddn8torsp";void dg_compileaddn8torsp(    Bufferhandle* pBHarrayhead,    UINT64 n) // 0 to 255... it may get sign extended...              //  if so then -128 to 127{    // addq  rsp + 0x0n -> rsp                0x48 0x83 0xC4 0x00    unsigned char mycode[5] = "\x48\x83\xC4\x00";    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return;    }    mycode[3] = (unsigned char)(n & 0xff); // assumes n is in range...    dg_compilesegment(        pBHarrayhead,        (const char*)mycode,        4);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileaddn8torspname);    }}const char* dg_compilecalloffsetname = "dg_compilecalloffset";void dg_compilecalloffset (    Bufferhandle* pBHarrayhead,    INT64 offset){    unsigned char pbuf[6] = "\xE8\x00\x00\x00\x00";    // UINT64 calloffsetcodelength = 5; // this must be the number of bytes in the call        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // make sure offset isn't too big    if ((offset + 0x80000000) >= 0x100000000)    {        // push error that offset is too big        dg_pusherror(pBHarrayhead, dg_branchtoobigerror);        dg_pusherror(pBHarrayhead, dg_compilecalloffsetname);        return;    }        *(INT32*)(&(pbuf[1])) = offset;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         5);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecalloffsetname);        return;    }}const char* dg_compilejmpoffsetname = "dg_compilejmpoffset";void dg_compilejmpoffset (    Bufferhandle* pBHarrayhead,    INT64 offset){    unsigned char pbuf[6] = "\xE9\x00\x00\x00\x00";    // UINT64 calloffsetcodelength = 5; // this must be the number of bytes in the call        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // make sure offset isn't too big    if ((offset + 0x80000000) >= 0x100000000)    {        // push error that offset is too big        dg_pusherror(pBHarrayhead, dg_branchtoobigerror);        dg_pusherror(pBHarrayhead, dg_compilejmpoffsetname);        return;    }        *(INT32*)(&(pbuf[1])) = offset;        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        5);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilejmpoffsetname);        return;    }}const char* dg_compilejmpbracketoffsetname = "dg_compilejmpbracketoffset";void dg_compilejmpbracketoffset (    Bufferhandle* pBHarrayhead,    INT64 offset){    unsigned char pbuf[7] = "\xFF\x25\x00\x00\x00\x00";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // make sure offset isn't too big    if ((offset + 0x80000000) >= 0x100000000)    {        // push error that offset is too big        dg_pusherror(pBHarrayhead, dg_branchtoobigerror);        dg_pusherror(pBHarrayhead, dg_compilejmpbracketoffsetname);        return;    }        *(INT32*)(&(pbuf[2])) = offset;        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        6);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilejmpbracketoffsetname);        return;    }}const char dg_compileacopyofsscopytoname[] = "dg_compileacopyofsscopyto";void dg_compileacopyofsscopyto(    Bufferhandle* pBHarrayhead,    unsigned char* psqstr,    UINT64 sqstrlen){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    dg_compilecalloffset(        pBHarrayhead,        sqstrlen);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileacopyofsscopytoname);        return;    }    dg_compilesegment(        pBHarrayhead,        (const char*)psqstr,        sqstrlen);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileacopyofsscopytoname);        return;    }    // start addr of string will be on return stack already    //  need to move it to data stack..    dg_compilepushdatastack(pBHarrayhead);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileacopyofsscopytoname);        return;    }    dg_compilepushntodatastack(        pBHarrayhead,        sqstrlen);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileacopyofsscopytoname);        return;    }}const char* dg_compilecopystonewstringname = "dg_compilecopystonewstring";void dg_compilecopystonewstring (    Bufferhandle* pBHarrayhead,    const char* pstring,    UINT64 stringlength){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // compile call over string    dg_compilecalloffset (        pBHarrayhead,        stringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }        // compile a copy of the string    dg_compilesegment (        pBHarrayhead,        (const char*)pstring,        stringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }        // pop length to parameter 1 out of 0 to 2    dg_compilepopregfromret(        pBHarrayhead,        dg_rsi);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }        dg_compilealignretstack(        pBHarrayhead,        3);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }        dg_compilemovntoreg(        pBHarrayhead,        stringlength,        dg_rdx);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }        dg_compilecalladdress(        pBHarrayhead,        (UINT64)&dg_stonewstring);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonewstringname);        return;    }}const char* dg_compilecopystonew0stringname = "dg_compilecopystonew0string";void dg_compilecopystonew0string (    Bufferhandle* pBHarrayhead,    const char* pstring,    UINT64 stringlength){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // compile call over string    dg_compilecalloffset (        pBHarrayhead,        stringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }        // compile a copy of the string    dg_compilesegment (        pBHarrayhead,        (const char*)pstring,        stringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }        // pop length to parameter 1 out of 0 to 2    dg_compilepopregfromret(        pBHarrayhead,        dg_rsi);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }        dg_compilealignretstack(        pBHarrayhead,        3);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }        dg_compilemovntoreg(        pBHarrayhead,        stringlength,        dg_rdx);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }        dg_compilecalladdress(        pBHarrayhead,        (UINT64)&dg_stonew0string);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecopystonew0stringname);        return;    }}const char* dg_compilecalloffsetinsamebuffername = "dg_compilecalloffsetinsamebuffer";void dg_compilecalloffsetinsamebuffer (    Bufferhandle* pBHarrayhead,    INT64 targetoffset){    unsigned char pbuf[6] = "\xE8\x00\x00\x00\x00";    UINT64 calloffsetcodelength = 5; // this must be the number of bytes in the call        UINT64 sourceoffset = 0;    UINT64 compilebufid = 0;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        compilebufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilecalloffsetinsamebuffername);        return;    }        sourceoffset = calloffsetcodelength + dg_getbufferlength(        pBHarrayhead,        compilebufid); // not checking overflow        // since buffers are limited to 2 gigs in length, overflow can't really happen        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecalloffsetinsamebuffername);        return;    }        if (((targetoffset - sourceoffset) + 0x80000000) >= 0x100000000)    {        // push error that offset is too big        dg_pusherror(pBHarrayhead, dg_branchtoobigerror);        dg_pusherror(pBHarrayhead, dg_compilecalloffsetinsamebuffername);        return;    }        *(INT32*)(&(pbuf[1])) = (INT32)(targetoffset - sourceoffset);        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         5);}const char* dg_compilejmpoffsetinsamebuffername = "dg_compilejmpoffsetinsamebuffer";void dg_compilejmpoffsetinsamebuffer (    Bufferhandle* pBHarrayhead,    INT64 targetoffset){    unsigned char pbuf[6] = "\xE9\x00\x00\x00\x00";    UINT64 calloffsetcodelength = 5; // this must be the number of bytes in the call        UINT64 sourceoffset = 0;    UINT64 compilebufid = 0;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        compilebufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilejmpoffsetinsamebuffername);        return;    }        sourceoffset = calloffsetcodelength + dg_getbufferlength(        pBHarrayhead,        compilebufid); // not checking overflow        // since buffers are limited to 2 gigs in length, overflow can't really happen        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilejmpoffsetinsamebuffername);        return;    }        if (((targetoffset - sourceoffset) + 0x80000000) >= 0x100000000)    {        // push error that offset is too big        dg_pusherror(pBHarrayhead, dg_branchtoobigerror);        dg_pusherror(pBHarrayhead, dg_compilejmpoffsetinsamebuffername);        return;    }        *(INT32*)(&(pbuf[1])) = (INT32)(targetoffset - sourceoffset);        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        5);}/*void dg_compilejumptoaddress (    Bufferhandle* pBHarrayhead,    UINT64 addr){    // [RIP+0] 64BIT JMP,   0xFF 0x25 0x00 0x00 0x00 0x00    // 64BIT address        0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00        // movl nn->rax  0x48 0xB8 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    // jump rax      0xFF 0xE0 ( ff /4 )        // unsigned char pbuf[13] = "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xE0";        unsigned char pbuf[15] = "\xFF\x25\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";        *(UINT64*)(&(pbuf[4])) = addr;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         14);}*/void dg_compilecalladdress (    Bufferhandle* pBHarrayhead,    UINT64 addr){    // [RIP+2] 64BIT CALL,     0xFF 0x15 0x02 0x00 0x00 0x00    // here+8 always BRANCH,   0xEB 0x08    // 64BIT address           0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00        // movl nn->rax  0x48 0xB8 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    // call rax      0xFF 0xD0  ( ff /2 )        unsigned char pbuf[13] = "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xD0";        // unsigned char pbuf [17] = "\xFF\x15\x02\x00\x00\x00\xEB\x08\x00\x00\x00\x00\x00\x00\x00\x00";        *(UINT64*)(&(pbuf[2])) = addr;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         12);}/*void dg_compilejmpaddress (    Bufferhandle* pBHarrayhead,    UINT64 addr){    // [RIP+2] 64BIT CALL,     0xFF 0x15 0x02 0x00 0x00 0x00    // here+8 always BRANCH,   0xEB 0x08    // 64BIT address           0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00        // movl nn->rax  0x48 0xB8 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    // call rax      0xFF 0xD0  ( ff /2 )        unsigned char pbuf[13] = "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xE0";        // unsigned char pbuf [17] = "\xFF\x15\x02\x00\x00\x00\xEB\x08\x00\x00\x00\x00\x00\x00\x00\x00";        *(UINT64*)(&(pbuf[2])) = addr;        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        12);}*//*void dg_compilecalladdresspreserveregs (    Bufferhandle* pBHarrayhead,    UINT64 addr){    dg_compilecalladdress(        pBHarrayhead,        addr);}*/// what about 2 [RIP+N] CALL, NEVER IF, address to call THEN, // this compiles a push pBHarrayhead to the return stack before the callvoid dg_compilecallfunctblfunction (    Bufferhandle* pBHarrayhead,    UINT64 functionindex){    // assumes already aligned, and any other parameters pushed            // EBP 8 [R+N] EAX MOV,       movl eax<-[ebp+8]     0x8B 0x45 0x08    // EAX PUSH,                  pushl eax             0x50    // EAX oftbl [R+N] EAX MOV,   movl eax<-[eax+oftbl] 0x8B 0x40 oftbl    // EAX findex 4 * [R+N] CALL, call [eax+4*findex]   0xFF 0x50 UINT8findex*4    //                                                  0xFF 0x90 UINT64findex*4        // unsigned char pbuf[14] = "\x8B\x45\x08\x50\x8B\x40\x00\xFF\x90\x00\x00\x00\x00";        // pbuf[6] = bufferhandleppfunctbloffset; // assumes offset to function table < 0x100        // *(UINT64*)(&(pbuf[9])) = functionindex * 4;            // RDI oftbl [R+N] RAX MOV,      0x48 0x8B 0x47 oftbl    // RAX findex 8 * [R+N] CALL,    0xFF 0x90 0x00 0x00 0x00 0x00    unsigned char pbuf[11] = "\x48\x8B\x47\x00\xFF\x90\x00\x00\x00\x00";        pbuf[3] = bufferhandleppfunctbloffset; // assumes offset to function table < 0x100        // might want to check to see if the result is positive    *(INT32*)(&(pbuf[6])) = functionindex * 8;        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         10);}////////////////////////////////////////////////////////////////////////////// modR/M  mod R/N R/M //          -- --- ---unsigned char dg_packmodrslashm (    UINT64 mode,    UINT64 reg1orn,    UINT64 reg2ormem){     return( (unsigned char)( (reg2ormem & 0x7) | ((reg1orn & 0x7)<<3) | ((mode & 0x3)<<6) ) );}// SIB scale index base//        --   ---  ---unsigned char dg_packsib (    UINT64 basereg,    UINT64 indexscalecode,    UINT64 indexreg){    return ( (unsigned char)( (basereg & 0x7) | ((indexreg & 0x7)<<3) | (( indexscalecode & 0x3)<<6) ) );    }// modR/M  mod R/N R/M//          -- --- ---UINT64 dg_packtwobytevex (    UINT64 simdprefixcode, // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2  bits 8 - 9    UINT64 vectorlength, // 0 = 128, 1 = 256                          bit 10    UINT64 secondsourcereg, // 0-15  // 0 if unused... this is the default bits 11 - 14 gets inverted    UINT64 rexdotr) // 0 or 1  bit 15 gets inverted{     return(       (0xC5) |       ((simdprefixcode & 3) << 8) |       ((vectorlength & 1) << 10) |       (((~secondsourcereg) & 0xF) << 11) |       (((~rexdotr) & 1) << 15)        );}UINT64 dg_packthreebytevex (    UINT64 leadingopcodebytescode, // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A  bits 8 - 12    UINT64 rexdotb, // 0 or 1  bit 13    UINT64 rexdotx, // 0 or 1  bit 14    UINT64 rexdotr, // 0 or 1  bit 15    UINT64 simdprefixcode, // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2   bits 16 and 17    UINT64 vectorlength, // 0 = 128, 1 = 256  bit 18    UINT64 secondsourcereg, // 0-15  bits 19-22  0 if unused... this is the default    UINT64 rexdotw)         // 0 or 1 comes from opcode sequence apparently  bit 23{     return(       (0xC4) |       ( (leadingopcodebytescode & 0x1F) << 8 ) |       ( ( (~rexdotb) & 1 ) << 13 ) |       ( ( (~rexdotx) & 1 ) << 14 ) |       ( ( (~rexdotr) & 1 ) << 15 ) |       ( (simdprefixcode & 3) << 16 ) |       ( (vectorlength & 1) << 18 ) |       ( ( (~secondsourcereg) & 0xF ) << 19 ) |       ( (rexdotw & 1) << 23 )    // 0 or 1 comes from opcode sequence apparently    );}const char* dg_compilevexname = "dg_compilevex";void dg_compilevex ( // need to add way to force promotion to 3 byte vex...    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf,    UINT64 addresssize,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 rexdotw, // 0x48 comes from opcode I think    UINT64 usethreebytevex) // not zero means use three byte vex{ // wrxb    UINT64 rexdotb = 0; // 0x41    UINT64 rexdotx = 0; // 0x42    UINT64 rexdotr = 0; // 0x44    UINT64 vectorlength = 0;    UINT64 rexdotv = 0;        UINT64 x;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (psf->secondsourcereg == dg_noreg)    {        psf->secondsourcereg = dg_xmm0;    }        if (dg_isrexsrcordestreg(psf->secondsourcereg))    {        rexdotv = 0x8;    }        if (8 == addresssize)    {        x = 0;        if (psf->memmode == dg_memmodedefaultreg)        {            if (psf->mod == 3) // target is register, so allow all rex registers            {                    // May 14, 2018                /*                // if dil, sil, bpl, or spl then need 0x40                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                */                // I think only xmm is allowed..                if (dg_isrexsrcordestreg(psf->rslashm))                {                    rexdotb = 1; // 0x41                }            }            else            {                // if reg is rsp, size not needed...                //  making the default reg form not have rex                //  but the explicitely declared reg from will have rex                // does this actually do anything, since rsp is not a rex register?                if (psf->rslashm != dg_rsp)                {                    /*                    // if dil, sil, bpl, or spl then need 0x40                    if (dg_issildilbplorspl(psf->rslashm))                    {                        c = 0x40;                    }                    */                                        if (dg_isrexbaseorindexreg(psf->rslashm))                    {                        rexdotb = 1; // 0x41                    }                }            }        }                if ( // (psf->memmode == dg_memmodereg) ||            (psf->memmode == dg_memmodemodrslashm) ||            (psf->memmode == dg_memmodexmmreg))        {            if (psf->mod == 3) // target is register, so allow all rex registers            {                    // May 14, 2018                /*                // if dil, sil, bpl, or spl then need 0x40                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                */                                if (dg_isrexsrcordestreg(psf->rslashm))                {                    rexdotb = 1; // 0x41 c = 0x41;                }            }            else            {   // target is memory, so only rex address pointer registers are allowed                // if dil, sil, bpl, or spl then need 0x40                /*                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                */                                if (dg_isrexbaseorindexreg(psf->rslashm))                {                    rexdotb = 1; // 0x41 c = 0x41;                }            }        }                if (psf->memmode == dg_memmodesib)        {            if (dg_isrexbaseorindexreg(psf->basereg))            {                rexdotb = 1; // 0x41 c = 0x41;            }                        if (dg_isrexbaseorindexreg(psf->indexreg))            {                rexdotx = 1; // c = c | 0x42;            }        }                if (psf->memmode == dg_memmodevsib)        {            if (dg_isrexbaseorindexreg(psf->basereg))            {                rexdotb = 1; // 0x41 c = 0x41;            }                        if (dg_isxvindexreg(psf->indexreg))            {                rexdotx = 1; // c = c | 0x42;            }        }                /*        // if using xmm, no rex for size        if (psf->usesxmmandmemtargetsize == 0)        {            if (8 == psf->size)            {                c = c | 0x48;            }        }        */                /*        // if dil, sil, bpl, or spl then need 0x40        if (dg_issildilbplorspl(psf->targetreg))        {            c = c | 0x40;        }        */                if(dg_isrexsrcordestreg(psf->targetreg) != FORTH_FALSE)        {            rexdotr = 1; // c = c | 0x44;        }                if (psf->size == 32)        {            vectorlength = 1;        }                if (             (rexdotw != 0) ||             (rexdotb != 0) ||             (rexdotx != 0) ||             (leadingopcodebytescode != 1) || // using two byte vex assumes 0x0F leading opcode byte             (usethreebytevex != 0)           )        {            x = dg_packthreebytevex (                leadingopcodebytescode, // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A                rexdotb, // 0 or 1                rexdotx, // 0 or 1                rexdotr, // 0 or 1                simdprefixcode, // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2                vectorlength, // 0 = 128, 1 = 256                rexdotv | (psf->secondsourcereg & 0x7), // 0-15                rexdotw);         // 0 or 1 comes from opcode sequence apparently                        dg_compilesegment (                pBHarrayhead,                (const char*)&x,                3);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilevexname);                return;            }        }        else        {            x = dg_packtwobytevex (                simdprefixcode, // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2                vectorlength, // 0 = 128, 1 = 256                rexdotv | (psf->secondsourcereg & 0x7), // 0-15                rexdotr); // 0 or 1                        dg_compilesegment (                pBHarrayhead,                (const char*)&x,                2);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilevexname);                return;            }        }                /*        if (c != 0)        {            // if using rex and one of the regs was ah, bh, ch, or dh... give error            if (dg_ishighbytereg(psf->targetreg))            {                dg_pusherror(pBHarrayhead, (const char*)" can't use ah, bh, ch, or dh when a rex prefix is required");                dg_pusherror(pBHarrayhead, dg_compilerexname);                return;            }                        if (dg_ishighbytereg(psf->basereg))  // checking base reg will probably cover all the cases that can come up            {                                    //  if not... have to check rslashm                dg_pusherror(pBHarrayhead, (const char*)" can't use ah, bh, ch, or dh when a rex prefix is required");                dg_pusherror(pBHarrayhead, dg_compilerexname);                return;            }                    dg_compilesegment (                pBHarrayhead,                (const char*)&c,                1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilerexname);                return;            }        }        */    }}/*// need mode too... whether in 32d or 64 bit modeunsigned char dg_packrex (    UINT64 size,    UINT64 regr,    UINT64 regx,    UINT64 regb){    unsigned char rex = 0x80;        if (dg_sizeqword == size)    {        rex = rex | 0x08;    }        if ((regr & 0x0f) > 0x07)    {        rex = rex | 0x04;    }        if ((regx & 0x0f) > 0x07)    {        rex = rex | 0x02;    }        if ((regb & 0x0f) > 0x07)    {        rex = rex | 0x01;    }        return (rex);}*/const char* dg_compilesubnfromrspname = "dg_compilesubnfromrsp";void dg_compilesubnfromrsp(    Bufferhandle* pBHarrayhead,    UINT64 n){    // subq  rsp - 0x0n -> rsp                0x48 0x83 0xEC 0x00    unsigned char mycode[5] =  "\x48\x83\xEC\x00";    unsigned char mycode2[8] = "\x48\x81\xEC\x00\x00\x00\x00";    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return;    }        // offset is guaranteed to be -...    if (n <= 0x7F)    {        mycode[3] = (unsigned char)n; // assumes n is in range...                dg_compilesegment(            pBHarrayhead,            (const char*)mycode,            4);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilesubnfromrspname);        }                    return;    }        if (n <= 0x7FFFFFFF)    {               // if n is in range of n32        *( (UINT32*)(&(mycode2[3])) ) = (UINT32)n;                dg_compilesegment(            pBHarrayhead,            (const char*)mycode2,            7);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilesubnfromrspname);        }                    return;    }        dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);    dg_pusherror(pBHarrayhead, dg_compilesubnfromrspname);}const char* dg_compileaddnlocalstocallsubsframename = "dg_compileaddnlocalstocallsubsframe";void dg_compileaddnlocalstocallsubsframe (    Bufferhandle* pBHarrayhead,    UINT64 n){    // if n in range of n8    // movq  [rbp-0x20] -> rsp                0x48 0x8B 0x65 0xE0  // seems rex is needed    // subq  rsp - 0x0n -> rsp                0x48 0x83 0xEC 0x00    // movq  rsp -> [rbp-0x20]                0x48 0x89 0x65 0xE0  // seems rex is needed        // if n in range of n32    // movq  [rbp-0x20] -> rsp                0x48 0x8B 0x65 0xE0  // seems rex is needed    // subq  rsp - 0x0n -> rsp                0x48 0x81 0xEC 0x00 0x00 0x00 0x00    // movq  rsp -> [rbp-0x20]                0x48 0x89 0x65 0xE0  // seems rex is needed        INT64 offset;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        unsigned char n8string[13]  = "\x48\x8B\x65\xE0\x48\x83\xEC\x00\x48\x89\x65\xE0";    unsigned char n32string[16] = "\x48\x8B\x65\xE0\x48\x81\xEC\x00\x00\x00\x00\x48\x89\x65\xE0";        // check for overflow ...    if (n > (largestsignedint / sizeof(UINT64)))    {        dg_pusherror(pBHarrayhead, dg_invalidparametererror);        dg_pusherror(pBHarrayhead, dg_compileaddnlocalstocallsubsframename);        return;    }        offset = (((INT64)n) * sizeof(UINT64));        // offset is guaranteed to be -...    // if ((offset >= -0x80) && (offset <= 0x7F))
    if ((UINT64)(offset + 0x80) < 0x100)    {        // if n is in range of n8        n8string[7] = (UINT8)(((UINT64)offset) & 0xFF);                dg_compilesegment(            pBHarrayhead,            (const char*)n8string,            12);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compileaddnlocalstocallsubsframename);        }                    return;    }        // mac os x c compiler does the wrong thing if you give it -0x80000000 - 3/30/2022 J.N.    if ((offset >= (INT64)0xFFFFFFFF80000000) && (offset <= 0x7FFFFFFF))    {        // if n is in range of n32        *( (UINT32*)(&(n32string[7])) ) = (UINT32)(((UINT64)offset) & 0xFFFFFFFF);                dg_compilesegment(            pBHarrayhead,            (const char*)n32string,            15);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compileaddnlocalstocallsubsframename);        }                    return;    }        dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);    dg_pusherror(pBHarrayhead, dg_compileaddnlocalstocallsubsframename);}// on mac os x for x86 you need to align the stack to a 16 byte boundary before calling any gcc compiled code or//   any operating system or 3rd party library function due to the strong possibility the called routine will//   use the new x86 instructions requiring 16 byte alignment// stack pointer from before aligment already saved in subroutine frame// so to call a subroutine requiring aligment you do://   align stack for number of parameters you are going to push//   push parameters for subroutine//     stack should now be 16 byte aligned//   call subroutine//   (drop parameters from subroutine not needed because undoing alignment will drop them)//   undo aligment using saved stack pointer in subroutine frame//// (esp - (n*4) - x)&0x0f = 0 // n = number of parameters, x = alignment in bytes// (esp - (n*4))&0x0f = x     // assuming & is distributive, which it is, just choosing which bits// movl esp -> eax// subl eax - (4*n)&(0x0f) -> eax   // use signed or unsigned 8 bit because 0 < (4*(n+1))&(0x0f) < 0x10// andl eax & 0x0f -> eax               // use signed or unsigned 8 bit because 0 < x < 0x10// subl esp - eax -> esp                // // what if I put how many bytes I'm subtracting or adding onto the frame?//   If you know where you currently are...//   If we know how much local storage has been allocated then we can use just subl,//    but if we don't we have to do what we have below...// this alignment code does not affect any registers except the return stack pointer of course//  it affects flags at this time// this aligment code allows for local variable space to be added to the return stack at run time//  just push to return stack or subtract from esp and then and movl esp -> [ebp -0x30]const char* dg_compilealignretstackname = "dg_compilealignretstack";void dg_compilealignretstack(    Bufferhandle* pBHarrayhead,    UINT64 numberofparameters){    // movq  [rbp-0x20] -> rsp                0x48 0x8B 0x65 0xE0  // seems rex is needed    // andq  rsp & 0xfffffffffffffff0 -> rsp  0x48 0x83 0xE4 0xF0    // subq  rsp - 0x0n -> rsp                0x48 0x83 0xEC 0x00    unsigned char mycode[13]  = "\x48\x8B\x65\xE0\x48\x83\xE4\xF0\x48\x83\xEC\x08";        UINT64 length = 8;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (numberofparameters > 6)    {        if ((numberofparameters & 1) == 1)        {            length = 12;        }    }        dg_compilesegment (        pBHarrayhead,        (const char*)mycode,        length);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilealignretstackname);    }}// on mac os x for x86 you need to align the stack to a 16 byte boundary before calling any gcc compiled code or//   any operating system or 3rd party library function due to the strong possibility the called routine will//   use the new x86 instructions requiring 16 byte alignment// stack pointer from before aligment already saved in subroutine frame// so to call a subroutine requiring aligment you do://   align stack for number of parameters you are going to push//   push parameters for subroutine//     stack should now be 16 byte aligned//   call subroutine//   (drop parameters from subroutine not needed because undoing alignment will drop them)//   undo aligment using saved stack pointer in subroutine frame//// (esp - (n*4) - x)&0x0f = 0 // n = number of parameters, x = alignment in bytes// (esp - (n*4))&0x0f = x     // assuming & is distributive, which it is, just choosing which bits// movl esp -> eax// subl eax - (4*n)&(0x0f) -> eax   // use signed or unsigned 8 bit because 0 < (4*(n+1))&(0x0f) < 0x10// andl eax & 0x0f -> eax               // use signed or unsigned 8 bit because 0 < x < 0x10// subl esp - eax -> esp                // // this alignment code does not affect any registers except the return stack pointer of course//  it affects flags at this time// this aligment code allows for local variable space to be added to the return stack at run time//  just push to return stack or subtract from esp and then and movl esp -> [ebp -0x30]const char* dg_compilealignretstackbname = "dg_compilealignretstackb";void dg_compilealignretstackb(    Bufferhandle* pBHarrayhead,    UINT64 numberofintparameters,    UINT64 numberoffloatparameters){    // movq  [rbp-0x20] -> rsp                0x48 0x8B 0x65 0xE0  // seems rex is needed    // andq  rsp & 0xfffffffffffffff0 -> rsp  0x48 0x83 0xE4 0xF0    // subq  rsp - 0x0n -> rsp                0x48 0x83 0xEC 0x00    unsigned char mycode[13] = "\x48\x8B\x65\xE0\x48\x83\xE4\xF0\x48\x83\xEC\x08";        UINT64 length = 8;    UINT64 numberofparametersonstack = 0;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (numberofintparameters > 6)    {        numberofparametersonstack = numberofintparameters - 6;    }        if (numberoffloatparameters > 8)    {        numberofparametersonstack += (numberoffloatparameters - 8);    }        if ((numberofparametersonstack & 1) == 1)    {        length = 12;    }        dg_compilesegment (        pBHarrayhead,        (const char*)mycode,        length);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilealignretstackbname);    }}// compiled code does not trash registers//   and does not make assumptions about alignment of locals pointerconst char* dg_forthcompilealignretfornname = "COMPILE-ALIGN-RET-FOR-N";void dg_forthcompilealignretforn (Bufferhandle* pBHarrayhead){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompilealignretfornname);    }        dg_compilealignretstack(        pBHarrayhead,        n);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompilealignretfornname);    }}// assumes subroutine is using standard frame and pBHarrayhead is first parametervoid dg_compilepushpBHarrayheadtoret (Bufferhandle* pBHarrayhead){    // pushq [rbp-0x10]    // unsigned char pbuf[4] = "\xFF\x75\xF0";        // movq [rbp-0x10] -> rdi                0x48 0x8B 0x7D 0xF0    unsigned char pbuf[5] = "\x48\x8B\x7D\xF0";        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         4);}const char* dg_compilecallcorename = "dg_compilecallcore";void dg_compilecallcore (    Bufferhandle* pBHarrayhead,     UINT64 addr){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilealignretstack(pBHarrayhead, 1); // align for 1 paramater        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecallcorename);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecallcorename);        return;    }        dg_compilecalladdress (pBHarrayhead, addr);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecallcorename);        return;    }}const char* dg_compilecallcoreoneuparamname = "dg_compilecallcoreoneuparam";

void dg_compilecallcoreoneuparam (
    Bufferhandle* pBHarrayhead, 
    UINT64 addr,
    UINT64 uparam1)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);
    
    if (baderrorcount == olderrorcount)
    {
        return;
    }
    
    dg_compilealignretstack(pBHarrayhead, 2); // align for 1 paramater
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoreoneuparamname);
        return;
    }

    dg_compilemovntoreg(
        pBHarrayhead,
        uparam1,
        dg_param2reg);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoreoneuparamname);
        return;
    }
    
    dg_compilepushpBHarrayheadtoret(pBHarrayhead);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoreoneuparamname);
        return;
    }
    
    dg_compilecalladdress (pBHarrayhead, addr);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoreoneuparamname);
        return;
    }
}


const char* dg_compilecallcoretwouparamsname = "dg_compilecallcoretwouparams";

void dg_compilecallcoretwouparams (
    Bufferhandle* pBHarrayhead, 
    UINT64 addr,
    UINT64 uparam1,
    UINT64 uparam2)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);
    
    if (baderrorcount == olderrorcount)
    {
        return;
    }
    
    dg_compilealignretstack(pBHarrayhead, 3); // align for 1 paramater
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoretwouparamsname);
        return;
    }

    dg_compilemovntoreg(
        pBHarrayhead,
        uparam2,
        dg_param3reg);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoretwouparamsname);
        return;
    }

    dg_compilemovntoreg(
        pBHarrayhead,
        uparam1,
        dg_param2reg);

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoretwouparamsname);
        return;
    }
    
    dg_compilepushpBHarrayheadtoret(pBHarrayhead);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoretwouparamsname);
        return;
    }
    
    dg_compilecalladdress (pBHarrayhead, addr);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compilecallcoretwouparamsname);
        return;
    }
}const char* dg_compilecallftcolonname = "dg_compilecallftcolon";void dg_compilecallftcolon (    Bufferhandle* pBHarrayhead,     UINT64 n){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilealignretstack(        pBHarrayhead,        1); // align for 1 paramater        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecallftcolonname);        return;    }        dg_compilecallfunctblfunction (        pBHarrayhead,        n);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecallftcolonname);        return;    }}// this compile call routine allows for removing two parameters on return instead of just one// this routine assumes code compiled just before this code leaves n on the return stack// might be simpler to just write this out in the routines that use thisconst char* dg_compilepushdatastackname = "dg_compilepushdatastack";void dg_compilepushdatastack (Bufferhandle* pBHarrayhead){    UINT64 bufferid;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        bufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilepopregfromret(        pBHarrayhead,        dg_rsi);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilealignretstack(        pBHarrayhead,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilecalladdress (pBHarrayhead, (UINT64)(&dg_pushdatastack));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }}// this compile call routine allows for removing two parameters on return instead of just one// this routine assumes code compiled just before this code leaves n in the rsi register// might be simpler to just write this out in the routines that use thisconst char* dg_compilepushntodatastackname = "dg_compilepushntodatastack";void dg_compilepushntodatastack (    Bufferhandle* pBHarrayhead,    UINT64 n){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        dg_compilealignretstack(        pBHarrayhead,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilemovntoreg(        pBHarrayhead,        n,        dg_rsi);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }        dg_compilecalladdress(        pBHarrayhead,        (UINT64)(&dg_pushdatastack));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushdatastackname);        return;    }}// this compile call routine allows for removing two parameters on return instead of just one// this routine assumes code compiled just before this code leaves n in the rsi register// might be simpler to just write this out in the routines that use thisconst char* dg_compilepushntof64stackname = "dg_compilepushntof64stack";void dg_compilepushntof64stack (    Bufferhandle* pBHarrayhead,    UINT64 n)  // simpler to leave type as UINT64 and avoid all the weird casting{    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        dg_compilealignretstack(        pBHarrayhead,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushntof64stackname);        return;    }        dg_compilemovntoreg(        pBHarrayhead,        n,        dg_rsi);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushntof64stackname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushntof64stackname);        return;    }        dg_compilecalladdress(        pBHarrayhead,        (UINT64)(&dg_pushf64stack));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushntof64stackname);        return;    }}const char* dg_compileobtoptodatastackname = "dg_compileobtoptodatastack";

void dg_compileobtoptodatastack (
    Bufferhandle* pBHarrayhead,
    UINT64 bufferid,
    UINT64 offset)
{
    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);
    
    dg_compilealignretstack(
        pBHarrayhead,
        3);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilemovntoreg(
        pBHarrayhead,
        offset,
        dg_param3reg); // dg_r8);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilemovntoreg(
        pBHarrayhead,
        bufferid,
        dg_param2reg); // dg_rdx); // bufferid
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilepushpBHarrayheadtoret(pBHarrayhead);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilecalladdress(
        pBHarrayhead,
        (UINT64)(&dg_getpbufferoffset));
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    // moo 
    dg_compilealignretstack(
        pBHarrayhead,
        2);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilemovregtoreg(
        pBHarrayhead,
        dg_rax,
        dg_param2reg); // dg_rsi); // rsi is incorrect 2022 6/23 J.N.
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilepushpBHarrayheadtoret(pBHarrayhead);
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
    
    dg_compilecalladdress(
        pBHarrayhead,
        (UINT64)(&dg_pushdatastack));
    
    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_compileobtoptodatastackname);
        return;
    }
}
const char* dg_compilobtoptodatastackname = "dg_compilobtoptodatastack";void dg_compilobtoptodatastack (    Bufferhandle* pBHarrayhead,    UINT64 bufferid,    UINT64 offset){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        dg_compilealignretstack(        pBHarrayhead,        3);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilemovntoreg(        pBHarrayhead,        offset,        dg_rdx);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilemovntoreg(        pBHarrayhead,        bufferid,        dg_rsi); // bufferid        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilecalladdress(        pBHarrayhead,        (UINT64)(&dg_getpbufferoffset));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilealignretstack(        pBHarrayhead,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilemovregtoreg(        pBHarrayhead,        dg_rax,        dg_rsi);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilepushpBHarrayheadtoret(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }        dg_compilecalladdress(        pBHarrayhead,        (UINT64)(&dg_pushdatastack));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilobtoptodatastackname);        return;    }}// +00 saved rbp// -08 saved flags// -10 pBHarrayhead (RDI)// -18 old error count// -20 end of locals (change this to mark where subroutine's return stack stuff is)// -28 RAX// -30 safe return offset// -38 safe return bufferid// -40 jump buffer address (pBHarrayhead + sizeof(Bufferhandle))void dg_compileinitlocals (Bufferhandle* pBHarrayhead){    // this is ridiculously complicated    unsigned char pbuf[24] = "\x55\x48\x8B\xEC\x9C\x9C\x48\x81\x65\xF0\xFF\xFF\xFB\xFF\x9D\x57\xFF\x37\x57\x48\x89\x65\xE0";    // unsigned char pbuf[14] =    "\x55\x48\x8B\xEC\x9C\x57\xFF\x37\x57\x48\x89\x65\xE0";    // unsigned char pbuf[6] = "\x55\x48\x8B\xEC\x9C";    UINT64 currentcompilebufferid;    UINT64 currentcompilebufferlength;        // rdi = pBHarrayhead        // pushq rbp;            0x55             (0x50+rd)    // movq rbp<-rsp;       ( 0x48 ) 0x8B 0xEC   (0x8B /r)  r/m32 -> r32 = 11 101 100        // pushfq                0x9C        // this clears the alignment check flag which disables exceptions     //  which can happen if an unaligned memory access occurs    // pushfq                0x9C    // andq [rbp-0x10]<-[rbp-0x10]&$^(0x0000000000040000)  // clear aligment check flag    //                       0x48 0x81 0x65 0xF0 0xFF 0xFF 0xFB 0xFF    (0x81 /4) // 01 100 101    // popfq                 0x9D        // pushq pBHarrayhead    //  pushq rdi            0x57             (0x50+rd)    // pushq old error count    //  pushq [rdi]          0xFF 0x37        (0xff /6) (error count) // 00 110 111    // pushq rdi             0x57             // for end of locals variable            // rsp holds end of locals, this is used during alignment code calculations for subroutine calls    // movq rsp->[rbp-0x20]  0x48 0x89 0x65 0xE0    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        23);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompileentername);    }

    dg_putbufferuint64(
        pBHarrayhead,
        DG_DATASPACE_BUFFERID,
        dg_colonreturnstackdepth,
        4); // for -0x20

    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)
    {
        dg_pusherror(pBHarrayhead, dg_forthcompileentername);
    }}//const char* dg_compileexitlocalsname = "EXIT-LOCALS,";// This function assumes you are using the Diaperglu standard frame, which means//  you used dg_compileinitlocals at the beginning of the subroutine you are//  compiling.void dg_compileexitlocals (Bufferhandle* pBHarrayhead){    UINT64 haslocalsflag;    UINT64 haslocalstringsflag;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        /*    haslocalsflag = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_colonhaslocalsflag);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompileexitname);        return;    }        if (haslocalsflag != FORTH_FALSE)    {        // compile a call to dg_restorelocalstackdepth        dg_compilecallcore(            pBHarrayhead,            (UINT64)&dg_restorelocalstackdepth);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcompileexitname);            return;        }    }        haslocalstringsflag = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_colonhaslocalstringsflag);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompileexitname);        return;    }        if (haslocalstringsflag != FORTH_FALSE)    {        // compile a call to dg_restorelocalstackdepth        dg_compilecallcore(            pBHarrayhead,            (UINT64)&dg_restorelocallsstackdepth);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcompileexitname);            return;        }    }    */    //                         not sure if rex is needed for leaq    // leaq [rbp-0x8] -> rsp   0x48 0x8D 0x65 0xF8   (0x8D /r = 01 100 101)  (drops everything up to saved flags)    // popfq                   0x9D             // -0x08    // popq rbp;               0x5D             // rbp -0x00    // ret                     0xC3        dg_compilesegment (        pBHarrayhead,        (const char*)"\x48\x8D\x65\xF8\x9D\x5D\xC3",        7);        if (olderrorcount != dg_geterrorcount(pBHarrayhead))    {        dg_pusherror(pBHarrayhead, dg_forthcompileexitname);    }}void dg_compileentersubroutineframe (Bufferhandle* pBHarrayhead){    dg_compileinitlocals(pBHarrayhead);    /*    unsigned char pbuf[32] = "\x55\x8B\xEC\x53\x50\x50\x9C\x9C\x81\x65\xEC\xFF\xFF\xFB\xFF\x9D\xE8\x00\x00\x00\x00\x81\x04\x24\x00\x00\x00\x00\x89\x65\xF4";    UINT64 currentcompilebufferid;    UINT64 currentcompilebufferlength;     // pushl ebp;            0x55             (0x50+rd)    // movl ebp<-esp;        0x8B 0xEC        (0x8B /r)  r/m32 -> r32 = 11 101 100    // pushl ebx             0x53        // push empty value so frame is same size as colon frame    // pushl eax             0x50             // error count in colon frame, not used in this one    // pushl eax             0x50             // for end of locals variable    // pushfl                0x9C        // this clears the alignment check flag which disables exceptions     //  which can happen if an unaligned memory access occurs    // pushfl                0x9C    // andl [ebp-0x14]<-[ebp-0x14]&$^(0x00040000)  // clear aligment check flag    //                       0x81 0x65 0xEC 0xFF 0xFF 0xFB 0xFF    (0x81 /4) // 01 100 101    // popfl                 0x9D        // push pointer to beginning of current compile buffer    // call eip+0            0xE8 0x00 0x00 0x00 0x00    // addl [esp]<-offsetto0 0x81 0x04 0x24 0xnn 0xnn 0xnn 0xnn        // esp holds end of locals, this is used during alignment code calculations for subroutine calls    // movl esp->[ebp-0x0C]  0x89 0x65 0xF4    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        currentcompilebufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompileentersubname);        return;    }        currentcompilebufferlength = dg_getbufferlength(        pBHarrayhead,        currentcompilebufferid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompileentersubname);        return;    }        *(UINT64*)(&(pbuf[24])) = -(currentcompilebufferlength + 21);        // +24 gets -(currentcompileoffset+21)    dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        31);        // dg_compilesegment (    //    pBHarrayhead,    //    (const char*)"\x55\x8B\xEC\x53\x8B\x45\x08\xFF\x30\x50\x9C\x9C\x81\x65\xEC\xFF\xFF\xFB\xFF\x9D\x89\x65\xF4",    //    23);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompileentersubname);    }    */}// +00 saved rbp// -08 saved flags// -10 param 0 (RDI)// -18 param 1 (RSI)// -20 end of locals (change this to mark where subroutine's return stack stuff is)const char dg_forthentercallsubsframecommaname[] = "ENTER-CALL-SUBS-FRAME,";void dg_forthentercallsubsframecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[13] = "\x55\x48\x8B\xEC\x9C\x57\x56\x57\x48\x89\x65\xE0";    // pushq rbp;            0x55             (0x50+rd)    // movq rbp<-rsp;        0x48 0x8B 0xEC   (0x8B /r)  r/m32 -> r32 = 11 101 100    // pushfq                0x9C    // pushq rdi             0x57             (0x50+rd)  // param 0    // pushq rsi             0x56             (0x50+rd)  // param 1    // pushq rdi             0x57             // for end of locals variable        // rsp holds end of locals, this is used during alignment code calculations for subroutine calls    // movq rsp->[rbp-0x20]  0x48 0x89 0x65 0xE0    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)pbuf,        12);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthentercallsubsframecommaname);    }}const char dg_forthexitcallsubsframecommaname[]  = "EXIT-CALL-SUBS-FRAME,";// same as dg_compileexitlocalsconst char* dg_compilepusholderrcnttoretname = "COMPILE-OLDERRORCOUNT>RET";void dg_compilepusholderrorcounttoret (Bufferhandle* pBHarrayhead){    // push [rpb-18]  0xff /6 = 01 110 101 = 0xFF 0x75 0xE8    dg_compilesegment (        pBHarrayhead,        (const char*)"\xFF\x75\xE8",        3);}const char* dg_compilequeryerrorname = "COMPILE-QUERYERROR";void dg_compilequeryerror (Bufferhandle* pBHarrayhead){    // movq rax<-[rpb-10]; (pBHarrayhead)    // movq rax<-[rax];   (current error count)    // cmpq rax<-[rbp-18] (old error count)    dg_compilesegment (        pBHarrayhead,        (const char*)"\x48\x8B\x45\xF0\x48\x8B\x00\x48\x3B\x45\xE8",        11);}/*      <div class=word id=dg_compilesavelocalframestackpointer><pre>/////////////////////////////////////////////////////////////////////////////////////// dg_compilesavelocalframestackpointer   //// C prototype://  void dg_compilesavelocalframestackpointer (Bufferhandle* pBHarrayhead)//// Inputs://  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is //                                 used as the bufferhandle for the array where the //                                 other bufferhandles are stored.//                                                          // Action://  Compiles code to update the end of local variable address saved in the//   subroutine frame with the current value of the return stack pointer.//// Note://  Diaperglu uses a different technique to drop parameters and unalign the return//   stack pointer after a subroutine call. It uses a local variable saved as part//   of the subroutine's frame to keep track of the end of local variable storage //   so all the subroutine has to do is set the return stack pointer to this value //   to drop everything on the return stack. This means there needs to be a way to //   update the this value to allocate more local variable storage for the //   subroutine. That is what this function is for.////  To use this function,//   1st) You need to be using the standard Diaperglu frame in your subroutine.//    This means you called dg_initlocals at the beginning of your subroutine.//   2nd) Compile code to push stuff to the return stack that you are going to use//    as local variables... meaning you want it to still be there after you call//    a subroutine.//   3rd) Call this function to compile code to allocate local variable//   storage before compiling calls to any subroutines.// // Failure cases://  current compile buffer id is for a nonexistent invalid buffer//  out of memory when trying to grow current compile buffer//  ///////////////////////////////////////////////////////////////////////////////////</pre>      </div>*//*void dg_compilesavelocalframestackpointer (Bufferhandle* pBHarrayhead){    // movl esp->[ebp-0x0C]  0x89 0x65 0xF4   (save frame stack pointer, marks top of local storage)    // movq rsp->[ebp-0x20]  0x48 0x89 0x65 0xE0    dg_compilesegment (        pBHarrayhead,        (const char*)"\x48\x89\x65\xE0",        4);}*/// compiled code no longer trashes the eax register//   and does not make assumptions about alignment of locals pointerconst char* dg_forthcompilealignretfornpfname = "COMPILE-ALIGN-RET-FOR-N-PRESERVE-FLAGS";void dg_forthcompilealignretfornpf (Bufferhandle* pBHarrayhead){    dg_forthcompilealignretforn (pBHarrayhead);}// +00 saved rbp// -08 saved flags// -10 pBHarrayhead// -18 old error count// -20 end of locals (change this to mark where subroutine's return stack stuff is)void dg_showframe (Bufferhandle* pBHarrayhead){    UINT64* showframeframepointer = (UINT64*)dg_getframepointer();    UINT64* callerframepointer = (UINT64*)(showframeframepointer[0]);        UINT64  mystackpointer = (UINT64)dg_getretstackpointer();        // dont want to show frame of this subroutine, so need to get frame of routine that called dg_showframe        dg_printzerostring(pBHarrayhead, (unsigned char*)"frame pointer of caller's parent = ");    dg_writestdoutuint64tohex(pBHarrayhead, callerframepointer[0]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)"\ncaller's frame pointer = ");    dg_writestdoutuint64tohex(pBHarrayhead, (UINT64)callerframepointer);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)" caller's frame's return address = ");    dg_writestdoutuint64tohex(pBHarrayhead, callerframepointer[1]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)" caller's frame's saved flags = ");    dg_writestdoutuint64tohex(pBHarrayhead, callerframepointer[-1]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)" caller's frame's saved pBHarrayhead = ");    dg_writestdoutuint64tohex(pBHarrayhead, callerframepointer[-2]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)" caller's frame's old error count = ");    dg_writestdoutuint64tohex(pBHarrayhead, callerframepointer[-3]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)" caller's frame's bottom of local frame = ");    dg_writestdoutuint64tohex(pBHarrayhead, callerframepointer[-4]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)"\ndg_showframe's frame pointer = ");    dg_writestdoutuint64tohex(pBHarrayhead, (UINT64)showframeframepointer);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)" return address from caller = ");    dg_writestdoutuint64tohex(pBHarrayhead, showframeframepointer[1]);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");}// need to modify this for r8-r15void dg_compilepushregtoret (    Bufferhandle* pBHarrayhead,    UINT64 reg){    // assumes reg is 64bit    unsigned char pbuf[3] = "\x41\x50";        pbuf[1] = ((unsigned char)reg & 0x7) + 0x50;        if (reg >= dg_rax)    {        dg_compilesegment(pBHarrayhead, (const char*)(pbuf + 1), 1);    }    else    {        dg_compilesegment(pBHarrayhead, (const char*)pbuf, 2);    }}////  void dg_compileresulttoparameter (//    Bufferhandle* pBHarrayhead,//    UINT64 parementer) // assumes parameters compiled in reverse order//    // compiles RAX parameterreg -> MOV,//        or RAX PUSH, depending on which parameter it is/*// parameter index is 0 based and goes up by 1svoid dg_compilepushparametertoret (    Bufferhandle* pBHarrayhead,    UINT64 parameterindex){    // I should push an error here if parameter index is too large    //  or... make it work...    // not checking overflow, trying to use this with negative indexes will not work    unsigned char x = (unsigned char)(((parameterindex*4)+8)&0xff);             // pushl [epb+x]    unsigned char pbuf[4] = "\xFF\x75\x00";        pbuf[2] = x;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         3);}*/void dg_compilepopregfromret (    Bufferhandle* pBHarrayhead,    UINT64 reg){    // assumes reg is 64bit    unsigned char pbuf[3] = "\x41\x58";        pbuf[1] = ((unsigned char)reg & 0x7) + 0x58;        if (reg >= dg_rax)    {        dg_compilesegment(pBHarrayhead, (const char*)(pbuf + 1), 1);    }    else    {        dg_compilesegment(pBHarrayhead, (const char*)pbuf, 2);    }}// I think I can do a 64bit offset using://  branch opposite past jump//  [RIP+N] 64BIT JMP, where n = 0//  64 bit address to jump to// to keep it pic.. could do this (uses rax though)//  branch opposite past relative 64 bit jump//    [RIP+N] RAX LEA,//    RAX JMP,//   or...//     0 RIP+N CALL,//     RSP [R]  offset N ADD,//     RETconst char* dg_compilebranchname = "dg_compilebranch";UINT64 dg_compilebranch (    Bufferhandle* pBHarrayhead,    UINT64 branchtype){    UINT64 cbufferid;    UINT64 afterbranchoffset = (UINT64)dg_badbufferid;        unsigned char pbuf[7] = "\x0F\x80\x00\x00\x00\x00";        unsigned char x = ((unsigned char)(branchtype & 0x0f)) + 0x80;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == dg_geterrorcount(pBHarrayhead))    {        return(afterbranchoffset);    }        cbufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilebranchname);        return (afterbranchoffset);    }        if (branchtype > DG_BRANCHTYPE_ALWAYS)    {        //afterbranchoffset = dg_getbufferlength(pBHarrayhead, cbufferid);                //if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        //{        //    dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        //    dg_pusherror(pBHarrayhead, dg_compilebranchname);        //}                afterbranchoffset = (UINT64)-1;                return (afterbranchoffset);    }        if (branchtype == DG_BRANCHTYPE_ALWAYS)    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\xE9\x00\x00\x00\x00", // branch always nowhere            5);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilebranchname);            return (afterbranchoffset);        }                afterbranchoffset = dg_getbufferlength(            pBHarrayhead,            cbufferid);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);            dg_pusherror(pBHarrayhead, dg_compilebranchname);        }                return (afterbranchoffset);    }        pbuf[1] = x;        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         6);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilebranchname);    }        afterbranchoffset = dg_getbufferlength(        pBHarrayhead,        cbufferid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilebranchname);    }        return (afterbranchoffset);}const char* dg_resolvecompiledbranchname = "dg_resolvecompiledbranch";void dg_resolvecompiledbranch(    Bufferhandle* pBHarrayhead,    UINT64 afterbranchoffset,    UINT64 targetoffset){    UINT64 compilebufid;        unsigned char* pcompilebuf;    UINT64* pcompilebuflength;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return;    }    compilebufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);        return;    }    pcompilebuf = dg_getpbuffer(        pBHarrayhead,        compilebufid,        &pcompilebuflength);    if (pcompilebuf == (unsigned char*)badbufferhandle)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);        return;    }        // Someone compiled a branch never. This is not an error.    //  Nothing to resovle so just return.    if ((UINT64)-1 == afterbranchoffset)    {        return;    }    // afterbranchoffset = to current compile buffer length should be allowed    if (afterbranchoffset > *pcompilebuflength)    {        dg_pusherror(pBHarrayhead, dg_branchsourcepastenderror);        dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);        return;    }        // could check to see if offset > max INT32, this means    //  someone compiled a REAAALLLY big buffer    if (targetoffset > *pcompilebuflength)    {        dg_pusherror(pBHarrayhead, dg_branchsourcepastenderror);        dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);        return;    }    if (afterbranchoffset < 5)    {        // branch off beginning of buffer        dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);        return;    }        if ( ((*(pcompilebuf + afterbranchoffset - 5)) & 0xF0) != 0x80 )  // the parenthesis are needed here for correct calculation    {        if ( (*(pcompilebuf + afterbranchoffset - 5)) != 0xE9)        {            if (afterbranchoffset < 6) // for XBEGINBRANCH,            {                // branch off beginning of buffer                dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);                return;            }                        if ( ( (*(pcompilebuf + afterbranchoffset - 6)) != 0xC7 ) &&                 ( (*(pcompilebuf + afterbranchoffset - 5)) != 0xF8 ) )            {                dg_pusherror(pBHarrayhead, dg_branchopcodemissingerror);                dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);                return;            }        }    }        if (*((UINT32*)(pcompilebuf + (afterbranchoffset - 4))) != 0)    {        dg_pusherror(pBHarrayhead, dg_branchalreadyresolvederror);        dg_pusherror(pBHarrayhead, dg_resolvecompiledbranchname);        return;    }    *((UINT32*)(pcompilebuf + (afterbranchoffset - 4))) = targetoffset - afterbranchoffset;}// this has some problems... need to do a more thorough testconst char* dg_resolvecompiled8bitbranchname = "dg_resolvecompiled8bitbranch";void dg_resolvecompiled8bitbranch(    Bufferhandle* pBHarrayhead,    UINT64 afterbranchoffset,    UINT64 targetoffset){    UINT64 compilebufid;        unsigned char* pcompilebuf;    UINT64* pcompilebuflength;        INT64 displacement;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    compilebufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);        return;    }    pcompilebuf = dg_getpbuffer(        pBHarrayhead,        compilebufid,        &pcompilebuflength);    if (pcompilebuf == (unsigned char*)badbufferhandle)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);        return;    }    // afterbranchoffset = to current compile buffer length should be allowed    if (afterbranchoffset > *pcompilebuflength)    {        dg_pusherror(pBHarrayhead, dg_branchsourcepastenderror);        dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);        return;    }    if (targetoffset > *pcompilebuflength)    {        dg_pusherror(pBHarrayhead, dg_branchsourcepastenderror);        dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);        return;    }    if (afterbranchoffset < 1)    {        // branch off beginning of buffer        dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);        return;    }        displacement = targetoffset - afterbranchoffset;        if ( (displacement > 0x7F) ||         (displacement < -0x80) )    {        // instead of doing error, do this....        // make displacement +5        *((UINT64*)(pcompilebuf + (afterbranchoffset - 1))) = 5;                // compile branch always + 5 (takes 5 bytes)        dg_compilesegment(            pBHarrayhead,            (const char*)"\xE9\x05\x00\x00\x00",            5);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);            return;        }                // compile branch always to begin (takes 5 bytes)        displacement = targetoffset - (afterbranchoffset + 10);                dg_compilesegment(            pBHarrayhead,            (const char*)"\xE9",            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);            return;        }                  dg_compilesegment(            pBHarrayhead,            (const char*)&displacement,            sizeof(INT64));                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);            return;        }                  //dg_pusherror(pBHarrayhead, dg_branchtoobigerror);        //dg_pusherror(pBHarrayhead, dg_resolvecompiled8bitbranchname);        return;    }    *((unsigned char*)(pcompilebuf + (afterbranchoffset - 1))) =        (unsigned char)(displacement & 0xff);}const char* dg_compilecomparename = "dg_compilecompare";void dg_compilecompare(    Bufferhandle* pBHarrayhead,    UINT64 n){    // cmp eax - nnnnnnnn     unsigned char pbuf[7] = "\x48\x3D\x00\x00\x00\x00";    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    // could check and compile smaller opcodes for n=0        // check to see if n > max INT32    if ((n + 0x80000000) >= 0x100000000)    {        // push error that offset is too big        dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);        dg_pusherror(pBHarrayhead, dg_compilecomparename);        return;    }        *(UINT32*)(&(pbuf[2])) = n;    dg_compilesegment(pBHarrayhead, (const char*)pbuf, 6);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecomparename);        return;    }}/*const char* dg_compileundoalignretstackname = "dg_compileundoalignretstack";void dg_compileundoalignretstack (Bufferhandle* pBHarrayhead){    // don't need to do this because the next align will drop everything}*//*// n is the number of parametersvoid dg_compiledropparametersfromret (Bufferhandle* pBHarrayhead, UINT64 n){    // dont need to do this because align code drops paramaters    // and exit automatically drops everything}*/// if n is too big...// compile push [RIP+N] where n = 2// compile 8 bit branch over n// compile 64 bit n// this routine returns the buffer offset of the compiled UINT64 n dataconst char* dg_compilepushntoretname = "dg_compilepushntoret";UINT64 dg_compilepushntoret (    Bufferhandle* pBHarrayhead,    UINT64 n){    UINT64 ccbufferid;    UINT64 targetoffset = (UINT64)-1;        // n N PUSH, ( 64BIT )    unsigned char pbuf[6] = "\x68\x00\x00\x00\x00";        // n N RSP 4 [R+N] 32BIT MOV,    unsigned char pbuf2[9] = "\xC7\x44\x24\x04\x00\x00\x00\x00";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return(targetoffset);    }        *(UINT32*)(&(pbuf[1])) = (UINT32)(n & 0xFFFFFFFF);        ccbufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilepushntoretname);        return(targetoffset);    }        dg_compilesegment(        pBHarrayhead,        (const char*)pbuf,        5);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepushntoretname);        return(targetoffset);    }        // in 32 bit mode... probably want -80000000 to 180000000    if ((n + 0x80000000) >= 0x100000000)    {        *(UINT32*)(&(pbuf2[4])) = (UINT32)(n >> 4);                dg_compilesegment(            pBHarrayhead,            (const char*)pbuf2,            8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilepushntoretname);            return(targetoffset);        }    }        // bufferlength can't be less than 5 if dg_compilesegment worked so no need to check    //   subtraction underflow    // also dg_getbufferlength can't really fail either    targetoffset = dg_getbufferlength(        pBHarrayhead,        ccbufferid) - sizeof(UINT64);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compilepushntoretname);        return(targetoffset);    }        return (targetoffset);}const char* dg_compilentoparametername = "dg_compilentoparameter";void dg_compilentoparameter (    Bufferhandle* pBHarrayhead,    UINT64 n,    UINT64 parameter) // 0 based, 0 = first parameter{    UINT64 regparametertable[6] =    {        dg_rdi,        dg_rsi,        dg_rdx,        dg_rcx,        dg_r8,        dg_r9    };        if (parameter < 6)    {        dg_compilemovntoreg(            pBHarrayhead,            n,            regparametertable[parameter]);                return;    }        dg_compilepushntoret(        pBHarrayhead,        n);}void dg_forthcompilesafecallbuffer (Bufferhandle* pBHarrayhead)//     ( bufferoffset bufferid -- ){    UINT64* pbuflength;    unsigned char* pdatastack;        UINT64* pints;        UINT64 compilebufid;        UINT64 ccbuflength;    UINT64 finalccbuflength;        UINT64 x;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        dg_compilealignretstack(        pBHarrayhead,        7); // want just the and rsp... to get multiple of 16        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        pdatastack = dg_getpbuffer(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        &pbuflength);        if (pdatastack == (unsigned char*)badbufferhandle)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        if (*pbuflength < (2 * sizeof(UINT64)) )    {        dg_pusherror(pBHarrayhead, dg_datastackunderflowerror);        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        // could check for misaligned data stack here        pints = (UINT64*)(pdatastack + *pbuflength - (2 * sizeof(UINT64)));        compilebufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        ccbuflength = dg_getbufferlength(        pBHarrayhead,        compilebufid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        // safe call to forth routine//  rdi <- pBHarrayhead    0x48 0x8B 0x7D 0xF0//  push return offset (don't know it yet...)//  push return bufferid//  push address of jump buffer (this is where forth routine returns)//  rdx <- target offset//  rsi <- target bufferid//  rax <- &getpbufferoffset//  jmp rax OR do the RIP [R] JMP, thing    // push offset    dg_compilemovntorax ( // "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00" 10 bytes        pBHarrayhead,        0); // return offset        dg_compilepushregtoret( // "\x50" 2 bytes        pBHarrayhead,        dg_rax);        // dg_compilemovregtobracketrbpd8(    //    pBHarrayhead,    //    dg_rax,    //    -0x30); // return offset        // push bufferid    dg_compilemovntorax ( // "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00" 10 bytes        pBHarrayhead,        compilebufid); // return bufferid (which is current compile bufferid)        // dg_compilemovregtobracketrbpd8(    //    pBHarrayhead,    //    dg_rax,    //    -0x38); // return bufferid        dg_compilepushregtoret( // "\x50" 2 bytes        pBHarrayhead,        dg_rax);// push pBHarrayhead + sizeof(Bufferhandle) .. this is the return address        dg_compilemovbracketrbpd8toreg (        pBHarrayhead,        dg_rax,        -0x10); // -0x10        dg_compileaddn32torax (        pBHarrayhead,        sizeof(Bufferhandle));        // dg_compilemovregtobracketrbpd8(    //    pBHarrayhead,    //    dg_rax,    //    -0x40); // return bufferid        dg_compilepushregtoret( // "\x50" 2 bytes        pBHarrayhead,        dg_rax);        dg_compilemovntoreg ( // "\x48\xBE\x00\x00\x00\x00\x00\x00\x00\x00" 10 bytes        pBHarrayhead,        pints[1],        dg_rsi); // target bufferid        dg_compilemovntoreg ( // "\x48\xBA\x00\x00\x00\x00\x00\x00\x00\x00" 10 bytes        pBHarrayhead,        pints[0],        dg_rdx); // target offset        dg_compilemovbracketrbpd8toreg (        pBHarrayhead,        dg_rdi,        -0x10); // pBHarrayhead from frame        dg_compilecalladdress ( // "\xFF\x15\x02\x00\x00\x00\xEB\x08\x00\x00\x00\x00\x00\x00\x00\x00" 16 bytes        pBHarrayhead,        (UINT64)&dg_getpbufferoffset); // target address        // dg_compilepushbracketrbpd8 (    //    pBHarrayhead,    //    -0x40);        dg_compilemovbracketrbpd8toreg (        pBHarrayhead,        dg_rdi,        -0x10); // pBHarrayhead from frame        dg_compilejumptorax(pBHarrayhead); // "\xFF\xE0" 2 bytes        // dg_compilecalltorax(pBHarrayhead);        // could put here to targetoffset location    finalccbuflength = dg_getbufferlength(        pBHarrayhead,        compilebufid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        dg_putbufferuint64(        pBHarrayhead,        compilebufid,        ccbuflength+2,        finalccbuflength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcompilesafecallbuffername);        return;    }        (*pbuflength) -= (2 * sizeof(UINT64));}// normal call to forth routine//  rsp <- rsp - 8//  rdi <- pBHarrayhead//  call forth routine// safe call to forth routine//  rdi <- pBHarrayhead//  push offset//  push bufferid//  push pBHarrayhead//  push address of jump buffer (this is where forth routine returns)//  jump to forth routine//  jump buffer does//   pop rdi//   pop rsi//   pop rdx//   call getpbufferoffset//   jmp rax/*void jmpbuffer (void)// ( offset buffid pBHarrayhead -ret- )// jumpbuffer assumes there is NO return address on the stack, //  just pBHarrayhead, bufferid, and offset//  to get this, you JUMP to this routine, or return to it.{    __asm    {        call dg_getpbufferoffset        pop ecx        pop ecx        pop ecx        jmp eax            }}*/const char* dg_initjumpbuffername = "dg_initjumpbuffer";// jump boffer code assumes it is being called from a subroutine that did init localsvoid dg_initjumpbuffer (Bufferhandle* pBHarrayhead){    const char* pError;        // popq  rsi                              0x5E // bufferid    // popq  rdx                              0x5A // offset    // movq  [rbp-0x10] -> rdi                0x48 0x8B 0x7D 0xF0  // pBHarrayhead    // movq  [rbp-0x20] -> rsp                0x48 0x8B 0x65 0xE0  // seems rex is needed    // andq  rsp & 0xfffffffffffffff0 -> rsp  0x48 0x83 0xE4 0xF0    // subq  rsp - 0x08n -> rsp               0x48 0x83 0xEC 0x08    // movq  &dg_getpbufferoffset -> rax      0x48 0xB8 0xnn 0xnn 0xnn 0xnn 0xnn 0xnn 0xnn 0xnn    // call  rax                              0xFF 0xD0    // jump  rax                              0xFF 0xE0        unsigned char pbuf[33] = "\x5E\x5A\x48\x8B\x7D\xF0\x48\x8B\x65\xE0\x48\x83\xE4\xF0\x48\x83\xEC\x08\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xD0\xFF\xE0";    // unsigned char pbuf[39] = "\x48\x8B\x55\xD0\x48\x8B\x75\xC8\x48\x8B\x7D\xF0\x48\x8B\x65\xE0\x48\x83\xE4\xF0\x48\x83\xEC\x08\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xD0\xFF\xE0";    *((UINT64*)(pbuf + 20)) = (UINT64)(&dg_getpbufferoffset);        pError = dg_movebytes(        pbuf,        ((unsigned char*)pBHarrayhead) + sizeof(Bufferhandle),        32);        if (pError != dg_success)    {        dg_pusherror(pBHarrayhead, pError);        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_initjumpbuffername);    }}/*// this wont work because the gcc compiled code up to and including calling dg_forthregsfrom trashes the registers//  need to call dg_forthregsfrom from dgluvoid dg_forthshowcapturedregs (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    UINT64 x = 0;        if (baderrorcount == olderrorcount)    {        return;    }                dg_printzerostring(pBHarrayhead, (unsigned char*)"eflags = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"eax = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"ebx = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"ecx = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"edx = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"esi = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"edi = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"esp = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_printzerostring(pBHarrayhead, (unsigned char*)"ebp = ");                x = dg_popdatastack(pBHarrayhead);        dg_writestdoutuint64tohex(pBHarrayhead, x);        dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");}*/void dg_initSibformatter (struct dg_Sibformatter* psf){    psf->basereg = dg_noreg;    psf->indexreg = dg_noreg;    psf->scale = 1;    psf->displacementsize = dg_sizenone;    psf->displacement = 0;    psf->targetreg = dg_noreg; // this one has to eventually be set    psf->direction = 0; // for forward    psf->size = 0; // default size... will become dword    psf->mod = 0;    psf->rslashm = 0;    psf->memmode = dg_memmodeunknown;    psf->immediatesize = 0;  // for use smallest possible    psf->immediatevalue = 0;    psf->immediatevaluehi = 0;    psf->offset = (UINT64)-1;    psf->bufferid = dg_badbufferid;    psf->usesxmmandmemtargetsize = 0;    psf->secondsourcereg = dg_noreg;    psf->usesthreebytevex = 0;}  // displacement is signedvoid dg_bumpdisplacementsizeifneeded (dg_Sibformatter* psf){    if (psf->displacement == 0)    {        return;    }        if ((psf->displacementsize == dg_sizenone) ||        (psf->displacementsize == dg_sizebyte) )    {        if ( (psf->displacement < 0x80) &&             (psf->displacement >= -0x80) )        {            psf->displacementsize = dg_sizebyte;            return;        }    }        psf->displacementsize = dg_sizedword;}void dg_setmod(dg_Sibformatter* psf){    // promote ebp displacement size to byte if basereg is ebp, rbp, or r13    if (psf->displacementsize == dg_sizenone)    {        if ( (psf->basereg == dg_ebp) ||             (psf->basereg == dg_rbp) ||             (psf->basereg == dg_r13)         )        {            psf->displacementsize = dg_sizebyte;        }    }        // if displacementsize is none (and base reg is not ebp, rbp, or r13) then mod = 0    if (psf->displacementsize == dg_sizenone)    {        psf->mod = 0;    }        // now need to set mode based on displacementsize    // if displacementsize is byte, mod = 1    if (psf->displacementsize == dg_sizebyte)    {        psf->mod = 1;    }        // if displacementsize is dword, mod = 2    if (psf->displacementsize == dg_sizedword)    {        psf->mod = 2;    }}const char* dg_formatsibname = "dg_formatsib";void dg_formatsib (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 newscale;     // targetreg HAS to be set    // if (psf->targetreg == dg_noreg)    // {    //    dg_pusherror(pBHarrayhead, (const char*)"target reg not set");    //    dg_pusherror(pBHarrayhead, dg_formatsibname);    //    return;    // }         // if indexreg = esp then error out    if ((psf->indexreg == dg_esp) ||        (psf->indexreg == dg_rsp))     {        dg_pusherror(pBHarrayhead, (const char*)"index register can't be esp or rsp");        dg_pusherror(pBHarrayhead, dg_formatsibname);        return;    }        // if no basereg and there is a scale reg then error out      // (or could compile a push eax, set eax to 0, then use eax as base reg, then pop eax)    if ((psf->basereg == dg_noreg) && (psf->indexreg != dg_noreg))    {        // this might be the base reg = ebp (except index = esp) case        dg_pusherror(pBHarrayhead, (const char*)"no base register with a scale register");        dg_pusherror(pBHarrayhead, dg_formatsibname);        return;    }        // not checking scale... only lower 2 bits are used so gonna use and to ignore other bits        // bumping displacement size if needed based on value of the displacement    dg_bumpdisplacementsizeifneeded (psf);        // always be sib    psf->memmode = dg_memmodesib;    // have to set r/m, mod, scale, index, and base    // r/m is always 4    psf->rslashm = 4;        // scale doesn't change, (could force it to be 0-3)        // if no basereg and no indexreg then      // mod = 0, index = 4, base = 5, scale doesn't matter      // I think this means you are accessing an absolute address (non relative)      // this case is handled, compile and exit    if ( (psf->basereg == dg_noreg) &&          (psf->indexreg == dg_noreg) )    {        psf->mod = 0;        psf->indexreg = 4;        psf->basereg = 5;                // only dword size displacement is supported, so ignoring requests          // for any other size displacements in this case        psf->displacementsize = dg_sizedword;        return;    }    // basereg doesn't change after this point, all 7 are ok          // if no indexreg then indexreg is 4    if (psf->indexreg == dg_noreg)    {        psf->indexreg = 4;    }        dg_setmod(psf);        switch (psf->scale)    {        case 1:           newscale = 0;           break;        case 2:            newscale = 1;            break;        case 4:            newscale = 2;            break;        case 8:            newscale = 3;            break;        default:            newscale = 0;            dg_pusherror(pBHarrayhead, (const char*)"unknown scale - must be one of 1, 2, 4, or 8");            dg_pusherror(pBHarrayhead, dg_formatsibname);            break;    }        psf->scale = newscale;    }// this routine does not handle the mod = 3 reg to reg case  // this routine only handles reg to mem or mem to reg casesconst char* dg_formatmodrslashmname = "dg_formatmodrslashm";void dg_formatmodrslashm (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 addresssize;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_formatmodrslashmname);        return;    }        // only basereg, displacement, displacementsize, and targetreg are set    // targetreg HAS to be set        // if (psf->targetreg == dg_noreg)    // {    //    dg_pusherror(pBHarrayhead, (const char*)"target reg not set");    //    dg_pusherror(pBHarrayhead, dg_formatmodrslashmname);    //    return;    // }            if (psf->memmode == dg_memmodebufferoffset)    {        if (8 == addresssize)        {            // this is pc relative mode, must use modr/m            psf->rslashm = dg_ebp;            psf->displacementsize = 4; // displacementsize is always 4 with this mode            psf->mod = 0;            return;        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"eip/rip relative addressing only supported in 64 bit mode at this time... can use [O]PUSH, and [O]POP, instead.");            dg_pusherror(pBHarrayhead, dg_formatmodrslashmname);            return;        }                return;    }        // if indexreg is set, could use sib instead      // technically this shouldn't happen, if this routine is called index reg shoul      // be dg_noreg    if (psf->indexreg != dg_noreg)    {        dg_formatsib (            pBHarrayhead,            psf);                return;    }        if (psf->basereg == dg_noreg)    {        // this is absolute address mode... must use sib in 64 bit mode        if (8 == addresssize)        {            dg_formatsib (                pBHarrayhead,                psf);                        return;        }        else        {            // absolute address mode in 32 bit mode... could also sib            psf->rslashm = dg_ebp;            psf->displacementsize = 4; // displacementsize is always 4 with this mode            psf->mod = 0;            return;        }                return;    }        // psf->memmode = dg_memmodemodrslashm;        // this doesn't work in x86-32bit mode...    if ((psf->basereg == dg_eip) ||        (psf->basereg == dg_rip))    {        if (8 == addresssize)        {            // this is pc relative mode, must use modr/m            psf->rslashm = dg_ebp;            psf->displacementsize = 4; // displacementsize is always 4 with this mode            psf->mod = 0;            return;        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"eip/rip relative addressing only supported in 64 bit mode at this time... can use [O]PUSH, and [O]POP, instead.");            dg_pusherror(pBHarrayhead, dg_formatmodrslashmname);            return;        }                return;    }            // scale not used so not checking it        // bump up displacement size if needed     dg_bumpdisplacementsizeifneeded (psf);        // use sib if basereg is esp or rsp    if ((psf->basereg == dg_esp) ||        (psf->basereg == dg_rsp))    {        dg_formatsib (            pBHarrayhead,            psf);                    return;    }        dg_setmod(psf);        psf->rslashm = psf->basereg;}void dg_formatreg(    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    psf->mod = 3;    psf->rslashm = psf->basereg;}unsigned char dg_calculatemodrslashm (dg_Sibformatter* psf){    return( dg_packmodrslashm(psf->mod, psf->targetreg, psf->rslashm) );}unsigned char dg_calculatesib (dg_Sibformatter* psf){    return( dg_packsib (psf->basereg, psf->scale, psf->indexreg) );}// could probably speed this up with a logic function...UINT64 dg_getsizefromreg (UINT64 reg){    if (reg <= dg_bh)    {        return (1);    }        if (reg <= dg_di)    {        return (2);    }        if (reg <= dg_edi)    {        return (4);    }        if (reg <= dg_r15l)    {        return (1);    }        if (reg <= dg_r15w)    {        return (2);    }        if (reg <= dg_r15d)    {        return (4);    }        if (reg <= dg_rdi)    {        return (8);    }        if (reg <= dg_dil)    {        return (1);    }        if (reg == dg_eip)    {        return (4);    }        if (reg == dg_rip)    {        return (8);    }        return ((UINT64)-1);}// in 32 bit mode, base reg must be one of EAX, EBX, ECX, EDX, EBP, ESP, EDI, ESI// in 64 bit mode, base reg must be one of RAX, RBX, RCX, RDX, RBP, RSP, RDI, RSI,//  R8, R9, R10, R11, R12, R13, R14, or R15const char* dg_asmmodenotsupported = " - assembler only supports 32 bit (4 byte addressing) and 64 bit (8 byte addressing) modes at this time";const char* dg_asm32bitbaseindexregbaderror = " - in 32 bit mode base and/or index reg must be one of: EAX, EBX, ECX, EDX, EBP, ESP, ESI, or EDI";const char* dg_asm64bitindexregbaderror = " - in 64 bit mode index reg must be one of: RAX, RBX, RCX, RDX, RBP, RSP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, or R15";const char* dg_asm64bitbaseregbaderror = " - in 64 bit mode index reg must be one of: RAX, RBX, RCX, RDX, RBP, RSP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15, or RIP";const char* dg_vindexregbaderror = " - index reg must be one of: YMM0, YMM1, YMM2, YMM3, YMM4, YMM5, YMM6, YMM7, YMM8, YMM9, YMM10, YMM11, YMM12, YMM13, YMM14, or YMM15";const char dg_checkbaseregname[] = "dg_checkbasereg";void dg_checkbasereg (    Bufferhandle* pBHarrayhead,    UINT64 reg){    UINT64 addresssize;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_checkbaseregname);        return;    }        if (4 == addresssize)    {        if (reg != dg_noreg)        {            if ((reg < dg_eax) || (reg > dg_edi))            {                dg_pusherror(pBHarrayhead, dg_asm32bitbaseindexregbaderror);                dg_pusherror(pBHarrayhead, dg_checkbaseregname);                return;            }        }    }        if (8 == addresssize)    {        if (reg != dg_noreg)        {            if ((reg < dg_r8) || (reg > dg_rdi))            {                if (reg != dg_rip)                {                    dg_pusherror(pBHarrayhead, dg_asm64bitbaseregbaderror);                    dg_pusherror(pBHarrayhead, dg_checkbaseregname);                    return;                }            }        }    }        if ((4 != addresssize) && (8 != addresssize))    {        dg_pusherror(pBHarrayhead, dg_asmmodenotsupported);        dg_pusherror(pBHarrayhead, dg_checkbaseregname);        return;    }}const char dg_checkindexregname[] = "dg_checkindexreg";void dg_checkindexreg (    Bufferhandle* pBHarrayhead,    UINT64 reg){    UINT64 addresssize;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_checkindexregname);        return;    }        if (4 == addresssize)    {        if (reg != dg_noreg)        {            if ((reg < dg_eax) || (reg > dg_edi))            {                dg_pusherror(pBHarrayhead, dg_asm32bitbaseindexregbaderror);                dg_pusherror(pBHarrayhead, dg_checkindexregname);                return;            }        }    }        if (8 == addresssize)    {        if (reg != dg_noreg)        {            if ((reg < dg_r8) || (reg > dg_rdi))            {                dg_pusherror(pBHarrayhead, dg_asm64bitindexregbaderror);                dg_pusherror(pBHarrayhead, dg_checkindexregname);                return;            }        }    }        if ((4 != addresssize) && (8 != addresssize))    {        dg_pusherror(pBHarrayhead, dg_asmmodenotsupported);        dg_pusherror(pBHarrayhead, dg_checkindexregname);        return;    }}const char dg_checkvindexregname[] = "dg_checkvindexreg";void dg_checkvindexreg (    Bufferhandle* pBHarrayhead,    UINT64 reg){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ((reg < dg_xmm0) || (reg > dg_ymm15))  // allowing xmm regs    {        dg_pusherror(pBHarrayhead, dg_vindexregbaderror);        dg_pusherror(pBHarrayhead, dg_checkvindexregname);        return;    }}const char* dg_pullmemusingsibname = "dg_pullmemusingsib";void dg_pullmemusingsib (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf)    // id for [r+s*r+d] already popped off stack    // expects ( basereg scale indexreg displacement mindisplacementsize -- ){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        psf->displacementsize = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingsibname);        return;    }        psf->displacement = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingsibname);        return;    }        psf->indexreg = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingsibname);        return;    }        psf->scale = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingsibname);        return;    }        psf->basereg = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingsibname);        return;    }    psf->memmode = dg_memmodesib;}    const char* dg_pullmemusingvsibname = "dg_pullmemusingvsib";void dg_pullmemusingvsib (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf)    // id for [r+s*r+d] already popped off stack    // expects ( basereg scale indexreg displacement mindisplacementsize -- ){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        psf->displacementsize = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingvsibname);        return;    }        psf->displacement = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingvsibname);        return;    }        psf->indexreg = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingvsibname);        return;    }        psf->scale = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingvsibname);        return;    }        psf->basereg = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingvsibname);        return;    }    psf->memmode = dg_memmodevsib;}const char* dg_pullmemusingrslashmname = "dg_pullmemusingrslashm";void dg_pullmemusingrslashm (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf)    // id for [r+d] already popped off stack    // expects ( basereg displacement mindisplacementsize -- ){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        psf->displacementsize = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingrslashmname);        return;    }        psf->displacement = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingrslashmname);        return;    }        psf->basereg = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullmemusingrslashmname);        return;    }        psf->memmode = dg_memmodemodrslashm;}UINT64 intparameterslookuptable[6] = {    dg_rdi,    dg_rsi,    dg_rdx,    dg_rcx,    dg_r8,    dg_r9};UINT64 floatparameterslookuptable[8] = {    dg_xmm0,    dg_xmm1,    dg_xmm2,    dg_xmm3,    dg_xmm4,    dg_xmm5,    dg_xmm6,    dg_xmm7};UINT64 intreturnparameterstable[2] ={    dg_rax,    dg_rdx};UINT64 floatreturnparameterstable[2] = {    dg_xmm0,    dg_xmm1};const char* dg_determineparameterregistername = "dg_determineparameterregister";UINT64 dg_determineparameterregister (    Bufferhandle* pBHarrayhead,    UINT64 parameterindex){    UINT64 parameterregister;    UINT64 numberofintparameters;    UINT64 numberoffloatparameters;    UINT64 extraparametersarefloatsflag = FORTH_FALSE;    UINT64 x;    UINT64 floatparameterindex;    UINT64 numberofintparametersonstack = 0;    // UINT64 numberoffloatparametersonstack = 0;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return((UINT64)-1);    }        numberofintparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcparameters);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_determineparameterregistername);        return((UINT64)-1);    }        numberoffloatparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcfparameters);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_determineparameterregistername);        return((UINT64)-1);    }        extraparametersarefloatsflag = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_extraparametersfloatsflag);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {         dg_pusherror(pBHarrayhead, dg_determineparameterregistername);         return((UINT64)-1);    }        if (          (parameterindex < numberofintparameters) ||         (            (parameterindex >= (numberofintparameters + numberoffloatparameters)) &&            (extraparametersarefloatsflag == FORTH_FALSE)         )       )    {        // it's an integer parameter        if (parameterindex < (sizeof(intparameterslookuptable)/sizeof(UINT64)))        {            // it's in a register            return(intparameterslookuptable[parameterindex]);        }                // it's on the stack        x = parameterindex - (sizeof(intparameterslookuptable)/sizeof(UINT64));                // I doubt this is possible but... you never know... someone inputs a ton of parameters...        if (x > dg_cparameteronstackflag)        {            dg_pusherror(pBHarrayhead, dg_parametersovermaxsizeerror);            dg_pusherror(pBHarrayhead, dg_determineparameterregistername);            return((UINT64)-1);        }                return(x | dg_cparameteronstackflag);    }        // what's the rule when you have a variable parameter list?    //  the way it is now, extra parameters are the parsing mode at the end        // it's a float parameter         floatparameterindex = parameterindex - numberofintparameters;         if (  floatparameterindex < (sizeof(floatparameterslookuptable)/sizeof(UINT64)) )    {        // it's in a register        return(floatparameterslookuptable[floatparameterindex]);    }        // it's on the stack, if there are any int parameters on the stack, it goes after that...    if (numberofintparameters > (sizeof(intparameterslookuptable)/sizeof(UINT64)))    {        numberofintparametersonstack = numberofintparameters - (sizeof(intparameterslookuptable)/sizeof(UINT64));    }    return(((floatparameterindex - (sizeof(floatparameterslookuptable)/sizeof(UINT64))) + numberofintparametersonstack) | dg_cparameteronstackflag);    }const char* dg_pulloneaddressingmodename = "dg_pulloneaddressingmode";void dg_pulloneaddressingmode(    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 addresssize;    UINT64 parametertype;    UINT64 notdoneflag = FORTH_TRUE;        // UINT64 numberofintparameters;    // UINT64 numberoffloatparameters;    // UINT64 whichintparameter;    // UINT64 whichfloatparameter;        UINT64 rstackdepth;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);        return;    }        while (notdoneflag != FORTH_FALSE)    {        parametertype = dg_popdatastack(pBHarrayhead);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);            return;        }            switch (parametertype) {                            case dg_isdatasize:                psf->size = dg_popdatastack(pBHarrayhead);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                            break;                        case dg_isforward:                break;                    case dg_isreverse:                psf->direction = 1;                break;            case dg_isimmediate:                // pull smallest allowed byte size                  // this allows you to force 32 bits when 8 bits or 0 is available                psf->immediatesize = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                // can remove this when everything is 64 bits                if ( (8 == psf->immediatesize) &&                     (4 == addresssize) )                {                    psf->immediatevaluehi = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                        return;                    }                                        psf->immediatevalue = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                        return;                    }                }                else                {                    psf->immediatevalue = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                        return;                    }                }                                notdoneflag = FORTH_FALSE;                                psf->memmode = dg_memmodeimmediate;                            break;                        case dg_isbasedisplacement:                            dg_pullmemusingrslashm (                    pBHarrayhead,                    psf);                                    notdoneflag = FORTH_FALSE;                                dg_checkbasereg(pBHarrayhead, psf->basereg);                                break;                        case dg_isbasescaleindexdisplacement:                            dg_pullmemusingsib (                    pBHarrayhead,                    psf);                                notdoneflag = FORTH_FALSE;                                dg_checkbasereg(pBHarrayhead, psf->basereg);                dg_checkindexreg(pBHarrayhead, psf->indexreg);                                break;                            case dg_isbasescalevindexdisplacement:                dg_pullmemusingvsib (                    pBHarrayhead,                    psf);                                notdoneflag = FORTH_FALSE;                                dg_checkbasereg(pBHarrayhead, psf->basereg);                dg_checkvindexreg(pBHarrayhead, psf->indexreg);  // must be ymmr (will allow xmmr)                                break;                                        case dg_ishereplusdisplacement:                            psf->displacement = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->displacementsize = 4;                psf->basereg = dg_eip; // probably have to change this to dg_rip and check addresssize;                psf->memmode = dg_memmodeeipplusn;                                 notdoneflag = FORTH_FALSE;                break;                            case dg_isbufferoffset:                            psf->bufferid = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->offset = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->memmode = dg_memmodebufferoffset;                                notdoneflag = FORTH_FALSE;                            break;                            case dg_iscurrentcompilebufferoffset:                            psf->bufferid = dg_getbufferuint64(                    pBHarrayhead,                    DG_DATASPACE_BUFFERID,                    currentcompilebuffer);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->offset = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->memmode = dg_memmodebufferoffset;                                notdoneflag = FORTH_FALSE;                            break;                            case dg_isccbufferoffsetnobracket:                            psf->bufferid = dg_getbufferuint64(                    pBHarrayhead,                    DG_DATASPACE_BUFFERID,                    currentcompilebuffer);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->offset = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->memmode = dg_memmodebufferoffsetnobracket;                                notdoneflag = FORTH_FALSE;                            break;                        case dg_isreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodereg;                }                                psf->size = dg_getsizefromreg (psf->basereg);                                notdoneflag = FORTH_FALSE;                            break;                            case dg_isfloatingpointstackreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodefpsreg;                }                                // psf->size = dg_getsizefromreg (psf->basereg);                                notdoneflag = FORTH_FALSE;                            break;                            case dg_isxmmreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodexmmreg;                }                                if ((psf->basereg >= dg_ymm0) &&                    (psf->basereg <= dg_ymm15))                {                    psf->size = 32;                }                else                {                    psf->size = 16;                }                                notdoneflag = FORTH_FALSE;                            break;                            case dg_isymmreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodexmmreg;                }                                if ((psf->basereg >= dg_xmm0) &&                    (psf->basereg <= dg_xmm15))                {                    psf->size = 16;                }                else                {                    psf->size = 32;                }                                notdoneflag = FORTH_FALSE;                            break;                        case dg_iscontrolreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodecontrolreg;                }                                psf->size = 4; // size is ignored for the MOVCR, instruction 3/17/2020                                notdoneflag = FORTH_FALSE;                            break;                        case dg_issegmentreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodesegmentreg;                }                            psf->size = 2; // for the mov sr to r opcode, it seems size is ingored,                // but the docs say you can put the 0x66 and 0x48 prefix but it seems in all                // cases the move gets 0 extended to 64 bits in 64 bit mode...                // but to allow the user the flexibility to choose the prefixes, I'm going to                // make the n SR size different from the SRn                // if the user chooses n SR, then the size of the reg will be used                // if the user chooses SRn, then size is ignored and no prefix is used. 3/17/2020                                notdoneflag = FORTH_FALSE;                            break;                        case dg_isdebugreg:                            psf->basereg = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodedebugreg;                }                                psf->size = 4; // size is ignored for the MOVDR, instruction 3/17/2020                                notdoneflag = FORTH_FALSE;                            break;                            case dg_isthreebytevex:                psf->usesthreebytevex = (UINT64)-1;                break;                            case dg_isdgluforthframelocal:                // it's on the stack relative to the frame register                //  going to make 0 be local variable 0                //  1 local variable 1, etc...                //  [rbp - 0x28] = local 0  (there are 4 things...)                //  [rbp - 0x30] = local 1 etc                parametertype = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                psf->displacementsize = 0; // use at least 0  bytes to encode the displacement                psf->displacement = -1 * (parametertype + dg_dgluframelocaloffset) * sizeof(UINT64); // not checking for overflow...                psf->basereg = dg_rbp;                       psf->memmode = dg_memmodemodrslashm;                                    notdoneflag = FORTH_FALSE;                                break;              case dg_isparamusingnoframe:                // determine parameter type, reg or stack                // do parameter type                parametertype = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                parametertype = dg_determineparameterregister (                    pBHarrayhead,                    parametertype);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (dg_cparameteronstackflag == (parametertype & dg_cparameteronstackmask) )                {                    // it's on the stack...                    // need rstack depth                    rstackdepth = dg_getbufferuint64(                        pBHarrayhead,                        DG_DATASPACE_BUFFERID,                        dg_noframereturnstackdepth);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                        return;                    }                                            psf->displacementsize = 0; // use at least 0  bytes to encode the displacement                    psf->displacement = ((parametertype & (~dg_cparameteronstackmask)) + rstackdepth) * sizeof(UINT64);                         // can't overflow because of mask                        // + 1 because function return is at 0... assumes stack pointer                        // going to need to track stack pointer offset and adjust...                    psf->basereg = dg_rsp;                           psf->memmode = dg_memmodemodrslashm;                                        notdoneflag = FORTH_FALSE;                                    break;                }                                psf->basereg = parametertype;                                if ((parametertype >= dg_xmm0) &&                    (parametertype <= dg_xmm15))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodexmmreg;                    }                                        psf->size = 16;                                        notdoneflag = FORTH_FALSE;                                        break;                }                                // promote memmode to defaultreg if not already higher                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodedefaultreg;                }                                psf->size = dg_getsizefromreg (psf->basereg);                                notdoneflag = FORTH_FALSE;                            break;                                                            case dg_isparamusingframe:                // determine parameter type, reg or stack                // do parameter type                parametertype = dg_popdatastack(pBHarrayhead);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                parametertype = dg_determineparameterregister (                    pBHarrayhead,                    parametertype);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                if (dg_cparameteronstackflag == (parametertype & dg_cparameteronstackmask) )                {                    // it's on the stack...                    // need to determine if using rbp as base reg or not and adjust                    psf->displacementsize = 0; // use at least 0  bytes to encode the displacement                    psf->displacement = ((parametertype & (~dg_cparameteronstackmask)) + dg_paramusingframeoffset) * sizeof(UINT64);                         // can't overflow because of mask                        // + 1 because function return is at 0... assumes stack pointer                        // going to need to track stack pointer offset and adjust...                    psf->basereg = dg_rbp;                           psf->memmode = dg_memmodemodrslashm;                    // psf->size = addresssize; // leaving it on default size so xmm registers work                                        notdoneflag = FORTH_FALSE;                                    break;                }                                psf->basereg = parametertype;                                if ((parametertype >= dg_xmm0) &&                    (parametertype <= dg_xmm15))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodexmmreg;                    }                                        psf->size = 16;                                        notdoneflag = FORTH_FALSE;                                        break;                }                                // promote memmode to defaultreg if not already higher                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodedefaultreg;                }                                psf->size = dg_getsizefromreg (psf->basereg);                                notdoneflag = FORTH_FALSE;                            break;                            default:                                if (dg_cparameteronstacknoframeflag == (parametertype & dg_cparameteronstackmask) )                {                    // it's on the stack...                    // need rstack depth                    rstackdepth = dg_getbufferuint64(                        pBHarrayhead,                        DG_DATASPACE_BUFFERID,                        dg_noframereturnstackdepth);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                        return;                    }                                            // need to determine if using rbp as base reg or not and adjust                    psf->displacementsize = 0; // use at least 0  bytes to encode the displacement                    psf->displacement = ((parametertype & (~dg_cparameteronstackmask)) + rstackdepth) * sizeof(UINT64);                         // can't overflow because of mask                        // + 1 because function return is at 0... assumes stack pointer                        // going to need to track stack pointer offset and adjust...                    psf->basereg = dg_rsp;                           psf->memmode = dg_memmodemodrslashm;                    // psf->size = addresssize;  // leaving it on default size so xmm registers work                                        notdoneflag = FORTH_FALSE;                                    break;                }                                if (dg_cparameteronstackflag == (parametertype & dg_cparameteronstackmask) )                {                    // it's on the stack...                    // need to determine if using rbp as base reg or not and adjust                    psf->displacementsize = 0; // use at least 0  bytes to encode the displacement                    psf->displacement = ((parametertype & (~dg_cparameteronstackmask)) + dg_paramusingframeoffset) * sizeof(UINT64);                         // can't overflow because of mask                        // + 1 because function return is at 0... assumes stack pointer                        // going to need to track stack pointer offset and adjust...                    psf->basereg = dg_rbp;                           psf->memmode = dg_memmodemodrslashm;                    // psf->size = addresssize; // leaving it on default size so xmm registers work                                        notdoneflag = FORTH_FALSE;                                    break;                }                                // assuming it is a reg of some type                psf->basereg = parametertype;                                if ((parametertype >= dg_st0) &&                    (parametertype <= dg_st7))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodefpsreg;                    }                                        notdoneflag = FORTH_FALSE;                                        break;                }                                if ((parametertype >= dg_xmm0) &&                    (parametertype <= dg_xmm15))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodexmmreg;                    }                                        psf->size = 16;                                        notdoneflag = FORTH_FALSE;                                        break;                }                                if ((parametertype >= dg_ymm0) &&                    (parametertype <= dg_ymm15))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodexmmreg;                    }                                        psf->size = 32;                                        notdoneflag = FORTH_FALSE;                                        break;                }                            if ((parametertype >= dg_cr0) &&                    (parametertype <= dg_cr15))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodecontrolreg;                    }                                        psf->size = 4; // size is ignored for the MOVCR, instruction 3/17/2020                                        notdoneflag = FORTH_FALSE;                                        break;                }                            if ((parametertype >= dg_dr0) &&                    (parametertype <= dg_dr7))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodedebugreg;                    }                                        psf->size = 4; // size is ignored for the MOVDR, instruction 3/17/2020                                        notdoneflag = FORTH_FALSE;                                        break;                }                            if ((parametertype >= dg_segregcs) &&                    (parametertype <= dg_segreggs))                {                    if (psf->memmode == dg_memmodeunknown)                    {                        psf->memmode = dg_memmodesegmentreg;                    }                                        // for the mov sr to r opcode, it seems size is ingored,                    // but the docs say you can put the 0x66 and 0x48 prefix but it seems in all                    // cases the move gets 0 extended to 64 bits in 64 bit mode...                    // but to allow the user the flexibility to choose the prefixes, I'm going to                    // make the n SR size different from the SRn                    // if the user chooses n SR, then the size of the reg will be used                    // if the user chooses SRn, then size is ignored and no prefix is used. 3/17/2020                    psf->size = 4;                                        notdoneflag = FORTH_FALSE;                                        break;                }                            // promote memmode to defaultreg if not already higher                if (psf->memmode == dg_memmodeunknown)                {                    psf->memmode = dg_memmodedefaultreg;                }                                psf->size = dg_getsizefromreg (psf->basereg);                                notdoneflag = FORTH_FALSE;                            break;        }    }}/*const char* dg_checkforvalidxmminstructionname = "dg_checkforvalidxmminstruction";void dg_checkforvalidxmminstruction (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* pfirsttarget,  // top on stack    dg_Sibformatter* psecondtarget){    // target can not be immediate    if( (pfirsttarget->memmode == dg_memmodeimmediate) ||        (psecondtarget->memmode == dg_memmodeimmediate))    {        dg_pusherror(pBHarrayhead, (const char*)"target can not be immediate");        dg_pusherror(pBHarrayhead, dg_checkforvalidxmminstructionname);        return;    }        // target can not be a floating point stack register    if( (pfirsttarget->memmode == dg_memmodefpsreg) ||        (psecondtarget->memmode == dg_memmodefpsreg))    {        dg_pusherror(pBHarrayhead, (const char*)"target can not be a floating point stack register");        dg_pusherror(pBHarrayhead, dg_checkforvalidxmminstructionname);        return;    }        // target can not be a regular register    if( (pfirsttarget->memmode == dg_memmodereg) ||        (psecondtarget->memmode == dg_memmodereg))    {        dg_pusherror(pBHarrayhead, (const char*)"target can not be a non xmm register");        dg_pusherror(pBHarrayhead, dg_checkforvalidxmminstructionname);    }                // one of the targets has to be an xmm reg    if( (pfirsttarget->memmode != dg_memmodexmmreg) &&        (psecondtarget->memmode != dg_memmodexmmreg))    {        dg_pusherror(pBHarrayhead, (const char*)"the destination must be an xmm register");        dg_pusherror(pBHarrayhead, dg_checkforvalidxmminstructionname);        return;    }        // the destination must be an xmm reg    if( (pfirsttarget->direction == 1) ||        (psecondtarget->direction == 1))    {        // reverse was specified, second target is the destination        if (psecondtarget->memmode != dg_memmodexmmreg)        {            dg_pusherror(pBHarrayhead, (const char*)"the destination must be an xmm register");            dg_pusherror(pBHarrayhead, dg_checkforvalidxmminstructionname);            return;        }    }    else    {        // forward was specified        if (pfirsttarget->memmode != dg_memmodexmmreg)        {            dg_pusherror(pBHarrayhead, (const char*)"the destination must be an xmm register");            dg_pusherror(pBHarrayhead, dg_checkforvalidxmminstructionname);            return;        }    }} */const char* dg_absoluteaddress64toobigerror = "If you are using [N] in 64 bit mode, the absolute addresses are limited to a signed 32 bits. Use a register to hold the address";const char* dg_compiledisplacementname = "dg_compiledisplacement";void dg_compiledisplacement (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 ccbufferid;    UINT64 beforedisplacementoffset;    char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ((UINT64)-1 != psf->offset)    {        ccbufferid = dg_getbufferuint64(            pBHarrayhead,            DG_DATASPACE_BUFFERID,            currentcompilebuffer);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);            dg_pusherror(pBHarrayhead, dg_compiledisplacementname);            return;        }                beforedisplacementoffset = dg_getbufferlength(            pBHarrayhead,            ccbufferid);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);            dg_pusherror(pBHarrayhead, dg_compiledisplacementname);            return;        }                if (psf->displacementsize != 4)        {            // displacement size should = 4..            dg_pusherror(pBHarrayhead, (const char*)"  expected displacement size to be 4 if you are using a current compile buffer offset. Should also be compiling as [EIP+N]");            dg_pusherror(pBHarrayhead, dg_compiledisplacementname);        }                // displacement = offset - (here + displacementsize + immediatesize)        //  displacementsize is always 4        if (psf->offset > beforedisplacementoffset) // forward offsets not supported        {            dg_pusherror(pBHarrayhead, dg_offsetpastenderror);            dg_pusherror(pBHarrayhead, dg_compiledisplacementname);            return;        }                psf->displacement =            psf->offset -            (beforedisplacementoffset + 4 + psf->immediatesize);    }        switch (psf->displacementsize)    {        case 0:            break;        case 1:            c = (char)((UINT64)psf->displacement & 0xff);                        dg_compilesegment(                pBHarrayhead,                (const char*)&c,                1);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiledisplacementname);                return;            }                        break;                    case 4:            if (((UINT64)(psf->displacement + 0x80000000)) >= 0x100000000)            {                dg_pusherror(pBHarrayhead, dg_absoluteaddress64toobigerror);                dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);                dg_pusherror(pBHarrayhead, dg_compiledisplacementname);                return;            }                        dg_compilesegment(                pBHarrayhead,                (const char*)&psf->displacement,                sizeof(INT32));                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiledisplacementname);                return;            }    }}const char* dg_formatpsfname = "dg_formatpsf";void dg_formatpsf(    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // promotions may occurr    switch (psf->memmode)    {        case dg_memmodeimmediate:                        // this is error because immediate psf should have been combined with another psf containing a target            dg_pusherror(pBHarrayhead, (const char*)"immediate value for instruction should have been combined with reg or memory target");            dg_pusherror(pBHarrayhead, dg_formatpsfname);            break;                case dg_memmodedefaultreg:        case dg_memmodereg:        case dg_memmodefpsreg:        case dg_memmodexmmreg:                        dg_formatreg(                pBHarrayhead,                psf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_formatpsfname);                return;            }                        break;                case dg_memmodebufferoffset:        case dg_memmodemodrslashm:                        dg_formatmodrslashm (                 pBHarrayhead,                 psf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_formatpsfname);                return;            }                        break;                                case dg_memmodesib:                        dg_formatsib (                pBHarrayhead,                psf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_formatpsfname);                return;            }                        break;                    default:                        dg_pusherror(pBHarrayhead, (const char*)"unknown addressing mode type");            dg_pusherror(pBHarrayhead, dg_formatpsfname);            break;    }}const char* dg_compilepsfname = "dg_compilepsf";void dg_compilepsf(    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // doing format separately from compile in case of promotions    switch (psf->memmode)    {        case dg_memmodedefaultreg:        case dg_memmodereg:        case dg_memmodefpsreg:        case dg_memmodexmmreg:                    c = dg_calculatemodrslashm(psf);                        dg_compilesegment(                pBHarrayhead,                (const char*)&c,                sizeof(unsigned char));                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilepsfname);                return;            }                        break;                case dg_memmodebufferoffset:        case dg_memmodemodrslashm:                    c = dg_calculatemodrslashm(psf);                        dg_compilesegment(                pBHarrayhead,                (const char*)&c,                sizeof(unsigned char));                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilepsfname);                return;            }                        dg_compiledisplacement(pBHarrayhead, psf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilepsfname);                return;            }                        break;                    case dg_memmodesib:                    c = dg_calculatemodrslashm(psf);                        dg_compilesegment(                pBHarrayhead,                (const char*)&c,                sizeof(unsigned char));                        c = dg_calculatesib(psf);                        dg_compilesegment(                pBHarrayhead,                (const char*)&c,                sizeof(unsigned char));                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilepsfname);                return;            }                        dg_compiledisplacement(                pBHarrayhead,                psf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilepsfname);                return;            }            break;                    default:            dg_pusherror(pBHarrayhead, dg_compilepsfname);            return;            break;    }        return;}UINT64 dg_queryisrega(UINT64 regtype){    UINT64 flag = FORTH_TRUE;        switch (regtype)    {        case dg_al:        case dg_ax:        case dg_eax:        case dg_rax:            break;        default:            flag = FORTH_FALSE;            break;    }        return (flag);}const char* dg_gettargettypename = "dg_gettargettype";UINT64 dg_gettargettype (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 flag;    UINT64 targettype;        switch (psf->memmode)    {        case dg_memmodeimmediate:            targettype = dg_targettypeimmediate;            break;                case dg_memmodedefaultreg:            flag = dg_queryisrega(psf->basereg);                        if (flag != FORTH_FALSE)            {                targettype = dg_targettyperega;            }            else            {                targettype = dg_targettypereg;            }            break;                    case dg_memmodefpsreg:            targettype = dg_targettypefpsreg;            break;                case dg_memmodexmmreg:            targettype = dg_targettypexmmreg;            break;                case dg_memmodecontrolreg:            targettype = dg_targettypecontrolreg;            break;                case dg_memmodedebugreg:            targettype = dg_targettypedebugreg;        break;                case dg_memmodesegmentreg:            targettype = dg_targettypesegmentreg;        break;                    case dg_memmodereg:            targettype = dg_targettypereg;            break;                case dg_memmodebufferoffset:        case dg_memmodemodrslashm:        case dg_memmodesib:            targettype = dg_targettypemem;            break;                    default:            targettype = dg_targettypeunknown;            break;    }        return (targettype);}const char* dg_determine2targettypename = "dg_determine2targettype";UINT64 dg_determine2targettype (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf1, // top on stack    dg_Sibformatter* psf2) // second on stack{    UINT64 targettype1;    UINT64 targettype2;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return(dg_targettypeunknown);    }        targettype1 = dg_gettargettype(        pBHarrayhead,        psf1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_determine2targettypename);        return(dg_targettypeunknown);    }        targettype2 = dg_gettargettype(        pBHarrayhead,        psf2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_determine2targettypename);        return(dg_targettypeunknown);    }    return ((targettype2 * dg_targettypenumberoftypes) + targettype1);}// for PUSH, POP,const char* dg_compilerexnosizetargetregname = "dg_compilerexnosizetargetreg";void dg_compilerexnosizetargetreg (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf,    UINT64 addresssize){    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // compiling rex    // bit 4-7 = 0100    // bit 3 = size    // bit 2 = modr/m reg extension    // bit 1 = sib index extension    // bit 0 = modr/m r/m extension, sib base extension, or opcode reg extension        // not 64 bit data so...    //  if 64 bit addressing and    //   using [R+N] with basereg (modr/m r/m) = R8 - R15    //   or [R+S*I+N] with either basereg or indexreg = R8 - R15    //  then need to compile either 0x41 or 0x43        if (8 == addresssize)    {        c = 0;                if ((psf->memmode == dg_memmodemodrslashm) ||            (psf->memmode == dg_memmodedefaultreg) ||            (psf->memmode == dg_memmodereg))        {            // if dil, sil, bpl, or spl then need 0x40             // it seems dil sil bpl spl not used with this function... but it doesn't hurt to have this...            if (dg_issildilbplorspl(psf->rslashm))            {                c = 0x40;            }                        if (dg_isrexbaseorindexreg(psf->rslashm))            {                c = 0x41;            }        }                if (psf->memmode == dg_memmodesib)        {            // if you are using sib, you are accessing memory...            //  can't get sil, dil spl, or bpl here...            if (dg_isrexbaseorindexreg(psf->basereg))            {                c = 0x41;            }                        if (dg_isrexbaseorindexreg(psf->indexreg))            {                c = c | 0x42;            }        }                if (c != 0)        {            // won't have case where a high byte reg is used            dg_compilesegment (                pBHarrayhead,                (const char*)&c,                1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilerexnosizetargetregname);                return;            }        }    }}const char* dg_compilerexnotargetregname = "dg_compilerexnotargetreg";void dg_compilerexnotargetreg (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf,    UINT64 addresssize){    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        /*    dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilerexnotargetreg\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)"addresssize = ");    dg_writestdoutuint64tohex(pBHarrayhead, addresssize);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)"memmode = ");    dg_writestdoutuint64tohex(pBHarrayhead, psf->memmode);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_printzerostring(pBHarrayhead, (unsigned char*)"rslashm = ");    dg_writestdoutuint64tohex(pBHarrayhead, psf->rslashm);    dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");    */        // compiling rex    // bit 4-7 = 0100    // bit 3 = size    // bit 2 = modr/m reg extension    // bit 1 = sib index extension    // bit 0 = modr/m r/m extension, sib base extension, or opcode reg extension        // not 64 bit data so...    //  if 64 bit addressing and    //   using [R+N] with basereg (modr/m r/m) = R8 - R15    //   or [R+S*I+N] with either basereg or indexreg = R8 - R15    //  then need to compile either 0x41 or 0x43        if (8 == addresssize)    {        c = 0;                if (psf->memmode == dg_memmodedefaultreg)        {            // if reg is rsp, size not needed...            //  making the default reg form not have rex            //  but the explicitely declared reg from will have rex            if (psf->rslashm != dg_rsp)            {                // if dil, sil, bpl, or spl then need 0x40                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                            // dg_printzerostring(pBHarrayhead, (unsigned char*)" is memmodedefaultreg\n");                if (dg_isrexbaseorindexreg(psf->rslashm))                {                    c = 0x41;                }            }        }                if ((psf->memmode == dg_memmodereg) ||            (psf->memmode == dg_memmodemodrslashm))        {            // if dil, sil, bpl, or spl then need 0x40            if (dg_issildilbplorspl(psf->rslashm))            {                c = 0x40;            }                        if (dg_isrexbaseorindexreg(psf->rslashm))            {                // dg_printzerostring(pBHarrayhead, (unsigned char*)"adding rex for base reg for modr/m");                c = 0x41;            }        }                if (psf->memmode == dg_memmodesib)        {            if (dg_isrexbaseorindexreg(psf->basereg))            {                // dg_printzerostring(pBHarrayhead, (unsigned char*)"adding rex for base reg for sib");                c = 0x41;            }                        if (dg_isrexbaseorindexreg(psf->indexreg))            {                // dg_printzerostring(pBHarrayhead, (unsigned char*)"adding rex for index reg for sib");                c = c | 0x42;            }        }                if (psf->usesxmmandmemtargetsize == 0) // if using xmm ignore size for rex        {            if (8 == psf->size)            {                // dg_printzerostring(pBHarrayhead, (unsigned char*)"adding rex for size");                c = c | 0x48;            }        }                if (c != 0)        {            dg_compilesegment (                pBHarrayhead,                (const char*)&c,                1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilerexnotargetregname);                return;            }        }    }}// assumes you are using target regconst char* dg_compilerexname = "dg_compilerex";void dg_compilerex (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf,    UINT64 addresssize){    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // compiling rex    // bit 4-7 = 0100    // bit 3 = size    // bit 2 = modr/m reg extension    // bit 1 = sib index extension    // bit 0 = modr/m r/m extension, sib base extension, or opcode reg extension        // not 64 bit data so...    //  if 64 bit addressing and    //   using [R+N] with basereg (modr/m r/m) = R8 - R15    //   or [R+S*I+N] with either basereg or indexreg = R8 - R15    //  then need to compile either 0x41 or 0x43        // need to check if it's reg or modr/m that uses a reg target instead of memory    //  if it is then use dg_isrexsrcordestreg instead of dg_isrexbaseorindexreg        if (8 == addresssize)    {        c = 0;        if (psf->memmode == dg_memmodedefaultreg)        {            if (psf->mod == 3) // target is register, so allow all rex registers            {                    // May 14, 2018                // if dil, sil, bpl, or spl then need 0x40                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                                if (dg_isrexsrcordestreg(psf->rslashm))                {                    c = 0x41;                }            }            else            {                // if reg is rsp, size not needed...                //  making the default reg form not have rex                //  but the explicitely declared reg from will have rex                // does this actually do anything, since rsp is not a rex register?                if (psf->rslashm != dg_rsp)                {                    // if dil, sil, bpl, or spl then need 0x40                    if (dg_issildilbplorspl(psf->rslashm))                    {                        c = 0x40;                    }                                        if (dg_isrexbaseorindexreg(psf->rslashm))                    {                        c = 0x41;                    }                }            }        }                if ((psf->memmode == dg_memmodereg) ||            (psf->memmode == dg_memmodemodrslashm) ||            (psf->memmode == dg_memmodexmmreg))        {            if (psf->mod == 3) // target is register, so allow all rex registers            {                    // May 14, 2018                // if dil, sil, bpl, or spl then need 0x40                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                                if (dg_isrexsrcordestreg(psf->rslashm))                {                    c = 0x41;                }            }            else            {   // target is memory, so only rex address pointer registers are allowed                // if dil, sil, bpl, or spl then need 0x40                if (dg_issildilbplorspl(psf->rslashm))                {                    c = 0x40;                }                                if (dg_isrexbaseorindexreg(psf->rslashm))                {                    c = 0x41;                }            }        }                if (psf->memmode == dg_memmodesib)        {            if (dg_isrexbaseorindexreg(psf->basereg))            {                c = 0x41;            }                        if (dg_isrexbaseorindexreg(psf->indexreg))            {                c = c | 0x42;            }        }                // if using xmm, no rex for size        if (psf->usesxmmandmemtargetsize == 0)        {            if (8 == psf->size)            {                c = c | 0x48;            }        }                // if dil, sil, bpl, or spl then need 0x40        if (dg_issildilbplorspl(psf->targetreg))        {            c = c | 0x40;        }                if(dg_isrexsrcordestreg(psf->targetreg) != FORTH_FALSE)        {            c = c | 0x44;        }                if (c != 0)        {            // if using rex and one of the regs was ah, bh, ch, or dh... give error            if (dg_ishighbytereg(psf->targetreg))            {                dg_pusherror(pBHarrayhead, (const char*)" can't use ah, bh, ch, or dh when a rex prefix is required");                dg_pusherror(pBHarrayhead, dg_compilerexname);                return;            }                        if (dg_ishighbytereg(psf->basereg))  // checking base reg will probably cover all the cases that can come up            {                                    //  if not... have to check rslashm                dg_pusherror(pBHarrayhead, (const char*)" can't use ah, bh, ch, or dh when a rex prefix is required");                dg_pusherror(pBHarrayhead, dg_compilerexname);                return;            }                    dg_compilesegment (                pBHarrayhead,                (const char*)&c,                1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilerexname);                return;            }        }    }}const char* dg_compilen8tom8name = "dg_compilen8tom8";void dg_compilen8tom8 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n8    dg_Sibformatter* pregpsf) // assumed to be m8 with m8 already set up{    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }        if ((popcodes->n8tom8.opcodestringlength == 0) ||        (popcodes->n8tom8.popcodestring == (const char*)dg_badbufferid))    {        dg_pusherror(pBHarrayhead, (const char*)"opcode for compiling immediate 8 bit to memory is not set");        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }        dg_formatpsf(        pBHarrayhead,        pregpsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }        dg_compilerexnotargetreg(        pBHarrayhead,        pregpsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n8tom8.popcodestring,        popcodes->n8tom8.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }    pregpsf->immediatesize = 1; // needed for [O] mode    pregpsf->targetreg = popcodes->n8tom8.opcodeextension;        dg_compilepsf (        pBHarrayhead,        pregpsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }        c = (unsigned char)(pimmediatepsf->immediatevalue & 0xFF);        dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom8name);        return;    }}const char* dg_compilen16tom16name = "dg_compilen16tom16";void dg_compilen16tom16 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n16    dg_Sibformatter* pregpsf) // assumed to be m16 with m16 already set up{    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        unsigned char c = 0x66;    UINT16 w;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        if ((popcodes->n32tom32.opcodestringlength == 0) ||        (popcodes->n32tom32.popcodestring == (const char*)dg_badbufferid))    {        dg_pusherror(pBHarrayhead, (const char*)"opcode for compiling immediate 16 bit to memory is not set");        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        // 16 bit opcode prefix    dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        dg_formatpsf(        pBHarrayhead,        pregpsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        dg_compilerexnotargetreg(        pBHarrayhead,        pregpsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n32tom32.popcodestring,        popcodes->n32tom32.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        pregpsf->immediatesize = 2; // for [O] mode    pregpsf->targetreg = popcodes->n32tom32.opcodeextension;        dg_compilepsf (        pBHarrayhead,        pregpsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }        w = (UINT16)(pimmediatepsf->immediatevalue & 0xFFFF);        dg_compilesegment (        pBHarrayhead,        (const char*)&w,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tom16name);        return;    }}// also does n32 to m64const char* dg_compilen32tom32name = "dg_compilen32tom32";void dg_compilen32tom32 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n8    dg_Sibformatter* pmempsf) // assumed to be m8 with m8 already set up{    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        const char* pError;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        if ((popcodes->n32tom32.opcodestringlength == 0) ||        (popcodes->n32tom32.popcodestring == (const char*)dg_badbufferid))    {        dg_pusherror(pBHarrayhead, (const char*)"opcode for compiling immediate 32 bit to memory is not set");        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        dg_formatpsf(        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }    dg_compilerexnotargetreg(        pBHarrayhead,        pmempsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n32tom32.popcodestring,        popcodes->n32tom32.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        pmempsf->immediatesize = sizeof(UINT32);    pmempsf->targetreg = popcodes->n32tom32.opcodeextension;        dg_compilepsf (        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        pError = dg_checkifvaluefits(        pmempsf->immediatesize,  //        pmempsf->size,   // sign extended to this size        pimmediatepsf->immediatevalue);        if (pError != dg_success)    {        // dg_printzerostring(pBHarrayhead, (unsigned char*)"used value size = ");        // dg_writestdoutuint64tohex(pBHarrayhead, pmempsf->size);        // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_pusherror(pBHarrayhead, pError);        dg_pusherror(pBHarrayhead, dg_checkifvaluefitsname);        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        // made this 0x180000000 so that unsigned values from 0 to 0xffffffff will work    // hmm if size is 32bits then -80000000 to 180000000    // if size is 64bits -80000000 to 7fffffff....    /*    if (pmempsf->size == sizeof(UINT32))    {        if ((UINT64)(pimmediatepsf->immediatevalue + 0x80000000) >= 0x180000000)        {            dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);            dg_pusherror(pBHarrayhead, dg_compilen32tom32name);            return;        }    }        if (pmempsf->size == sizeof(UINT64))    {        if ((UINT64)(pimmediatepsf->immediatevalue + 0x80000000) >= 0x100000000)        {            dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);            dg_pusherror(pBHarrayhead, dg_compilen32tom32name);            return;        }    }    */        dg_compilesegment (        pBHarrayhead,        (const char*)&(pimmediatepsf->immediatevalue),        sizeof(INT32));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }}// also compiles n8 to m64const char* dg_compilen8tom32name = "dg_compilen8tom32";void dg_compilen8tom32 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n8    dg_Sibformatter* pmempsf) // assumed to be m8 with m8 already set up{    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom32name);        return;    }        if ((popcodes->n8tom32signextended.opcodestringlength == 0) ||        (popcodes->n8tom32signextended.popcodestring == (const char*)dg_badbufferid) ||        (pimmediatepsf->immediatesize > dg_sizebyte) || // user is forcing size to be dword        ((INT64)pimmediatepsf->immediatevalue >= 0x80) || // I'm pretty sure there is a way to do this compare in one step        ((INT64)pimmediatepsf->immediatevalue < -0x80 ) )   // top 25 bits have to be the same            {        dg_compilen32tom32 (            pBHarrayhead,            popcodes,            pimmediatepsf,            pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen8tom32name);            return;        }                return;    }        dg_formatpsf(        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom32name);        return;    }    dg_compilerexnotargetreg(        pBHarrayhead,        pmempsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom32name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n8tom32signextended.popcodestring,        popcodes->n8tom32signextended.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom32name);        return;    }        pmempsf->immediatesize = 1;    pmempsf->targetreg = popcodes->n8tom32signextended.opcodeextension;        dg_compilepsf (        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom32name);        return;    }        c = (unsigned char)(pimmediatepsf->immediatevalue & 0xff);        dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom32name);        return;    }}const char* dg_compilen8tom16name = "dg_compilen8tom16";void dg_compilen8tom16 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n8    dg_Sibformatter* pmempsf) // assumed to be m8 with m8 already set up{    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        unsigned char c = 0x66;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }        if ((popcodes->n8tom32signextended.opcodestringlength == 0) ||        (popcodes->n8tom32signextended.popcodestring == (const char*)dg_badbufferid) ||        (pimmediatepsf->immediatesize > dg_sizebyte) || // user is forcing size to be 16 bits        ((INT64)pimmediatepsf->immediatevalue >= 0x80) || // I'm pretty sure there is a way to do this compare in one step        ((INT64)pimmediatepsf->immediatevalue < -0x80 ) )   // top 25 bits have to be the same            {        dg_compilen16tom16 (            pBHarrayhead,            popcodes,            pimmediatepsf,            pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen8tom16name);            return;        }                return;    }        // compile 16 bit instruction prefix    dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }        dg_formatpsf(        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }        dg_compilerexnotargetreg(        pBHarrayhead,        pmempsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n8tom32signextended.popcodestring,        popcodes->n8tom32signextended.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }        pmempsf->immediatesize = 1;    pmempsf->targetreg = popcodes->n8tom32signextended.opcodeextension;        dg_compilepsf (        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }        c = (unsigned char)(pimmediatepsf->immediatevalue & 0xff);        dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tom16name);        return;    }}const char* dg_compilentom16name = "dg_compilentom16";void dg_compilentom16 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,     dg_Sibformatter* pmempsf) {    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ( (pimmediatepsf->immediatesize < 2) &&         ((INT64)pimmediatepsf->immediatevalue >= -0x80) &&         ((INT64)pimmediatepsf->immediatevalue < 0x80 ) )    {        dg_compilen8tom16 (            pBHarrayhead,            popcodes,            pimmediatepsf,            pmempsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilentom16name);            return;        }    }    else    {        dg_compilen16tom16 (             pBHarrayhead,             popcodes,             pimmediatepsf,             pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilentom16name);            return;        }    }}const char* dg_compilentom32name = "dg_compilentom32";void dg_compilentom32 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,     dg_Sibformatter* pmempsf) {    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ( (pimmediatepsf->immediatesize < 2) &&        ((INT64)pimmediatepsf->immediatevalue >= -0x80) &&        ((INT64)pimmediatepsf->immediatevalue < 0x80 ) )    {        dg_compilen8tom32 (             pBHarrayhead,             popcodes,             pimmediatepsf,             pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilentom32name);            return;        }    }    else    {        dg_compilen32tom32 (             pBHarrayhead,             popcodes,             pimmediatepsf,             pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilentom32name);            return;        }    }}const char* dg_compilentomname = "dg_compilentom";void dg_compilentom (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,     dg_Sibformatter* pmempsf) {    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        switch (pmempsf->size)    {        case 1:            dg_compilen8tom8 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pmempsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentomname);                return;            }                        break;                    case 2:            dg_compilentom16 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pmempsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentomname);                return;            }                        break;                case 8:        case 4:            dg_compilentom32 (                pBHarrayhead,                popcodes,                pimmediatepsf,                 pmempsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentomname);                return;            }                        break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"Unknown target size. Must be one of 8BIT 16BIT or 32BIT (1, 2, or 4).");            dg_pusherror(pBHarrayhead, dg_compilentomname);            break;    }    }const char* dg_compileopcodeplusropstrname = "dg_compileopcodeplusropstr";void dg_compileopcodeplusropstr (    Bufferhandle* pBHarrayhead,    const char* popcodestring,    UINT64 opcodestringlength,    UINT64 reg){    UINT64 addresssize;        unsigned char lastopcodebyte;    unsigned char c;     UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileopcodeplusropstrname);        return;    }        if (opcodestringlength == 0)    {        // could push error...        return;    }        // doing rex    if (8 == addresssize)    {        c = 0;                // if it's an opcode that is default 64bit like push or pop, don't do this        if (0x50 != (popcodestring[0] & 0xf0)) // if it's not push or pop then use size        {                                       // I think push and pop may be the only ones though....            if (8 == dg_getsizefromreg(reg))     // this check probalby not necessary...            {                c = 0x48;            }        }                // dg_printzerostring(pBHarrayhead, (unsigned char*)"dg_compileopcodeplusropstr reg is ");        // dg_writestdoutuinttodec(pBHarrayhead, reg);        // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                if (dg_isrexsrcordestreg(reg) != FORTH_FALSE)        {            c = c | 0x41; // I think... it's either this or 0x44        }                if (0 != c)        {            dg_compilesegment (                pBHarrayhead,                (const char*)&c,                1);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileopcodeplusropstrname);                return;            }        }    }    else    {        if (dg_isrexsrcordestreg(reg) != FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)" - can't use 64 bit addressing mode registers in 32 bit addressing mode");            dg_pusherror(pBHarrayhead, dg_compileopcodeplusropstrname);            return;        }    }        lastopcodebyte = popcodestring[opcodestringlength-1];    lastopcodebyte = lastopcodebyte | (reg & 0x7);        if (opcodestringlength > 1)    {        dg_compilesegment (            pBHarrayhead,             (const char*)popcodestring,             opcodestringlength - 1);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compileopcodeplusropstrname);            return;        }    }                    dg_compilesegment (        pBHarrayhead,         (const char*)&lastopcodebyte,         1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileopcodeplusropstrname);        return;    }}const char* dg_compilemem8name = "dg_compilemem8";void dg_compilemem8 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem8name);        return;    }        if (0 == popcodes->m8.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"addressing mode not supported");        dg_pusherror(pBHarrayhead, dg_compilemem8name);        return;                }        dg_formatpsf(        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem8name);        return;    }        dg_compilerexnotargetreg(        pBHarrayhead,        ptargetsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem8name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->m8.popcodestring,        popcodes->m8.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem8name);        return;    }        ptargetsf->targetreg = popcodes->m8.opcodeextension;        dg_compilepsf (        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem8name);        return;    }}const char* dg_compilereg8name = "dg_compilereg8";void dg_compilereg8 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->r8.opcodestringlength)    {        dg_compilemem8(            pBHarrayhead,            popcodes,            ptargetsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilereg8name);            return;        }                    return;    }        dg_compileopcodeplusropstr (        pBHarrayhead,        (const char*)popcodes->r8.popcodestring,        popcodes->r8.opcodestringlength,        ptargetsf->basereg);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilereg8name);        return;    }}const char* dg_compilerega8name = "dg_compilerega8";void dg_compilerega8 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ( (0 == popcodes->a8.opcodestringlength) ||         (ptargetsf->basereg != dg_al) )    {        dg_compilereg8(            pBHarrayhead,            popcodes,            ptargetsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilerega8name);            return;        }                    return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->a8.popcodestring,        popcodes->a8.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerega8name);        return;    }}const char* dg_compilen8name = "dg_compilen8";void dg_compilen8 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->n8.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"immediate and/or 8 bit operations not supported");        dg_pusherror(pBHarrayhead, dg_compilen8name);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->n8.popcodestring,        popcodes->n8.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8name);        return;    }        // just trimming value to byte regardless of size    dg_compilesegment (          pBHarrayhead,           (const char*)&(ptargetsf->immediatevalue),          1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8name);        return;    }}const char* dg_compilen16name = "dg_compilen16";void dg_compilen16 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    const char c = 0x66;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->n32.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"immediate and/or 16 bit operations not supported");        dg_pusherror(pBHarrayhead, dg_compilen16name);        return;    }        dg_compilesegment (        pBHarrayhead,         &c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16name);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->n32.popcodestring,        popcodes->n32.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16name);        return;    }        // just trimming value to 16 bits regardless of size    dg_compilesegment (          pBHarrayhead,           (const char*)&(ptargetsf->immediatevalue),          sizeof(UINT16));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16name);        return;    }}const char* dg_compilen16signextendedname = "dg_compilen16signextended";void dg_compilen16signextended (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    const char c = 0x66;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->n32signextended.opcodestringlength)    {        dg_compilen16 (            pBHarrayhead,            popcodes,            ptargetsf);                return;    }        dg_compilesegment (        pBHarrayhead,         &c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16signextendedname);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->n32signextended.popcodestring,        popcodes->n32signextended.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16signextendedname);        return;    }        // just trimming value to 16 bits regardless of size    dg_compilesegment (          pBHarrayhead,          (const char*)&(ptargetsf->immediatevalue),          1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16signextendedname);        return;    }}const char* dg_compilen32name = "dg_compilen32";void dg_compilen32 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->n32.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"immediate and/or 32 bit operations not supported");        dg_pusherror(pBHarrayhead, dg_compilen32name);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->n32.popcodestring,        popcodes->n32.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32name);        return;    }        // just trimming value to 32 bits regardless of size    dg_compilesegment (          pBHarrayhead,           (const char*)&(ptargetsf->immediatevalue),          sizeof(UINT32));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32name);        return;    }}const char* dg_compilen32signextendedname = "dg_compilen32signextended";void dg_compilen32signextended (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->n32signextended.opcodestringlength)    {        dg_compilen32signextended (            pBHarrayhead,            popcodes,            ptargetsf);                    return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->n32signextended.popcodestring,        popcodes->n32signextended.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32signextendedname);        return;    }        // just trimming value to 8 bits regardless of size    dg_compilesegment (          pBHarrayhead,          (const char*)&(ptargetsf->immediatevalue),          1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32signextendedname);        return;    }}const char* dg_compilemem16name = "dg_compilemem16";void dg_compilemem16 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 beforeinstructionccboffset;    UINT64 ccbufferid;        UINT64 addresssize;        const char c = 0x66;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;    }        if (0 == popcodes->m32.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"addressing mode not supported");        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;                }        dg_compilesegment (        pBHarrayhead,         &c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;    }        dg_formatpsf(        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;    }        dg_compilerexnotargetreg(        pBHarrayhead,        ptargetsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->m32.popcodestring,        popcodes->m32.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;    }        ptargetsf->targetreg = popcodes->m32.opcodeextension;        dg_compilepsf (        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem16name);        return;    }}const char* dg_compilereg16name = "dg_compilereg16";void dg_compilereg16 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    const char c = 0x66;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if (0 == popcodes->r32.opcodestringlength)    {        dg_compilemem16(            pBHarrayhead,            popcodes,            ptargetsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilereg16name);            return;        }                    return;    }        dg_compilesegment (        pBHarrayhead,         &c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilereg16name);        return;    }        dg_compileopcodeplusropstr (        pBHarrayhead,        (const char*)popcodes->r32.popcodestring,        popcodes->r32.opcodestringlength,        ptargetsf->basereg);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilereg16name);        return;    }}const char* dg_compilerega16name = "dg_compilerega16";void dg_compilerega16 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    const char c = 0x66;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ( (0 == popcodes->a32.opcodestringlength) ||         (dg_queryisrega(ptargetsf->basereg) == FORTH_FALSE) )    {        dg_compilereg16(            pBHarrayhead,            popcodes,            ptargetsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilerega16name);            return;        }                    return;    }        dg_compilesegment (        pBHarrayhead,         &c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerega16name);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->a32.popcodestring,        popcodes->a32.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerega16name);        return;    }}// does mem 64 tooconst char* dg_compilemem32name = "dg_compilemem32";void dg_compilemem32 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilemem32\n");        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32name);        return;    }        if (0 == popcodes->m32.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"addressing mode not supported");        dg_pusherror(pBHarrayhead, dg_compilemem32name);        return;                }        dg_formatpsf(        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32name);        return;    }        if (FORTH_FALSE != dg_isdefaultaddresssizeonetarget (popcodes))    {        dg_compilerexnosizetargetreg(            pBHarrayhead,            ptargetsf,            addresssize);    }    else    {        dg_compilerexnotargetreg(            pBHarrayhead,            ptargetsf,            addresssize);    }        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->m32.popcodestring,        popcodes->m32.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32name);        return;    }        ptargetsf->targetreg = popcodes->m32.opcodeextension;        dg_compilepsf (        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32name);        return;    }}const char* dg_compilemem32fpname = "dg_compilemem32fp";void dg_compilemem32fp (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32fpname);        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilemem32\n");        if (0 == popcodes->m32fp.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"addressing mode not supported");        dg_pusherror(pBHarrayhead, dg_compilemem32fpname);        return;                }        dg_formatpsf(        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32fpname);        return;    }        dg_compilerexnosizetargetreg(        pBHarrayhead,        ptargetsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32fpname);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->m32fp.popcodestring,        popcodes->m32fp.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32fpname);        return;    }        ptargetsf->targetreg = popcodes->m32fp.opcodeextension;        dg_compilepsf (        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem32fpname);        return;    }}const char* dg_compilemem64fpname = "dg_compilemem64fp";void dg_compilemem64fp (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem64fpname);        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilemem32\n");        if (0 == popcodes->m64fp.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"addressing mode not supported");        dg_pusherror(pBHarrayhead, dg_compilemem64fpname);        return;                }        dg_formatpsf(        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem64fpname);        return;    }        dg_compilerexnosizetargetreg(        pBHarrayhead,        ptargetsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem64fpname);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->m64fp.popcodestring,        popcodes->m64fp.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem64fpname);        return;    }        ptargetsf->targetreg = popcodes->m64fp.opcodeextension;        dg_compilepsf (        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem64fpname);        return;    }}const char* dg_compilemem80fpname = "dg_compilemem80fp";void dg_compilemem80fp (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem80fpname);        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilemem32\n");        if (0 == popcodes->m80fp.opcodestringlength)    {        dg_pusherror(pBHarrayhead, (const char*)"addressing mode not supported");        dg_pusherror(pBHarrayhead, dg_compilemem80fpname);        return;                }        dg_formatpsf(        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem80fpname);        return;    }        dg_compilerexnosizetargetreg(        pBHarrayhead,        ptargetsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem80fpname);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->m80fp.popcodestring,        popcodes->m80fp.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem80fpname);        return;    }        ptargetsf->targetreg = popcodes->m80fp.opcodeextension;        dg_compilepsf (        pBHarrayhead,        ptargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilemem80fpname);        return;    }}const char* dg_compilereg32name = "dg_compilereg32";void dg_compilereg32 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilereg32\n");         if (0 == popcodes->r32.opcodestringlength)    {        dg_compilemem32(            pBHarrayhead,            popcodes,            ptargetsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilereg32name);            return;        }                    return;    }        dg_compileopcodeplusropstr (        pBHarrayhead,        (const char*)popcodes->r32.popcodestring,        popcodes->r32.opcodestringlength,        ptargetsf->basereg);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilereg32name);        return;    }}const char* dg_compilerega32name = "dg_compilerega32";void dg_compilerega32 (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        unsigned char c;        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilerega32\n");         addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerega32name);        return;    }        if ( (0 == popcodes->a32.opcodestringlength) ||         (dg_queryisrega(ptargetsf->basereg) == FORTH_FALSE) )    {        dg_compilereg32(            pBHarrayhead,            popcodes,            ptargetsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilerega32name);            return;        }                    return;    }        if (8 == addresssize)    {        // there's no rega only push or pop instruction...        c = 0x48;                dg_compilesegment (            pBHarrayhead,            (const char*)&c,            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilerega32name);            return;        }    }        dg_compilesegment (        pBHarrayhead,         (const char*)popcodes->a32.popcodestring,        popcodes->a32.opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerega32name);        return;    }}const char* dg_compilentargetname = "dg_compilentarget";void dg_compilentarget (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 size;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        size = ptargetsf->size;        switch (size)    {        case 1:            dg_compilen8(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentargetname);                return;            }                        break;                    case 2:            if ( (ptargetsf->immediatesize < 2) &&                ((INT64)ptargetsf->immediatevalue >= -0x80) &&                ((INT64)ptargetsf->immediatevalue < 0x80 ) )            {                dg_compilen16signextended(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilentargetname);                    return;                }            }            else            {                dg_compilen16(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilentargetname);                    return;                }            }                        break;                case 8:        case 4:            if ( (ptargetsf->immediatesize < 2) &&                ((INT64)ptargetsf->immediatevalue >= -0x80) &&                ((INT64)ptargetsf->immediatevalue < 0x80 ) )            {                dg_compilen32signextended(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilentargetname);                    return;                }            }            else            {                dg_compilen32(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilentargetname);                    return;                }            }            break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"size not supported");            dg_pusherror(pBHarrayhead, dg_compilentargetname);            break;    }}const char* dg_compileregatargetname = "dg_compileregatarget";void dg_compileregatarget (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 size;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        size = ptargetsf->size;        switch (size)    {        case 1:            dg_compilerega8(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileregatargetname);                return;            }                        break;                    case 2:            dg_compilerega16(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileregatargetname);                return;            }                        break;                case 8:        case 4:            dg_compilerega32(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileregatargetname);                return;            }                        break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"size not supported");            dg_pusherror(pBHarrayhead, dg_compileregatargetname);            break;    }}const char* dg_compileregtargetname = "dg_compileregtarget";void dg_compileregtarget (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 size;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        size = ptargetsf->size;        switch (size)    {        case 1:            dg_compilereg8(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileregtargetname);                return;            }                        break;                    case 2:            dg_compilereg16(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileregtargetname);                return;            }                        break;                case 8:        case 4:            dg_compilereg32(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileregtargetname);                return;            }                        break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"size not supported");            dg_pusherror(pBHarrayhead, dg_compileregtargetname);            break;    }}const char* dg_compilememtargetname = "dg_compilememtarget";void dg_compilememtarget (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 size;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // if floating point...    if (popcodes->m32fp.opcodestringlength != 0)    {        switch(ptargetsf->size)        {            case 4:                dg_compilemem32fp(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilememtargetname);                    return;                }                break;                            case 8:                dg_compilemem64fp(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilememtargetname);                    return;                }                break;                            case 10:                dg_compilemem80fp(                    pBHarrayhead,                    popcodes,                    ptargetsf);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compilememtargetname);                    return;                }                break;                            default:                dg_pusherror(pBHarrayhead, (const char*)"Unknown floating point target size. Must be one of 32BIT 64BIT or 80BIT (4, 8, or 10).");                dg_pusherror(pBHarrayhead, dg_compilememtargetname);                break;        }                return;    }        size = ptargetsf->size;        switch (size)    {        case 1:            dg_compilemem8(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilememtargetname);                return;            }                        break;                    case 2:            dg_compilemem16(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilememtargetname);                return;            }                        break;                case 16:        case 8:        case 4:            dg_compilemem32(                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilememtargetname);                return;            }                        break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"Unknown target size. Must be one of 8BIT 16BIT 32BIT or 64BIT (1, 2, 4, or 8).");            dg_pusherror(pBHarrayhead, dg_compilememtargetname);            break;    }}const char* dg_compileonetargetname = "dg_compileonetarget";void dg_compileonetarget (    Bufferhandle* pBHarrayhead,    struct Onetargetopcodestrings* popcodes,    dg_Sibformatter* ptargetsf){    UINT64 targettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        targettype = dg_gettargettype(        pBHarrayhead,        ptargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileonetargetname);        return;    }        switch (targettype)    {        case dg_targettypeimmediate:                        dg_compilentarget (                pBHarrayhead,                popcodes,                ptargetsf);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileonetargetname);                return;            }                            break;                    case dg_targettyperega:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"a\n");            dg_compileregatarget (                pBHarrayhead,                popcodes,                ptargetsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileonetargetname);                return;            }                        break;                    case dg_targettypereg:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"r\n");            dg_compileregtarget (                pBHarrayhead,                popcodes,                ptargetsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileonetargetname);                return;            }                        break;                    /*        case dg_targettypefpsreg:                    dg_compilefpsregtarget (                pBHarrayhead,                popcodes,                ptargetsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileonetargetname);                return;            }            break;        */                case dg_targettypefpsreg:        case dg_targettypexmmreg:        case dg_targettypemem:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"m\n");            dg_compilememtarget (                pBHarrayhead,                popcodes,                ptargetsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compileonetargetname);                return;            }                        break;                                        default:            dg_pusherror(pBHarrayhead, (const char*)"unknown target type");            dg_pusherror(pBHarrayhead, dg_compileonetargetname);            break;    }}void dg_fillonetargetemptyoptable (    Bufferhandle* pBHarrayhead,    Onetargetopcodestrings* popcodes){    popcodes->n8.opcodestringlength = 0;    popcodes->n8.opcodeextension = (UINT64)-1;    popcodes->a8.opcodestringlength = 0;    popcodes->a8.opcodeextension = (UINT64)-1;        popcodes->r8.opcodestringlength = 0;    popcodes->r8.opcodeextension = (UINT64)-1;        popcodes->m8.opcodestringlength = 0;    popcodes->m8.opcodeextension = (UINT64)-1;        popcodes->n32signextended.opcodestringlength = 0;    popcodes->n32signextended.opcodeextension = (UINT64)-1;        popcodes->n32.opcodestringlength = 0;    popcodes->n32.opcodeextension = (UINT64)-1;        popcodes->a32.opcodestringlength = 0;    popcodes->a32.opcodeextension = (UINT64)-1;        popcodes->r32.opcodestringlength = 0;    popcodes->r32.opcodeextension = (UINT64)-1;        popcodes->m32.opcodestringlength = 0;    popcodes->m32.opcodeextension = (UINT64)-1;        popcodes->m32fp.opcodestringlength = 0;        popcodes->m64fp.opcodestringlength = 0;        popcodes->m80fp.opcodestringlength = 0;}const char* dg_fillonetargetn8onlyoptablename = "dg_fillonetargetn8onlyoptable";void dg_fillonetargetn8onlyoptable (    Bufferhandle* pBHarrayhead,    Onetargetopcodestrings* popcodes,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    const char* perror;        dg_fillonetargetemptyoptable (        pBHarrayhead,        popcodes);        popcodes->n8.opcodestringlength = opcodestringlength;        popcodes->n8.opcodeextension = (UINT32)-1;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(popcodes->n8.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, perror);        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillonetargetn8onlyoptablename);        return;    }}const char* dg_fillonetargetn32onlyoptablename = "dg_fillonetargetn32onlyoptable";void dg_fillonetargetn32onlyoptable (    Bufferhandle* pBHarrayhead,    Onetargetopcodestrings* popcodes,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    const char* perror;        dg_fillonetargetemptyoptable (        pBHarrayhead,        popcodes);        popcodes->n32.opcodestringlength = opcodestringlength;        popcodes->n32.opcodeextension = (UINT32)-1;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(popcodes->n8.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, perror);        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillonetargetn32onlyoptablename);        return;    }}void dg_fillonetargetmemonlyoptable (    Bufferhandle* pBHarrayhead,    Onetargetopcodestrings* popcodes,    UINT64 baseopcode,    UINT64 opcodeextension){    dg_fillonetargetemptyoptable (        pBHarrayhead,        popcodes);        popcodes->m8.popcodestring[0] = (char)(baseopcode & 0xff);    popcodes->m8.opcodestringlength = 1;    popcodes->m8.opcodeextension = opcodeextension;        popcodes->m32.popcodestring[0] = (char)((baseopcode & 0xff) | 1);    popcodes->m32.opcodestringlength = 1;    popcodes->m32.opcodeextension = opcodeextension;}const char* dg_fillonetargetmemonlyoptablebname = "dg_fillonetargetmemonlyoptableb";void dg_fillonetargetmemonlyoptableb (    Bufferhandle* pBHarrayhead,    Onetargetopcodestrings* popcodes,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    const char* perror;        dg_fillonetargetemptyoptable (        pBHarrayhead,        popcodes);        popcodes->m32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(popcodes->m32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, perror);        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillonetargetmemonlyoptablebname);        return;    }        popcodes->m32.opcodestringlength = opcodestringlength;        popcodes->m32.opcodeextension = opcodeextension;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(popcodes->m32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, perror);        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillonetargetmemonlyoptablebname);        return;    }}const char* dg_fillonetargetmem8onlyoptablename = "dg_fillonetargetmem8onlyoptable";void dg_fillonetargetmem8onlyoptable (    Bufferhandle* pBHarrayhead,    Onetargetopcodestrings* popcodes,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    const char* perror;        dg_fillonetargetemptyoptable (        pBHarrayhead,        popcodes);        popcodes->m8.opcodestringlength = opcodestringlength;    popcodes->m8.opcodeextension = opcodeextension;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(popcodes->m8.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, perror);        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillonetargetmem8onlyoptablename);        return;    }}const char* dg_doonetargetn8onlyinstructionname = "dg_doonetargetn8onlyinstruction";void dg_doonetargetn8onlyinstruction (    Bufferhandle* pBHarrayhead,    const char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = dg_popdatastack(pBHarrayhead);        dg_compilesegment(        pBHarrayhead,        popcodestring,        opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn8onlyinstructionname);        return;    }        if (n > 0xFF)    {        dg_pusherror(pBHarrayhead, (const char*)"the value of n is too big to fit into an unsigned byte");        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&n,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn8onlyinstructionname);        return;    }}const char* dg_forthinn8toalcommaname = "IN[N8]->AL,";void dg_forthinn8toalcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn8onlyinstruction (        pBHarrayhead,        (const char*)"\xE4", // popcodestring,        1, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinn8toalcommaname);        return;    }}const char* dg_forthinn8toeaxcommaname = "IN[N8]->EAX,";void dg_forthinn8toeaxcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn8onlyinstruction (        pBHarrayhead,        (const char*)"\xE5", // popcodestring,        1, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinn8toeaxcommaname);        return;    }}const char* dg_forthinn8toaxcommaname = "IN[N8]->AX,";void dg_forthinn8toaxcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn8onlyinstruction (        pBHarrayhead,        (const char*)"\x66\xE5", // popcodestring,  // this is probably right        2, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinn8toaxcommaname);        return;    }}const char* dg_forthaltooutn8commaname = "AL->OUT[N8],";void dg_forthaltooutn8comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn8onlyinstruction (        pBHarrayhead,        (const char*)"\xE6", // popcodestring,        1, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaltooutn8commaname);        return;    }}const char* dg_fortheaxtooutn8commaname = "EAX->OUT[N8],";void dg_fortheaxtooutn8comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn8onlyinstruction (        pBHarrayhead,        (const char*)"\xE7", // popcodestring,        1, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_fortheaxtooutn8commaname);        return;    }}const char* dg_forthaxtooutn8commaname = "AX->OUT[N8],";void dg_forthaxtooutn8comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn8onlyinstruction (        pBHarrayhead,        (const char*)"\x66\xE7", // popcodestring,  // this is probably right        2, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaxtooutn8commaname);        return;    }}const char* dg_doonetargetn16onlyinstructionname = "dg_doonetargetn16onlyinstruction";void dg_doonetargetn16onlyinstruction (    Bufferhandle* pBHarrayhead,    const char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    INT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = (INT64)dg_popdatastack(pBHarrayhead);        if ((n + 8000) >= 0x10000)    {        // error message assumes this is for XBEGIN which uses a signed displacement        dg_pusherror(pBHarrayhead, (const char*)"displacement is bigger than a signed 16 bit value");        return;    }        dg_compilesegment(        pBHarrayhead,        popcodestring,        opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn16onlyinstructionname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&n,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn16onlyinstructionname);        return;    }}const char* dg_forthxbeginn16commaname = "XBEGINN16,";void dg_forthxbeginn16comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn16onlyinstruction (        pBHarrayhead,        (const char*)"\x66\xC7\xF8", // popcodestring,  // this is probably right        3, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxbeginn16commaname);        return;    }}const char* dg_doonetargetn32onlyinstructionname = "dg_doonetargetn32onlyinstruction";void dg_doonetargetn32onlyinstruction (    Bufferhandle* pBHarrayhead,    const char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = dg_popdatastack(pBHarrayhead);        if ((n + 0x80000000) >= 0x100000000)    {        // error message assumes this is for XBEGIN which uses a signed displacement        dg_pusherror(pBHarrayhead, (const char*)"displacement is bigger than a signed 32 bit value");        dg_pusherror(pBHarrayhead, dg_doonetargetn32onlyinstructionname);        return;    }        dg_compilesegment(        pBHarrayhead,        popcodestring,        opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn32onlyinstructionname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&n,        4);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn32onlyinstructionname);        return;    }}const char* dg_forthxbeginn32commaname = "XBEGINN32,";void dg_forthxbeginn32comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetn32onlyinstruction (        pBHarrayhead,        (const char*)"\xC7\xF8", // popcodestring,        2, // opcodestringlength,        (UINT32)-1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxbeginn32commaname);        return;    }}const char* dg_doonetargetu32onlyinstructionname = "dg_doonetargetu32onlyinstruction";void dg_doonetargetu32onlyinstruction (    Bufferhandle* pBHarrayhead,    const char* popcodestring,    UINT64 opcodestringlength){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = dg_popdatastack(pBHarrayhead);        if (n >= 0x100000000)    {        // error message assumes this is for XBEGIN which uses a signed displacement        dg_pusherror(pBHarrayhead, (const char*)"displacement is bigger than an unsigned 32 bit value");        dg_pusherror(pBHarrayhead, dg_doonetargetu32onlyinstructionname);        return;    }        dg_compilesegment(        pBHarrayhead,        popcodestring,        opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetu32onlyinstructionname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&n,        4);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetu32onlyinstructionname);        return;    }}const char* dg_doonetargetn64onlyinstructionname = "dg_doonetargetn64onlyinstruction";void dg_doonetargetn64onlyinstruction (    Bufferhandle* pBHarrayhead,    const char* popcodestring,    UINT64 opcodestringlength){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = dg_popdatastack(pBHarrayhead);        dg_compilesegment(        pBHarrayhead,        popcodestring,        opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn64onlyinstructionname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&n,        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetn64onlyinstructionname);        return;    }}const char* dg_forthmovbracketntoalcommaname = "MOV[N]->AL,";void dg_forthmovbracketntoalcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoalcommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoalcommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\xA0", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoalcommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\xA0", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoalcommaname);            return;        }    }}const char* dg_forthmovbracketntoaxcommaname = "MOV[N]->AX,";void dg_forthmovbracketntoaxcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoaxcommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoaxcommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\x66\xA1", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoaxcommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\x66\xA1", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoaxcommaname);            return;        }    }}const char* dg_forthmovbracketntoeaxcommaname = "MOV[N]->EAX,";void dg_forthmovbracketntoeaxcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoeaxcommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoeaxcommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\xA1", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoeaxcommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\xA1", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoeaxcommaname);            return;        }    }}const char* dg_forthmovbracketntoraxcommaname = "MOV[N]->RAX,";void dg_forthmovbracketntoraxcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoraxcommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovbracketntoraxcommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\x48\xA1", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoraxcommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\x48\xA1", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovbracketntoraxcommaname);            return;        }    }}const char* dg_forthmovaltobracketncommaname = "MOVAL->[N],";void dg_forthmovaltobracketncomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovaltobracketncommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovaltobracketncommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\xA2", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovaltobracketncommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\xA2", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovaltobracketncommaname);            return;        }    }}const char* dg_forthmovaxtobracketncommaname = "MOVAX->[N],";void dg_forthmovaxtobracketncomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovaxtobracketncommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovaxtobracketncommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\x66\xA3", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovaxtobracketncommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\x66\xA3", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovaxtobracketncommaname);            return;        }    }}const char* dg_forthmoveaxtobracketncommaname = "MOVEAX->[N],";void dg_forthmoveaxtobracketncomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmoveaxtobracketncommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmoveaxtobracketncommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\xA3", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmoveaxtobracketncommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\xA3", // popcodestring,            1); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmoveaxtobracketncommaname);            return;        }    }}const char* dg_forthmovraxtobracketncommaname = "MOVRAX->[N],";void dg_forthmovraxtobracketncomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovraxtobracketncommaname);           }        if ((addresssize != 8) &&        (addresssize != 4))    {        dg_pusherror(pBHarrayhead, (const char*)"this compiler only supports 32 and 64 bit address sizes");        dg_pusherror(pBHarrayhead, dg_forthmovraxtobracketncommaname);        return;    }        if (addresssize == 4)    {        dg_doonetargetu32onlyinstruction (            pBHarrayhead,            (const char*)"\x48\xA3", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovraxtobracketncommaname);            return;        }    }        if (addresssize == 8)    {        dg_doonetargetn64onlyinstruction (            pBHarrayhead,            (const char*)"\x48\xA3", // popcodestring,            2); // opcodestringlength,                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovraxtobracketncommaname);            return;        }    }}const char* dg_doonetargetm8onlyinstructionname = "dg_doonetargetm8onlyinstruction";void dg_doonetargetm8onlyinstruction (    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    UINT64 targettype;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // no error from this one    dg_fillonetargetmem8onlyoptable (        pBHarrayhead,        &myopcodes,        popcodestring,        opcodestringlength,        opcodeextension);        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetm8onlyinstructionname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetm8onlyinstructionname);        return;    }        if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported for this instruction");        return;    }        if ((mytargetsf.size != 0) &&        (mytargetsf.size != 1))    {        dg_pusherror(pBHarrayhead, (const char*)"if a data size for this instruction is specified, it must be 8 bits");        return;    }        mytargetsf.size = 1;        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetm8onlyinstructionname);        return;    }}const char* dg_forthprefetcht0commaname = "PREFETCHT0,";void dg_forthprefetcht0comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetm8onlyinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x18", // popcodestring,        2, // opcodestringlength,        1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthprefetcht0commaname);        return;    }}const char* dg_forthprefetcht1commaname = "PREFETCHT1,";void dg_forthprefetcht1comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetm8onlyinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x18", // popcodestring,        2, // opcodestringlength,        2); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthprefetcht1commaname);        return;    }}const char* dg_forthprefetcht2commaname = "PREFETCHT2,";void dg_forthprefetcht2comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetm8onlyinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x18", // popcodestring,        2, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthprefetcht2commaname);        return;    }}const char* dg_forthprefetchntacommaname = "PREFETCHNTA,";void dg_forthprefetchntacomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetm8onlyinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x18", // popcodestring,        2, // opcodestringlength,        0); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthprefetchntacommaname);        return;    }}const char* dg_forthprefetchwcommaname = "PREFETCHW,";void dg_forthprefetchwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetm8onlyinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x0D", // popcodestring,        2, // opcodestringlength,        1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthprefetchwcommaname);        return;    }}const char* dg_forthprefetchwt1commaname = "PREFETCHWT1,";void dg_forthprefetchwt1comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetm8onlyinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x0D", // popcodestring,        2, // opcodestringlength,        2); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthprefetchwt1commaname);        return;    }}const char* dg_doonetargetmorringoresizename = "dg_doonetargetmorringoresize";void dg_doonetargetmorringoresize (    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // no error from this one    dg_fillonetargetmemonlyoptableb (        pBHarrayhead,        &myopcodes,        (unsigned char*)"",  // pprefixstring        0,                   // prefixstringlength        popcodestring,        opcodestringlength,        opcodeextension);        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetmorringoresizename);        return;    }        // size is ignored    mytargetsf.size = 4;    dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetmorringoresizename);        return;    }}const char* dg_forthltrcommaname = "LTR,";void dg_forthltrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorringoresize (        pBHarrayhead,        (unsigned char*)"\x0F\x00", // popcodestring,        2, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthltrcommaname);        return;    }}const char* dg_forthverrcommaname = "VERR,";void dg_forthverrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorringoresize (        pBHarrayhead,        (unsigned char*)"\x0F\x00", // popcodestring,        2, // opcodestringlength,        4); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthverrcommaname);        return;    }}const char* dg_forthverwcommaname = "VERW,";void dg_forthverwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorringoresize (        pBHarrayhead,        (unsigned char*)"\x0F\x00", // popcodestring,        2, // opcodestringlength,        5); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthverwcommaname);        return;    }}const char* dg_doonetargetmorrinstructionname = "dg_doonetargetmorrinstruction";void dg_doonetargetmorrinstruction (    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // no error from this one    dg_fillonetargetmemonlyoptableb (        pBHarrayhead,        &myopcodes,        (unsigned char*)"",  // pprefixstring        0,                   // prefixstringlength        popcodestring,        opcodestringlength,        opcodeextension);        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetmorrinstructionname);        return;    }        // I want to allow rex but not the 0x66 16 bit prefix    // so size is ingored if it isn't 64 bits    if (mytargetsf.size != 8)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetmorrinstructionname);        return;    }}const char* dg_forthlldtcommaname = "LLDT,";void dg_forthlldtcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorrinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x00", // popcodestring,        2, // opcodestringlength,        2); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlldtcommaname);        return;    }}const char* dg_forthlmswcommaname = "LMSW,";void dg_forthlmswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorrinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        6); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlldtcommaname);        return;    }}const char* dg_forthsldtcommaname = "SLDT,";void dg_forthsldtcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorrinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x00", // popcodestring,        2, // opcodestringlength,        0); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsldtcommaname);        return;    }}// this one allows the 0x66 16 bit prefixconst char* dg_doonetargetmorrinstructionbname = "dg_doonetargetmorrinstructionb";void dg_doonetargetmorrinstructionb (    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // no error from this one    dg_fillonetargetmemonlyoptableb (        pBHarrayhead,        &myopcodes,        (unsigned char*)"",  // pprefixstring        0,                   // prefixstringlength        popcodestring,        opcodestringlength,        opcodeextension);        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetmorrinstructionbname);        return;    }        if (mytargetsf.size == 0)    {        mytargetsf.size = 4; // if the user picks default mem size, gonna give them the no prefix one    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetmorrinstructionbname);        return;    }}const char* dg_forthsmswcommaname = "SMSW,";void dg_forthsmswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorrinstructionb (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        4); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsmswcommaname);        return;    }}const char* dg_forthstrcommaname = "STR,";void dg_forthstrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetmorrinstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x00", // popcodestring,        2, // opcodestringlength,        1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthstrcommaname);        return;    }}const char* dg_doonetargetminstructionname = "dg_doonetargetminstruction";void dg_doonetargetminstruction (    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    UINT64 targettype;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // no error from this one    dg_fillonetargetmemonlyoptableb (        pBHarrayhead,        &myopcodes,        (unsigned char*)"", // pprefixstring        0, // prefixstringlength        popcodestring,        opcodestringlength,        opcodeextension);        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetminstructionname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetminstructionname);        return;    }        if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported for this instruction");        return;    }        // size is ignored for this instruction, but I think I'll change this to check    //  to see if the user specified a size and tell them that if they do that, it has to be the correct one    mytargetsf.size = 4;        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetminstructionname);        return;    }}const char* dg_forthinvlpgcommaname = "INVLPG,";void dg_forthinvlpgcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        7); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinvlpgcommaname);        return;    }}const char* dg_forthfxrstorcommaname = "FXRSTOR,";void dg_forthfxrstorcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfxrstorcommaname);        return;    }}const char* dg_forthfxsavecommaname = "FXSAVE,";void dg_forthfxsavecomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        0); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfxsavecommaname);        return;    }}const char* dg_forthldmxcsrcommaname = "LDMXCSR,";void dg_forthldmxcsrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        2); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthldmxcsrcommaname);        return;    }}const char* dg_forthlgdtcommaname = "LGDT,";void dg_forthlgdtcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        2); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlgdtcommaname);        return;    }}const char* dg_forthlidtcommaname = "LIDT,";void dg_forthlidtcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlidtcommaname);        return;    }}const char* dg_forthsgdtcommaname = "SGDT,";void dg_forthsgdtcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        0); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsgdtcommaname);        return;    }}const char* dg_forthsidtcommaname = "SIDT,";void dg_forthsidtcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\x01", // popcodestring,        2, // opcodestringlength,        1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsidtcommaname);        return;    }}const char* dg_forthstmxcsrcommaname = "STMXCSR,";void dg_forthstmxcsrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthstmxcsrcommaname);        return;    }}const char* dg_forthxrstorcommaname = "XRSTOR,";void dg_forthxrstorcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        5); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxrstorcommaname);        return;    }}const char* dg_forthxrstor64commaname = "XRSTOR64,";void dg_forthxrstor64comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x48\x0F\xAE", // popcodestring,        3, // opcodestringlength,        5); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxrstor64commaname);        return;    }}const char* dg_forthxrstorscommaname = "XRSTORS,";void dg_forthxrstorscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xC7", // popcodestring,        2, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxrstorscommaname);        return;    }}const char* dg_forthxrstors64commaname = "XRSTORS64,";void dg_forthxrstors64comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x48\x0F\xC7", // popcodestring,        3, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxrstors64commaname);        return;    }}const char* dg_forthxsavecommaname = "XSAVE,";void dg_forthxsavecomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        4); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsavecommaname);        return;    }}const char* dg_forthxsave64commaname = "XSAVE64,";void dg_forthxsave64comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x48\x0F\xAE", // popcodestring,        3, // opcodestringlength,        4); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsave64commaname);        return;    }}const char* dg_forthxsaveccommaname = "XSAVEC,";void dg_forthxsaveccomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xC7", // popcodestring,        2, // opcodestringlength,        4); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsaveccommaname);        return;    }}const char* dg_forthxsavec64commaname = "XSAVEC64,";void dg_forthxsavec64comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x48\x0F\xC7", // popcodestring,        3, // opcodestringlength,        4); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsavec64commaname);        return;    }}const char* dg_forthxsaveoptcommaname = "XSAVEOPT,";void dg_forthxsaveoptcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        6); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsaveoptcommaname);        return;    }}const char* dg_forthxsaveopt64commaname = "XSAVEOPT64,";void dg_forthxsaveopt64comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x48\x0F\xAE", // popcodestring,        3, // opcodestringlength,        6); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsaveopt64commaname);        return;    }}const char* dg_forthxsavescommaname = "XSAVES,";void dg_forthxsavescomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x0F\xC7", // popcodestring,        2, // opcodestringlength,        5); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsavescommaname);        return;    }}const char* dg_forthxsaves64commaname = "XSAVES64,";void dg_forthxsaves64comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetminstruction (        pBHarrayhead,        (unsigned char*)"\x48\x0F\xC7", // popcodestring,        3, // opcodestringlength,        5); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxsaves64commaname);        return;    }}const char* dg_doonetargetrinstructionname = "dg_doonetargetrinstruction";void dg_doonetargetrinstruction (    Bufferhandle* pBHarrayhead,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 opcodeextension){    UINT64 targettype;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;    UINT64 addresssize;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // only supported in 64 bit mode....    addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);           }        if (addresssize != 8)    {        dg_pusherror(pBHarrayhead, (const char*)"this instruction only supported in 64 bit mode");        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);        return;    }        // no error from this one    dg_fillonetargetmemonlyoptableb (        pBHarrayhead,        &myopcodes,        pprefixstring,        prefixstringlength,        popcodestring,        opcodestringlength,        opcodeextension);        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);        return;    }        if ((targettype != dg_targettypereg) &&        (targettype != dg_targettyperega))    {        dg_pusherror(pBHarrayhead, (const char*)"only register targets are supported for this instruction");        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);        return;    }        if((mytargetsf.size != 4) &&       (mytargetsf.size != 8))    {        dg_pusherror(pBHarrayhead, (const char*)"target register size must be 32 or 64 bits");        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doonetargetrinstructionname);        return;    }}const char* dg_forthrdfsbasecommaname = "RDFSBASE,";void dg_forthrdfsbasecomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetrinstruction (        pBHarrayhead,        (unsigned char*)"\xF3",        1,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        0); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdfsbasecommaname);        return;    }}const char* dg_forthrdgsbasecommaname = "RDGSBASE,";void dg_forthrdgsbasecomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetrinstruction (        pBHarrayhead,        (unsigned char*)"\xF3",        1,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        1); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdgsbasecommaname);        return;    }}const char* dg_forthwrfsbasecommaname = "WRFSBASE,";void dg_forthwrfsbasecomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetrinstruction (        pBHarrayhead,        (unsigned char*)"\xF3",        1,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        2); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdfsbasecommaname);        return;    }}const char* dg_forthwrgsbasecommaname = "WRGSBASE,";void dg_forthwrgsbasecomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doonetargetrinstruction (        pBHarrayhead,        (unsigned char*)"\xF3",        1,        (unsigned char*)"\x0F\xAE", // popcodestring,        2, // opcodestringlength,        3); // opcodeextension);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthwrgsbasecommaname);        return;    }}const char* dg_compilen8tor8name = "dg_compilen8tor8";void dg_compilen8tor8 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n8    dg_Sibformatter* pregpsf) // assumed to be r8 {    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ((popcodes->n8tor8.opcodestringlength == 0) ||        (popcodes->n8tor8.popcodestring == (const char*)dg_badbufferid))    {        dg_compilen8tom8 (            pBHarrayhead,            popcodes,            pimmediatepsf, // assumed to be n8            pregpsf); // assumed to be m8 with m8 already set up                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen8tor8name);            return;        }                    return;    }        dg_compileopcodeplusropstr (        pBHarrayhead,        popcodes->n8tor8.popcodestring,        popcodes->n8tor8.opcodestringlength,        pregpsf->basereg);  // might be target reg...               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8tor8name);        return;    }        // just trimming value to byte regardless of size    c = (unsigned char)(pimmediatepsf->immediatevalue & 0xFF);         dg_compilesegment (        pBHarrayhead,         (const char*)&c,         1);}const char* dg_compilen16tor16name = "dg_compilen16tor16";void dg_compilen16tor16 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n16    dg_Sibformatter* pregpsf) // assumed to be r16{    unsigned char c = 0x66;    UINT16 w;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ((popcodes->n32tor32.opcodestringlength == 0) ||        (popcodes->n32tor32.popcodestring == (const char*)dg_badbufferid) ||         (pregpsf->memmode == dg_memmodereg))    {        // promote register to memory        dg_compilentom16 (            pBHarrayhead,            popcodes,            pimmediatepsf, // assumed to be n16            pregpsf); // assumed to be m16 with m16 already set up                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen16tor16name);            return;        }                return;    }        // 16 bit opcode prefix    dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tor16name);        return;    }        dg_compileopcodeplusropstr (          pBHarrayhead,          popcodes->n32tor32.popcodestring,          popcodes->n32tor32.opcodestringlength,          pregpsf->basereg);  // might be target reg...        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tor16name);        return;    }        // just trimming value to byte regardless of size    w = (UINT16)(pimmediatepsf->immediatevalue & 0xFFFF);        dg_compilesegment (         pBHarrayhead,          (const char*)&w,         2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16tor16name);        return;    }}const char* dg_compilen32tor32name = "dg_compilen32tor32";void dg_compilen32tor32 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf, // assumed to be n32    dg_Sibformatter* pregpsf) // assumed to be r32{    UINT64 addresssize;    UINT64 immediatesize = 4;        char* popcodestring;        const char* pError;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tor32name);           }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilen32tor32\n");    if ((popcodes->n32tor32.opcodestringlength == 0) ||        (popcodes->n32tor32.popcodestring == (const char*)dg_badbufferid) ||        (pregpsf->memmode == dg_memmodereg))    {        // promote register to memory        dg_compilentom32 (             pBHarrayhead,             popcodes,             pimmediatepsf, // assumed to be n8             pregpsf); // assumed to be m8 with m8 already set up                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen32tor32name);            return;        }                return;    }    if (sizeof(UINT64) == pregpsf->size)    {        if (sizeof(UINT64) != addresssize)        {            dg_pusherror(pBHarrayhead, (const char*)"64 bit regs not supported in 32 bit mode");            dg_pusherror(pBHarrayhead, dg_compilen32tor32name);            return;        }        else        {            // if this is mov n to r 64 bit then immediate size is 8            if (popcodes->n32tor32.popcodestring[0] == (char)0xB8)            {                // if mov, then immediatesize is 8                immediatesize = sizeof(UINT64);            }        }    }        dg_compileopcodeplusropstr (         pBHarrayhead,         popcodes->n32tor32.popcodestring,         popcodes->n32tor32.opcodestringlength,         pregpsf->basereg);  // might be target reg...        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tor32name);        return;    }        pError = dg_checkifvaluefits(        immediatesize,  //        pregpsf->size,   // sign extended to this size        pimmediatepsf->immediatevalue);        if (pError != dg_success)    {        // dg_printzerostring(pBHarrayhead, (unsigned char*)"used value size = ");        // dg_writestdoutuint64tohex(pBHarrayhead, pregpsf->size);        // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_pusherror(pBHarrayhead, pError);        dg_pusherror(pBHarrayhead, dg_checkifvaluefitsname);        dg_pusherror(pBHarrayhead, dg_compilen32tom32name);        return;    }        /*    if (immediatesize != sizeof(UINT64))    {        if (pregpsf->size == sizeof(UINT32))        {            if ((pregpsf->immediatevalue + 0x80000000) >= 0x180000000)            {                dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);                dg_pusherror(pBHarrayhead, dg_compilen32tom32name);                return;            }        }                if (pregpsf->size == sizeof(UINT64))        {            if ((pregpsf->immediatevalue + 0x80000000) >= 0x100000000)            {                dg_pusherror(pBHarrayhead, dg_signedvaluetoobigerror);                dg_pusherror(pBHarrayhead, dg_compilen32tom32name);                return;            }        }    }    */        // just trimming value to byte regardless of size    //  I think this comment might be wrong. ^^    dg_compilesegment (          pBHarrayhead,           (const char*)&(pimmediatepsf->immediatevalue),          immediatesize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32tor32name);        return;    }}const char* dg_compilentorname = "dg_compilentor";void dg_compilentor (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,     dg_Sibformatter* pregpsf) {    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilentor\n");        switch (pregpsf->size)    {        case 1:            dg_compilen8tor8 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pregpsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentorname);                return;            }                        break;                    case 2:            dg_compilen16tor16 (                 pBHarrayhead,                 popcodes,                 pimmediatepsf,                 pregpsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentorname);                return;            }                        break;                    case 8:        case 4:            dg_compilen32tor32 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pregpsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentorname);                return;            }                        break;                    default:                        dg_pusherror(pBHarrayhead, (const char*)"this size not supported yet");            dg_pusherror(pBHarrayhead, dg_compilentorname);            return;                        break;    }}const char* dg_compilen8toa8name = "dg_compilen8toa8";void dg_compilen8toa8 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,    dg_Sibformatter* pmempsf){    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ((popcodes->n8toa8.opcodestringlength == 0) ||        (popcodes->n8toa8.popcodestring == (const char*)dg_badbufferid))    {        dg_compilen8tor8 (             pBHarrayhead,             popcodes,             pimmediatepsf, // assumed to be n32             pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen8toa8name);            return;        }                return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n8toa8.popcodestring,        popcodes->n8toa8.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen8toa8name);        return;    }        // just trimming value to byte regardless of size    c = (unsigned char)((pimmediatepsf->immediatevalue) & 0xFF);        dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);}const char* dg_compilen16toa16name = "dg_compilen16toa16";void dg_compilen16toa16 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,    dg_Sibformatter* pmempsf){    unsigned char c = 0x66;    UINT16 w;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        if ((popcodes->n32toa32.opcodestringlength == 0) ||        (popcodes->n32toa32.popcodestring == (const char*)dg_badbufferid))    {        dg_compilen16tor16 (            pBHarrayhead,            popcodes,            pimmediatepsf, // assumed to be n32            pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen16toa16name);            return;        }                return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)&c,        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16toa16name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n32toa32.popcodestring,        popcodes->n32toa32.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16toa16name);        return;    }        // just trimming value to 16 bits regardless of size    w = (UINT16)((pimmediatepsf->immediatevalue) & 0xFFFF);        dg_compilesegment (        pBHarrayhead,        (const char*)&w,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16toa16name);        return;    }}// also does n32 to a64const char* dg_compilen32toa32name = "dg_compilen32toa32";void dg_compilen32toa32 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,    dg_Sibformatter* pmempsf){    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compilen32toa32\n");        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32toa32name);        return;    }        if ((popcodes->n32toa32.opcodestringlength == 0) ||        (popcodes->n32toa32.popcodestring == (const char*)dg_badbufferid))    {        dg_compilen32tor32 (            pBHarrayhead,            popcodes,            pimmediatepsf, // assumed to be n32            pmempsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilen32toa32name);            return;        }                return;    }        dg_compilesegment(        pBHarrayhead,        popcodes->n32toa32.pprefixstring,        popcodes->n32toa32.prefixstringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16toa16name);        return;    }        dg_compilerexnotargetreg(        pBHarrayhead,        pmempsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen16toa16name);        return;    }        dg_compilesegment (        pBHarrayhead,        popcodes->n32toa32.popcodestring,        popcodes->n32toa32.opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32toa32name);        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)&(pimmediatepsf->immediatevalue),        sizeof(UINT32));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilen32toa32name);        return;    }}/*const char* dg_compilentoa32name = "dg_compilentoa32";void dg_compilentoa32 (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,    dg_Sibformatter* pregpsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // if immediatepsf->size is 0, then use smallest size that will hold the immediate value    // i}*/const char* dg_compilentoaname = "dg_compilentoa";void dg_compilentoa (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pimmediatepsf,    dg_Sibformatter* pregpsf){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        switch (pregpsf->size)    {        case 1:            dg_compilen8toa8 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pregpsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentoaname);                return;            }                        break;                    case 2:            dg_compilen16toa16 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pregpsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentoaname);                return;            }                        break;                case 8:        case 4:            dg_compilen32toa32 (                pBHarrayhead,                popcodes,                pimmediatepsf,                pregpsf);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilentoaname);                return;            }                        break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"this size not supported yet");            dg_pusherror(pBHarrayhead, dg_compilentoaname);            break;    }}/*const char* dg_compilerormrpsfname = "dg_compilerormrpsf";void dg_compilerormrpsf (    Bufferhandle* pBHarrayhead,    dg_opcodeholder* popcodeholder,    dg_Sibformatter* ppsf,    UINT64 usessize2prefix){    UINT64 c = 0x66;    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilepsfname);        return;    }        if ((popcodeholder->opcodestringlength == 0) ||        (popcodeholder->popcodestring == (const char*)dg_badbufferid))    {        dg_pusherror(pBHarrayhead, (const char*)"opcode string for compiling register to/from memory instruction is not set");        dg_pusherror(pBHarrayhead, dg_compilepsfname);        return;    }        if (usessize2prefix != FORTH_FALSE)    {        // 16 bit opcode prefix        dg_compilesegment (            pBHarrayhead,            (const char*)&c,            1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);            return;        }    }        dg_formatpsf(        pBHarrayhead,        ppsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);        return;    }        dg_compilesegment(        pBHarrayhead,        popcodeholder->pprefixstring,        popcodeholder->prefixstringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);        return;    }        // rex goes here - need to do base/index reg, size, and target reg    dg_compilerex (        pBHarrayhead,        ppsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);        return;    }        dg_compilesegment (         pBHarrayhead,         popcodeholder->popcodestring,         popcodeholder->opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);        return;    }        dg_compilepsf (         pBHarrayhead,         ppsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);        return;    }        // need to make this support immediate values for EXTRACTPS,    dg_compilesegment (          pBHarrayhead,          (const char*)&(pmempsf->immediatevalue),          ppsf->immediatesize); // assumes little endian        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilerormrpsfname);        return;    }}*/const char* dg_compilertomname = "dg_compilertom";void dg_compilertom (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pregpsf,    dg_Sibformatter* pmempsf)  // could pass in error too{    UINT64 c = 0x66;    dg_opcodeholder* popcodeholder;    UINT64 isreverse = FORTH_FALSE;    UINT64 mysize;    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;    UINT64 mytrueopcodelength;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        // for rex calculation when using xmm... mem size is ignored when using xmm    pregpsf->usesxmmandmemtargetsize = popcodes->usesxmmandmemtargetsize;    pmempsf->usesxmmandmemtargetsize = popcodes->usesxmmandmemtargetsize;        // determine size, direction, and opcode string to use      // mtor is considered forward, rtom is considered reverse      // this comes into play for register to register operations,    if ( (pregpsf->direction == 0) &&         (pmempsf->direction == 0) )    {        isreverse = FORTH_TRUE;    }        mysize = pregpsf->size;        // if using xmm with specified mem size, if mempsf is mem then    //  mempsf size must be default or specified mem size    if (popcodes->usesxmmandmemtargetsize != 0)    {        if (pmempsf->size != popcodes->usesxmmandmemtargetsize)        {            dg_pusherror(pBHarrayhead, (const char*)"this instruction only supports one size memory target, you don't have to specify the size, but if you do, it has to be the size the instruction supports.");            dg_pusherror(pBHarrayhead, dg_compilertomname);            return;        }    }        else    {        if ( (pmempsf->size != 0) && // if mem target size is not default             (pmempsf->size != pregpsf->size) ) // and is not equal to register target size        {            dg_pusherror(pBHarrayhead, (const char*)"size of both targets must match. automatic size conversion not supported... yet");            dg_pusherror(pBHarrayhead, dg_compilertomname);           return;        }    }        switch (mysize)    {        case 1:            if (isreverse == FORTH_FALSE)            {                popcodeholder = &(popcodes->m8tor8);            }            else            {                popcodeholder = &(popcodes->r8tom8);            }                        break;                    case 2:        case 4:        case 8:        case 16:            if (isreverse == FORTH_FALSE)            {                popcodeholder = &(popcodes->m32tor32);            }            else            {                popcodeholder = &(popcodes->r32tom32);            }                        break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"non standard target sizes not supported... yet. Must be one of 1, 2, 4, 8, or 16 bytes.");            dg_pusherror(pBHarrayhead, dg_compilertomname);            return;    }            if ((popcodeholder->opcodestringlength == 0) ||        (popcodeholder->popcodestring == (const char*)dg_badbufferid))    {        dg_pusherror(pBHarrayhead, (const char*)"opcode string for compiling register to/from memory instruction is not set");        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        if (2 == mysize)    {        // 16 bit opcode prefix        dg_compilesegment (            pBHarrayhead,            (const char*)&c,            1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compilertomname);            return;        }    }        dg_formatpsf(        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        pmempsf->targetreg = pregpsf->basereg;        dg_compilesegment(        pBHarrayhead,        popcodeholder->pprefixstring,        popcodeholder->prefixstringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        // rex goes here - need to do base/index reg, size, and target reg    dg_compilerex (        pBHarrayhead,        pmempsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        dg_compilesegment (         pBHarrayhead,         popcodeholder->popcodestring,         popcodeholder->opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        dg_compilepsf (         pBHarrayhead,         pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }        // need to make this support immediate values for EXTRACTPS,    dg_compilesegment (          pBHarrayhead,          (const char*)&(pmempsf->immediatevalue),          pmempsf->immediatesize); // assumes little endian        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilertomname);        return;    }}const char* dg_compilegenericrtomname = "dg_compilegenericrtom";void dg_compilegenericrtom (    Bufferhandle* pBHarrayhead,    dg_opcodeholder* pforwardopcodeholder,    dg_opcodeholder* preverseopcodeholder,    dg_Sibformatter* pregpsf,    dg_Sibformatter* pmempsf,    UINT64 memsize){    UINT64 isreverse = FORTH_FALSE;    UINT64 mysize;    UINT64 ccbufferid;    UINT64 beforeinstructionccboffset;    UINT64 mytrueopcodelength;    struct dg_opcodeholder* popcodeholder;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        // determine size, direction, and opcode string to use      // mtor is considered forward, rtom is considered reverse      // this comes into play for register to register operations,    if ( (pregpsf->direction == 0) &&         (pmempsf->direction == 0) )    {        isreverse = FORTH_TRUE;    }        // size can't possibly be 0 since the mem size is automatically set to the reg size if the user didn't set it    if ( (pmempsf->size != pregpsf->size) && // if mem target size was not default         (pmempsf->size != memsize) ) // and is not equal to specified mem size...    {        // the case where the user sets the mem size to the reg size is not caught... be nice to fix that...        dg_pusherror(pBHarrayhead, (const char*)"Only one memory size is allowed for this instruction. You don't have to specify the size, but if you do, it has to be the correct size");        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        if (isreverse == FORTH_FALSE)    {        popcodeholder = pforwardopcodeholder;    }    else    {        popcodeholder = preverseopcodeholder;    }            if ((popcodeholder->opcodestringlength == 0) ||        (popcodeholder->popcodestring == (const char*)dg_badbufferid))    {        dg_pusherror(pBHarrayhead, (const char*)"opcode string for compiling register to/from memory instruction is not set");        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        pmempsf->targetreg = pregpsf->basereg;        // this is so rex won't do the flag to change 32BIT into 64BIT    //  this function is for instructions that have 64BIT memory targets by default among others    // what if I make this smarter.. so that if one of the targets is a reg....    //  but what if it's a regormem instruction and mem is picked? how will it know?    pmempsf->size = 4;        dg_formatpsf(        pBHarrayhead,        pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        dg_compilesegment(        pBHarrayhead,        popcodeholder->pprefixstring,        popcodeholder->prefixstringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        // rex goes here - need to do base/index reg, size, and target reg    dg_compilerex (        pBHarrayhead,        pmempsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        dg_compilesegment (         pBHarrayhead,         popcodeholder->popcodestring,         popcodeholder->opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        dg_compilepsf (         pBHarrayhead,         pmempsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);        return;    }        // for the n8mtoxmmr instructions    if (pmempsf->immediatesize != 0)    {        if (pmempsf->immediatesize == 1)        {            dg_compilesegment(                pBHarrayhead,                (const char*)&(pmempsf->immediatevalue), // assumes little endian                1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);                return;            }        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported... this error shouldn't happen unless...");            dg_pusherror(pBHarrayhead, dg_compilegenericrtomname);            return;        }    }}const char* dg_compilefprtomname = "dg_compilefprtom";void dg_compilefprtom (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pregpsf,    dg_Sibformatter* pmempsf)  // could pass in error too{    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilegenericrtom (        pBHarrayhead,        &(popcodes->m64tofpr),        &(popcodes->fprtom64),        pregpsf,        pmempsf,        popcodes->usesxmmandmemtargetsize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilefprtomname);        return;    }}const char* dg_compilexmmrtomname = "dg_compilexmmrtom";void dg_compilexmmrtom (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pregpsf,    dg_Sibformatter* pmempsf)  // could pass in error too{    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilegenericrtom (        pBHarrayhead,        &(popcodes->m64toxmm),        &(popcodes->xmmtom64),        pregpsf,        pmempsf,        popcodes->usesxmmandmemtargetsize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilexmmrtomname);        return;    }}const char* dg_compilentofpsrname = "dg_compilentofpsr";void dg_compilentofpsr(    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pregpsf, // immediate target    dg_Sibformatter* pmempsf) // fp reg target{    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        pregpsf->basereg = popcodes->n8tofpr.opcodeextension;    pmempsf->immediatevalue = pregpsf->immediatevalue;    pmempsf->immediatesize = pregpsf->immediatesize;    pregpsf->direction = 0;    pmempsf->direction = 0;        if (pmempsf->immediatesize == 0)    {        // could check to see if it fits in a byte        pmempsf->immediatesize = 1;    }        // n8 size is checked here    dg_compilegenericrtom (        pBHarrayhead,        &(popcodes->n8tofpr),        &(popcodes->n8tofpr), // ignoring directin        pregpsf,        pmempsf,        0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilentofpsrname);        return;    }}const char* dg_compilentoxmmrname = "dg_compilentoxmmr";void dg_compilentoxmmr(    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pregpsf, // immediate target    dg_Sibformatter* pmempsf) // xmm reg target{    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        pregpsf->basereg = popcodes->n8toxmm.opcodeextension;    pmempsf->immediatevalue = pregpsf->immediatevalue;    pmempsf->immediatesize = pregpsf->immediatesize;    pregpsf->direction = 0;    pmempsf->direction = 0;        if (pmempsf->immediatesize == 0)    {        // could check to see if it fits in a byte        pmempsf->immediatesize = 1;    }        // n8 size is checked here    dg_compilegenericrtom (        pBHarrayhead,        &(popcodes->n8toxmm),        &(popcodes->n8toxmm), // ignoring direction        pregpsf,        pmempsf,        0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilentoxmmrname);        return;    }}const char* dg_fill2targetemptyoptblname = "dg_fill2targetemptyoptbl";void dg_fill2targetemptyoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // 0-7{    popcodes->n8toa8.opcodestringlength = 0;    popcodes->n8toa8.prefixstringlength = 0;        popcodes->n8tor8.opcodestringlength = 0;    popcodes->n8tor8.prefixstringlength = 0;        popcodes->n8tom8.opcodestringlength = 0;    popcodes->n8tom8.prefixstringlength = 0;        popcodes->n32toa32.opcodestringlength = 0;    popcodes->n32toa32.prefixstringlength = 0;        popcodes->n32tor32.opcodestringlength = 0;    popcodes->n32tor32.prefixstringlength = 0;        popcodes->n32tom32.opcodestringlength = 0;    popcodes->n32tom32.prefixstringlength = 0;        popcodes->n8tom32signextended.opcodestringlength = 0;    popcodes->n8tom32signextended.prefixstringlength = 0;        popcodes->n8tofpr.opcodestringlength = 0;    popcodes->n8tofpr.prefixstringlength = 0;        popcodes->n8toxmm.opcodestringlength = 0;    popcodes->n8toxmm.prefixstringlength = 0;        popcodes->m8tor8.opcodestringlength = 0;    popcodes->m8tor8.prefixstringlength = 0;        popcodes->m32tor32.opcodestringlength = 0;    popcodes->m32tor32.prefixstringlength = 0;        popcodes->m64tofpr.opcodestringlength = 0;    popcodes->m64tofpr.prefixstringlength = 0;        popcodes->m64toxmm.opcodestringlength = 0;    popcodes->m64toxmm.prefixstringlength = 0;        popcodes->r8tom8.opcodestringlength = 0;    popcodes->r8tom8.prefixstringlength = 0;        popcodes->r32tom32.opcodestringlength = 0;    popcodes->r32tom32.prefixstringlength = 0;        popcodes->fprtom64.opcodestringlength = 0;    popcodes->fprtom64.prefixstringlength = 0;        popcodes->xmmtom64.opcodestringlength = 0;    popcodes->xmmtom64.prefixstringlength = 0;        popcodes->usesxmmandmemtargetsize = 0;}const char* dg_fill2targetmovoptblname = "dg_fill2targetmovoptbl";void dg_fill2targetmovoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->n8tor8.popcodestring[0] = (char)0xB0;    popcodes->n8tor8.opcodestringlength = 1;    popcodes->n8tor8.opcodeextension = (UINT64)-1;        popcodes->n8tom8.popcodestring[0] = (char)0xC6;    popcodes->n8tom8.opcodestringlength = 1;    popcodes->n8tom8.opcodeextension = 0;        popcodes->n32tor32.popcodestring[0] = (char)0xB8;    popcodes->n32tor32.opcodestringlength = 1;    popcodes->n32tor32.opcodeextension = (UINT64)-1;        popcodes->n32tom32.popcodestring[0] = (char)0xC7;    popcodes->n32tom32.opcodestringlength = 1;    popcodes->n32tom32.opcodeextension = 0;        popcodes->m8tor8.popcodestring[0] = (char)0x8A;    popcodes->m8tor8.opcodestringlength = 1;    popcodes->m8tor8.opcodeextension = (UINT64)-1;        popcodes->m32tor32.popcodestring[0] = (char)0x8B;    popcodes->m32tor32.opcodestringlength = 1;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r8tom8.popcodestring[0] = (char)0x88;    popcodes->r8tom8.opcodestringlength = 1;    popcodes->r8tom8.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = (char)0x89;    popcodes->r32tom32.opcodestringlength = 1;    popcodes->r32tom32.opcodeextension = (UINT64)-1;}// compile xmm registers to r/m ...//   one and only 1 target must be xmm//   after that it's regular compile two targetsconst char* dg_compiletwotargetsname = "dg_compiletwotargets";void dg_compiletwotargets (    Bufferhandle* pBHarrayhead,    Twotargetopcodestrings* popcodes,    dg_Sibformatter* pfirsttarget,  // top on stack    dg_Sibformatter* psecondtarget) // second on stack{    UINT64 twotargettype;    UINT64 isreverse = FORTH_FALSE;        UINT64 addresssize;    UINT64 mtomtransferreg;        dg_Sibformatter mtomraxtarget;        struct Twotargetopcodestrings mymovopcodes;    struct Twotargetopcodestrings *pmysrcopcodes;    struct Twotargetopcodestrings *pmydestopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing dg_compiletwotargets\n");        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);        return;    }        twotargettype = dg_determine2targettype (        pBHarrayhead,        pfirsttarget, // top on stack        psecondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);        return;    }        if ( (pfirsttarget->direction != 0) ||         (psecondtarget->direction != 0) )    {        isreverse = FORTH_TRUE;        pfirsttarget->direction = 1;        psecondtarget->direction = 1;    }    if (0 == pfirsttarget->size)    {        pfirsttarget->size = psecondtarget->size;    }        if (0 == psecondtarget->size)    {        psecondtarget->size = pfirsttarget->size;    }        if ( (0 == pfirsttarget->size) &&         (0 == psecondtarget->size) )    {        // can't I just say = addresssize?        if (4 == addresssize)        {            // use default size dword            pfirsttarget->size = 4;            psecondtarget->size = 4;        }        else        {            pfirsttarget->size = 8;            psecondtarget->size = 8;        }                // I thinking this should be an error instead...        //dg_pusherror(pBHarrayhead, (const char*)"size for operation must be specified");        //dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);        //return;    }        // need to determine 2 target size...    //  0 means unspecified... will be error eventually (nton case probably)    //    so in this case set default to byte    //  if sizes are specified on both, then both must match    //  if size is only specified on one, then other is set to same size            switch (twotargettype)    {        case dg_nton:                        dg_pusherror(pBHarrayhead, (const char*)"immediate to immediate operations not supported");            dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                        break;                    case dg_ntoa:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"n to a\n");                        dg_compilentoa (                pBHarrayhead,                popcodes,                psecondtarget, // 2nd on stack                pfirsttarget); // top on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                    case dg_ntor:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"n to r\n");                    dg_compilentor (                pBHarrayhead,                popcodes,                psecondtarget, // 2nd on stack                pfirsttarget); // top on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                    case dg_ntom:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"n to m\n");                        dg_compilentom (                pBHarrayhead,                popcodes,                psecondtarget, // second on stack                pfirsttarget); // first on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                case dg_ntofpsr:            // source reg = fpsr ... (mem not allowed, the missing ntom opcode checks for this)            // only n8 is allowed, checked in dg_compilegenericrtom            dg_compilentofpsr(                pBHarrayhead,                popcodes,                psecondtarget, // immediate target                pfirsttarget); // fp reg target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                    break;                case dg_ntoxmmr:            // source reg = xmmr ... (mem not allowed, the missing ntom opcode checks for this)            // only n8 is allowed, checked in dg_compilegenericrtom            dg_compilentoxmmr(                pBHarrayhead,                popcodes,                psecondtarget, // immediate target                pfirsttarget); // xmm reg target                     if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                    break;                    case dg_aton:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"a to n\n");                        dg_compilentoa (                pBHarrayhead,                popcodes,                pfirsttarget, // first on stack                psecondtarget); // second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                    // second target is used as mempsf        case dg_atoa:        case dg_ator:        case dg_rtoa:        case dg_rtor:                    // have to toggle the reverse flag...            if (isreverse == FORTH_FALSE)            {                pfirsttarget->direction = 1;                psecondtarget->direction = 1;            }            else            {                pfirsttarget->direction = 0;                psecondtarget->direction = 0;            }                        dg_compilertom (                pBHarrayhead,                popcodes,                pfirsttarget, // pregpsf, - top on stack                psecondtarget);  // pmempsf, - second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                case dg_mtoa:        case dg_mtor:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"m to r\n");                        // have to toggle the reverse flag...            if (isreverse == FORTH_FALSE)            {                pfirsttarget->direction = 1;                psecondtarget->direction = 1;            }            else            {                pfirsttarget->direction = 0;                psecondtarget->direction = 0;            }                        dg_compilertom (                pBHarrayhead,                popcodes,                pfirsttarget, // pregpsf, - top on stack                psecondtarget);  // pmempsf, - second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                                case dg_atom:        case dg_rtom:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"r to m\n");                        dg_compilertom (                pBHarrayhead,                popcodes,                psecondtarget, // pregpsf, - second on stack                pfirsttarget);  // pmempsf, - first on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                break;                    case dg_rton:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"r to n\n");                        dg_compilentor (                pBHarrayhead,                popcodes,                pfirsttarget, // first on stack                psecondtarget); // second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                    case dg_mton:                        // dg_printzerostring(pBHarrayhead, (unsigned char*)"m to n\n");                        dg_compilentom (                pBHarrayhead,                popcodes,                pfirsttarget, // first on stack                psecondtarget); // second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        break;                    case dg_mtom:            // if it's an xmm optable... would need to use xmm register for transfer...            if (popcodes->m64tofpr.opcodestringlength != 0)            {                // it's a floating point instruction... only supporting MOVQ, for now                if ((popcodes->m64tofpr.popcodestring[0] != (char)0x0F) ||                    (popcodes->m64tofpr.popcodestring[1] != (char)0x6F))                {                    dg_pusherror(pBHarrayhead, (const char*)"only MOVQ is supported for floating point memory to memory operations at this time");                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }                // change the opcode table from MOVQ, to MOV,                dg_fill2targetmovoptbl(                    pBHarrayhead,                    popcodes);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }            }            // I want to make it go mov src>rax operation rax>dest unless it's LEA,            //  for LEA, it's lea src>rax mov rax>dest            //  if forward, pfirsttarget is destination, psecondtarget is source            //  if reverse, psecondtarget is destination, pfirsttarget is destination            // need to check sizes, make sure both are the same...            //  they should be equal at this point unless they were different at the start of this routine            if (pfirsttarget->size != psecondtarget->size)            {                dg_pusherror(pBHarrayhead, (const char*)"size of both targets must match. automatic size conversion not supported... yet");                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }            dg_fill2targetmovoptbl(                pBHarrayhead,                &mymovopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        // check for LEA, case moo            if ( popcodes->m32tor32.popcodestring[0] != (char)0x8D )             {                   pmysrcopcodes = &mymovopcodes;                pmydestopcodes = popcodes;            }            else            {                pmysrcopcodes = popcodes;                pmydestopcodes = &mymovopcodes;            }            switch (pfirsttarget->size)            {            case 8:                mtomtransferreg = dg_rax;                break;            case 4:                mtomtransferreg = dg_eax;                break;            case 2:                mtomtransferreg = dg_ax;                break;            case 1:                mtomtransferreg = dg_al;                break;            default:                // this shouldn't happen... but just in case:                mtomtransferreg = dg_rax;                break;            }            if (FORTH_FALSE == isreverse)            {                dg_initSibformatter(&mtomraxtarget);                mtomraxtarget.basereg = mtomtransferreg;                mtomraxtarget.memmode = dg_memmodedefaultreg;                mtomraxtarget.size = dg_getsizefromreg(mtomtransferreg);                // have to do something with the reverse flags....                mtomraxtarget.direction = 1;                psecondtarget->direction = 1;                dg_compilertom(                    pBHarrayhead,                    pmysrcopcodes, // &mymovopcodes,                    &mtomraxtarget, // pregpsf, - top on stack                    psecondtarget);  // pmempsf, - second on stack                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }                dg_initSibformatter(&mtomraxtarget);                mtomraxtarget.basereg = mtomtransferreg;                mtomraxtarget.memmode = dg_memmodedefaultreg;                mtomraxtarget.size = dg_getsizefromreg(mtomtransferreg);                // mtomraxtarget.direction = 0;                dg_compilertom(                    pBHarrayhead,                    pmydestopcodes, // popcodes,                    &mtomraxtarget, // pregpsf, - second on stack                    pfirsttarget);  // pmempsf, - first on stack                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }            }            else            {                // simple thing to do would be not support reverse                // dg_pusherror(pBHarrayhead, (const char*)"reverse memory to memory operations not supported yet");                // dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                dg_initSibformatter(&mtomraxtarget);                mtomraxtarget.basereg = mtomtransferreg;                mtomraxtarget.memmode = dg_memmodedefaultreg;                mtomraxtarget.size = dg_getsizefromreg(mtomtransferreg);                // have to do something with the reverse flags....                mtomraxtarget.direction = 1;                pfirsttarget->direction = 1;                dg_compilertom(                    pBHarrayhead,                    pmysrcopcodes, // &mymovopcodes,                    &mtomraxtarget, // pregpsf, - top on stack                    pfirsttarget);  // pmempsf, - second on stack                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }                dg_initSibformatter(&mtomraxtarget);                mtomraxtarget.basereg = mtomtransferreg;                mtomraxtarget.memmode = dg_memmodedefaultreg;                mtomraxtarget.size = dg_getsizefromreg(mtomtransferreg);                // mtomraxtarget.direction = 0;                psecondtarget->direction = 0;                dg_compilertom(                    pBHarrayhead,                    pmydestopcodes, // popcodes,                    &mtomraxtarget, // pregpsf, - second on stack                    psecondtarget);  // pmempsf, - first on stack                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }            }            break;            /*            // if it's an xmm optable... would need to use xmm register for transfer...            if (popcodes->m64tofpr.opcodestringlength != 0)              {                // it's a floating point instruction... only supporting MOVQ, for now                if ( (popcodes->m64tofpr.popcodestring[0] != (char)0x0F) ||                     (popcodes->m64tofpr.popcodestring[1] != (char)0x6F) )                {                    dg_pusherror(pBHarrayhead, (const char*)"only MOVQ is supported for floating point memory to memory operations at this time");                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }                                // change the opcode table from MOVQ, to MOV,                dg_fill2targetmovoptbl (                    pBHarrayhead,                    popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }            }                                    // I want to make it go mov src>rax operation rax>dest            //  if forward, pfirsttarget is destination, psecondtarget is source            //  if reverse, psecondtarget is destination, pfirsttarget is destination                        // need to check sizes, make sure both are the same...            //  they should be equal at this point unless they were different at the start of this routine            if (pfirsttarget->size != psecondtarget->size)            {                dg_pusherror(pBHarrayhead, (const char*)"size of both targets must match. automatic size conversion not supported... yet");                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                        switch(pfirsttarget->size)            {                case 8:                    mtomtransferreg = dg_rax;                    break;                case 4:                    mtomtransferreg = dg_eax;                    break;                case 2:                    mtomtransferreg = dg_ax;                    break;                case 1:                    mtomtransferreg = dg_al;                    break;                default:                    // this shouldn't happen... but just in case:                    mtomtransferreg = dg_rax;                    break;            }                        dg_fill2targetmovoptbl (                    pBHarrayhead,                    &mymovopcodes);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                            dg_initSibformatter(&mtomraxtarget);                mtomraxtarget.basereg = mtomtransferreg;                mtomraxtarget.memmode = dg_memmodedefaultreg;                mtomraxtarget.size = dg_getsizefromreg (mtomtransferreg);                        if (FORTH_FALSE == isreverse)            {                // have to do something with the reverse flags....                mtomraxtarget.direction = 1;                psecondtarget->direction = 1;                                // if it's LEA, do LEA, you do the LEA, first and MOV, second                if (0x8d == (unsigned char)popcodes->m32tor32.popcodestring[0])                {                    dg_compilertom (                        pBHarrayhead,                        popcodes,                        &mtomraxtarget, // pregpsf, - top on stack                        psecondtarget);  // pmempsf, - second on stack                }                else                {                    dg_compilertom (                        pBHarrayhead,                        &mymovopcodes,                        &mtomraxtarget, // pregpsf, - top on stack                        psecondtarget);  // pmempsf, - second on stack                }                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }                                dg_initSibformatter(&mtomraxtarget);                    mtomraxtarget.basereg = mtomtransferreg;                    mtomraxtarget.memmode = dg_memmodedefaultreg;                    mtomraxtarget.size = dg_getsizefromreg (mtomtransferreg);                                    // mtomraxtarget.direction = 0;                                if (0x8d == (unsigned char)popcodes->m32tor32.popcodestring[0])                {                    dg_compilertom (                        pBHarrayhead,                        &mymovopcodes,                        &mtomraxtarget, // pregpsf, - second on stack                        pfirsttarget);  // pmempsf, - first on stack                }                else                {                    dg_compilertom (                        pBHarrayhead,                        popcodes,                        &mtomraxtarget, // pregpsf, - second on stack                        pfirsttarget);  // pmempsf, - first on stack                }                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }            }            else            {                // have to do something with the reverse flags....                mtomraxtarget.direction = 1;                pfirsttarget->direction = 1;                                if (0x8d == (unsigned char)popcodes->m32tor32.popcodestring[0])                {                    dg_compilertom (                        pBHarrayhead,                        popcodes,                        &mtomraxtarget, // pregpsf, - top on stack                        pfirsttarget);  // pmempsf, - second on stack                }                else                {                    dg_compilertom (                        pBHarrayhead,                        &mymovopcodes,                        &mtomraxtarget, // pregpsf, - top on stack                        pfirsttarget);  // pmempsf, - second on stack                }                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }                                dg_initSibformatter(&mtomraxtarget);                    mtomraxtarget.basereg = mtomtransferreg;                    mtomraxtarget.memmode = dg_memmodedefaultreg;                    mtomraxtarget.size = dg_getsizefromreg (mtomtransferreg);                                    // mtomraxtarget.direction = 0;                psecondtarget->direction = 0;                                if (0x8d == (unsigned char)popcodes->m32tor32.popcodestring[0])                {                            dg_compilertom (                        pBHarrayhead,                        &mymovopcodes,                        &mtomraxtarget, // pregpsf, - second on stack                        psecondtarget);  // pmempsf, - first on stack                }                else                {                    dg_compilertom (                        pBHarrayhead,                        popcodes,                        &mtomraxtarget, // pregpsf, - second on stack                        psecondtarget);  // pmempsf, - first on stack                }                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                    return;                }            }                                    break;            */                case dg_fpsrton:            dg_compilentofpsr(                pBHarrayhead,                popcodes,                pfirsttarget,   // fp reg target                psecondtarget); // immediate target            break;                case dg_mtofpsr:        case dg_fpsrtofpsr:            // have to toggle the reverse flag...            if (isreverse == FORTH_FALSE)            {                pfirsttarget->direction = 1;                psecondtarget->direction = 1;            }            else            {                pfirsttarget->direction = 0;                psecondtarget->direction = 0;            }                        dg_compilefprtom (                pBHarrayhead,                popcodes,                pfirsttarget, // pregpsf, - top on stack                psecondtarget);  // pmempsf, - second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                    break;                case dg_fpsrtom:            dg_compilefprtom (                pBHarrayhead,                popcodes,                psecondtarget, // pregpsf, - second on stack                pfirsttarget);  // pmempsf, - first on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                    break;                case dg_xmmrton:            dg_compilentoxmmr(                   pBHarrayhead,                   popcodes,                   pfirsttarget,   // xmm reg target                   psecondtarget); // immediate target                               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }            break;                case dg_mtoxmmr:        case dg_xmmrtoxmmr:                    // have to toggle the reverse flag...            if (isreverse == FORTH_FALSE)            {                pfirsttarget->direction = 1;                psecondtarget->direction = 1;            }            else            {                pfirsttarget->direction = 0;                psecondtarget->direction = 0;            }                        dg_compilexmmrtom (                pBHarrayhead,                popcodes,                pfirsttarget, // pregpsf, - top on stack                psecondtarget);  // pmempsf, - second on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                    break;                case dg_xmmrtom:            dg_compilexmmrtom (                pBHarrayhead,                popcodes,                psecondtarget, // pregpsf, - second on stack                pfirsttarget);  // pmempsf, - first on stack                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);                return;            }                    break;                default:            dg_pusherror(pBHarrayhead, (const char*)"unsupported two target mode");            dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);            break;    }}// hmm, how do I do the memory storage for the opcode strings?const char* dg_fill2targetmathoptblname = "dg_fill2targetmathoptbl";void dg_fill2targetmathoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 mathopindex) // 0-7{    dg_fill2targetemptyoptbl (        pBHarrayhead,        popcodes);        popcodes->n8toa8.popcodestring[0] = (char)(0x04 | ((mathopindex & 0x7) << 3));    popcodes->n8toa8.opcodestringlength = 1;    popcodes->n8toa8.opcodeextension = (UINT64)-1;        // popcodes->n8tor8.popcodestring[0] = (char)0;    // popcodes->n8tor8.opcodestringlength = 0;    // popcodes->n8tor8.opcodeextension = (UINT64)-1;        popcodes->n8tom8.popcodestring[0] = (char)0x80;    popcodes->n8tom8.opcodestringlength = 1;    popcodes->n8tom8.opcodeextension = mathopindex & 0x7;        popcodes->n32toa32.popcodestring[0] = (char)5 | ((mathopindex & 0x7) << 3);    popcodes->n32toa32.opcodestringlength = 1;    popcodes->n32toa32.opcodeextension = (UINT64)-1;        // popcodes->n32tor32.popcodestring[0] = (char)0;    // popcodes->n32tor32.opcodestringlength = 0;    // popcodes->n32tor32.opcodeextension = (UINT64)-1;        popcodes->n32tom32.popcodestring[0] = (char)0x81;    popcodes->n32tom32.opcodestringlength = 1;    popcodes->n32tom32.opcodeextension = mathopindex & 0x7;        popcodes->n8tom32signextended.popcodestring[0] = (char)0x83;    popcodes->n8tom32signextended.opcodestringlength = 1;    popcodes->n8tom32signextended.opcodeextension = mathopindex & 0x7;        popcodes->m8tor8.popcodestring[0] = (char)(0x02 | ((mathopindex & 0x7) << 3));    popcodes->m8tor8.opcodestringlength = 1;    popcodes->m8tor8.opcodeextension = (UINT64)-1;        popcodes->m32tor32.popcodestring[0] = (char)(0x03 | ((mathopindex & 0x7) << 3));    popcodes->m32tor32.opcodestringlength = 1;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r8tom8.popcodestring[0] = (char)(0x00 | ((mathopindex & 0x7) << 3));    popcodes->r8tom8.opcodestringlength = 1;    popcodes->r8tom8.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = 0x01 | ((mathopindex & 0x7) << 3);    popcodes->r32tom32.opcodestringlength = 1;    popcodes->r32tom32.opcodeextension = (UINT64)-1;        // popcodes->usesxmmandmemtargetsize = 0;}// ADCX 66 0F 38 F6 /rconst char* dg_fill2targetadcxoptblname = "dg_fill2targetadcxoptbl";void dg_fill2targetadcxoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->m32tor32.pprefixstring[0] = 0x66;    popcodes->m32tor32.prefixstringlength = 1;    popcodes->m32tor32.popcodestring[0] = 0x0F;    popcodes->m32tor32.popcodestring[1] = 0x38;    popcodes->m32tor32.popcodestring[2] = 0xF6;    popcodes->m32tor32.opcodestringlength = 3;    popcodes->m32tor32.opcodeextension = (UINT64)-1;    }// ADOX F3 0F 38 F6 /rconst char* dg_fill2targetadoxoptblname = "dg_fill2targetadoxoptbl";void dg_fill2targetadoxoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->m32tor32.pprefixstring[0] = 0xF3;    popcodes->m32tor32.prefixstringlength = 1;    popcodes->m32tor32.popcodestring[0] = 0x0F;    popcodes->m32tor32.popcodestring[1] = 0x38;    popcodes->m32tor32.popcodestring[2] = 0xF6;    popcodes->m32tor32.opcodestringlength = 3;    popcodes->m32tor32.opcodeextension = (UINT64)-1;}    const char* dg_fill2targettestoptblname = "dg_fill2targettestoptbl";void dg_fill2targettestoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->n8toa8.popcodestring[0] = (char)0xA8;    popcodes->n8toa8.opcodestringlength = 1;    popcodes->n8toa8.opcodeextension = (UINT64)-1;        popcodes->n8tom8.popcodestring[0] = (char)0xF6;    popcodes->n8tom8.opcodestringlength = 1;    popcodes->n8tom8.opcodeextension = 0;        popcodes->n32toa32.popcodestring[0] = (char)0xA9;    popcodes->n32toa32.opcodestringlength = 1;    popcodes->n32toa32.opcodeextension = (UINT64)-1;        popcodes->n32tom32.popcodestring[0] = (char)0xF7;    popcodes->n32tom32.opcodestringlength = 1;    popcodes->n32tom32.opcodeextension = 0;        popcodes->m8tor8.popcodestring[0] = (char)0x84;    popcodes->m8tor8.opcodestringlength = 1;    popcodes->m8tor8.opcodeextension = (UINT64)-1;        popcodes->m32tor32.popcodestring[0] = (char)0x85;    popcodes->m32tor32.opcodestringlength = 1;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r8tom8.popcodestring[0] = (char)0x84;    popcodes->r8tom8.opcodestringlength = 1;    popcodes->r8tom8.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = (char)0x85;    popcodes->r32tom32.opcodestringlength = 1;    popcodes->r32tom32.opcodeextension = (UINT64)-1;}const char* dg_fill2targetmemonlyoptblname = "dg_fill2targetmemonlyoptbl";void dg_fill2targetmemonlyoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 memopcode){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->m8tor8.popcodestring[0] = (char)(memopcode & 0xff);    popcodes->m8tor8.opcodestringlength = 1;    popcodes->m8tor8.opcodeextension = (UINT64)-1;        popcodes->m32tor32.popcodestring[0] = (char)((memopcode & 0xff)| 1);    popcodes->m32tor32.opcodestringlength = 1;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r8tom8.popcodestring[0] = (char)(memopcode & 0xff);    popcodes->r8tom8.opcodestringlength = 1;    popcodes->r8tom8.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = (char)((memopcode & 0xff) | 1);    popcodes->r32tom32.opcodestringlength = 1;    popcodes->r32tom32.opcodeextension = (UINT64)-1;}const char* dg_fill2targetmembonlyoptblname = "dg_fill2targetmembonlyoptbl";void dg_fill2targetmembonlyoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 memopcode){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->m8tor8.popcodestring[0] = (char)0x0F;    popcodes->m8tor8.popcodestring[1] = (char)(memopcode & 0xff);    popcodes->m8tor8.opcodestringlength = 2;    popcodes->m8tor8.opcodeextension = (UINT64)-1;        popcodes->m32tor32.popcodestring[0] = (char)0x0F;    popcodes->m32tor32.popcodestring[1] = (char)((memopcode & 0xff) | 1);    popcodes->m32tor32.opcodestringlength = 2;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r8tom8.popcodestring[0] = (char)0x0F;    popcodes->r8tom8.popcodestring[1] = (char)(memopcode & 0xff);    popcodes->r8tom8.opcodestringlength = 2;    popcodes->r8tom8.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = (char)0x0F;    popcodes->r32tom32.popcodestring[1] = (char)((memopcode & 0xff) | 1);    popcodes->r32tom32.opcodestringlength = 2;    popcodes->r32tom32.opcodeextension = (UINT64)-1;}const char* dg_fill2targetmem32onlyoptblname = "dg_fill2targetmem32onlyoptbl";void dg_fill2targetmem32onlyoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 memopcode){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);    popcodes->m32tor32.popcodestring[0] = (char)(memopcode & 0xff);    popcodes->m32tor32.opcodestringlength = 1;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = (char)(memopcode & 0xff);    popcodes->r32tom32.opcodestringlength = 1;    popcodes->r32tom32.opcodeextension = (UINT64)-1;}const char* dg_fill2targetm32bonlyoptblname = "dg_fill2targetm32bonlyoptbl";void dg_fill2targetm32bonlyoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 memopcode){    dg_fill2targetemptyoptbl(        pBHarrayhead,        popcodes);        popcodes->m32tor32.popcodestring[0] = (char)0x0F;    popcodes->m32tor32.popcodestring[1] = (char)(memopcode & 0xff);    popcodes->m32tor32.opcodestringlength = 2;    popcodes->m32tor32.opcodeextension = (UINT64)-1;        popcodes->r32tom32.popcodestring[0] = (char)0x0F;    popcodes->r32tom32.popcodestring[1] = (char)(memopcode & 0xff);    popcodes->r32tom32.opcodestringlength = 2;    popcodes->r32tom32.opcodeextension = (UINT64)-1;}const char* dg_pullandcompilevexbmishiftname = "dg_pullandcompilevexbmishift";void dg_pullandcompilevexbmishift (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morrsourceopcodebyte,    UINT64 morrdestinationopcodebyte,    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_Sibformatter firsttarget;    dg_Sibformatter secondsourcetarget;    dg_Sibformatter thirdtarget;    dg_Sibformatter immediatetarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondsourcetarget);    dg_initSibformatter(&thirdtarget);    dg_initSibformatter(&immediatetarget);         dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pimmediatetarget = &immediatetarget;    dg_Sibformatter* psecondsourcetarget = &secondsourcetarget;        dg_Sibformatter* prslashmtarget = &thirdtarget;    dg_Sibformatter* prtarget = &firsttarget;        UINT64 sourcetargettype;    UINT64 secondsourcetargettype;    UINT64 destinationtargettype;    UINT64 immediatetargettype;    UINT64 rslashmtargettype;    UINT64 rtargettype;        UINT64 rexdotw = 0;        UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack forward destination            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack                       // forward source target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &immediatetarget); // fourth on stack if secondsource is used otherwise third on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }                immediatetargettype = dg_gettargettype(            pBHarrayhead,            pimmediatetarget);                    if (immediatetargettype != dg_targettypeimmediate)        {            dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }    }        if ((disallowedmodes & 8) != 8) // if used, this is the shift    {        dg_pulloneaddressingmode(            pBHarrayhead,            &secondsourcetarget); // top on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }                secondsourcetargettype = dg_gettargettype(            pBHarrayhead,            &secondsourcetarget); // second on stack if used                    if ((secondsourcetargettype != dg_targettyperega) &&            (secondsourcetargettype != dg_targettypereg))        {            dg_pusherror(pBHarrayhead, (const char*)"second source target must be a register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }    }    else    {        // have to set second source base reg to 0 if it isn't used        secondsourcetarget.basereg = 0;    }        if ( (firsttarget.direction != 0) ||         (secondsourcetarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondsourcetarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse == FORTH_FALSE)    {        pdestinationtarget = &firsttarget;        psourcetarget = &thirdtarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);        if ((sourcetargettype == dg_targettypemem) &&        (destinationtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"both source and destination target can not be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        rslashmtargettype = sourcetargettype;    rtargettype = destinationtargettype;        if (isreverse == FORTH_FALSE)    {        // if it is forward and the destination is memory then switch to using reverse opcode        if (destinationtargettype == dg_targettypemem)        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }    }    else    {        // if it is reverse and the source is memory then switch to using forward opcode        if (sourcetargettype == dg_targettypemem)        {            isreverse = FORTH_FALSE;        }        else        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;        }    }        if ((disallowedmodes & 0x20) == 0x20)    {        if (rslashmtargettype != dg_targettypemem)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be memory");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be memory");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }    }        if ((disallowedmodes & 0x40) == 0x40)    {        if ((rslashmtargettype != dg_targettypereg) &&            (rslashmtargettype != dg_targettyperega))        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be register");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be register");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }    }        prslashmtarget->targetreg = prtarget->basereg;    prslashmtarget->secondsourcereg = psecondsourcetarget->basereg;  // check this for all...        if(prslashmtarget->size == 0)    {        prslashmtarget->size = prtarget->size;    }        /*  // this check wont work for mem target....    if ( ((disallowedmodes & 4) == 4) &&         (psourcetarget->size != pdestinationtarget->size) )    {        dg_pusherror(pBHarrayhead, (const char*)"destination and source register must be the same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }    */        if (prslashmtarget->size == 8)    {        rexdotw = 1;    }        // dg_formatpsf needs to know about the immediate size for the [O] calculation    if ((disallowedmodes & 0x10) != 0x10)    {        if (pimmediatetarget->immediatesize == 0)        {            pimmediatetarget->immediatesize = 1; // gonna force it to byte since that's the only thing supported        }                if (pimmediatetarget->immediatesize != 1)        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }                prslashmtarget->immediatesize = pimmediatetarget->immediatesize; // I could just make it 1...        prslashmtarget->immediatevalue = pimmediatetarget->immediatevalue; // this probably isn't needed since I use pimmediatetarget below    }                dg_formatpsf(        pBHarrayhead,        prslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        prslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        if (isreverse == FORTH_FALSE)    {        dg_compilesegment(            pBHarrayhead,            (const char*)&(morrsourceopcodebyte), // assumes little endian            1);    }    else    {        dg_compilesegment(            pBHarrayhead,            (const char*)&(morrdestinationopcodebyte), // assumes little endian            1);    }            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        dg_compilepsf(        pBHarrayhead,        prslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexbmishiftname);            return;        }    }}const char* dg_forthrorxcommaname = "RORX,";void dg_forthrorxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexbmishift (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF0, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x0C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrorxcommaname);        return;    }}const char* dg_forthsarxcommaname = "SARX,";void dg_forthsarxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexbmishift (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF7, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsarxcommaname);        return;    }}const char* dg_forthshlxcommaname = "SHLX,";void dg_forthshlxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexbmishift (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF7, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthshlxcommaname);        return;    }}const char* dg_forthshrxcommaname = "SHRX,";void dg_forthshrxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexbmishift (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF7, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthshrxcommaname);        return;    }}const char* dg_pullandcompilevexn8rmorrtofromrname = "dg_pullandcompilevexn8rmorrtofromr";void dg_pullandcompilevexn8rmorrtofromr (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morrsourceopcodebyte,    UINT64 morrdestinationopcodebyte,    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_Sibformatter firsttarget;    dg_Sibformatter secondsourcetarget;    dg_Sibformatter thirdtarget;    dg_Sibformatter immediatetarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondsourcetarget);    dg_initSibformatter(&thirdtarget);    dg_initSibformatter(&immediatetarget);         dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pimmediatetarget = &immediatetarget;    dg_Sibformatter* psecondsourcetarget = &secondsourcetarget;        dg_Sibformatter* prslashmtarget = &thirdtarget;    dg_Sibformatter* prtarget = &firsttarget;        UINT64 sourcetargettype;    UINT64 secondsourcetargettype;    UINT64 destinationtargettype;    UINT64 immediatetargettype;    UINT64 rslashmtargettype;    UINT64 rtargettype;        UINT64 rexdotw = 0;        UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        if ((disallowedmodes & 8) != 8)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &secondsourcetarget); // top on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }                secondsourcetargettype = dg_gettargettype(            pBHarrayhead,            &secondsourcetarget); // second on stack if used                    if ((secondsourcetargettype != dg_targettyperega) &&            (secondsourcetargettype != dg_targettypereg))        {            dg_pusherror(pBHarrayhead, (const char*)"second source target must be a register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &immediatetarget); // fourth on stack if secondsource is used otherwise third on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }                immediatetargettype = dg_gettargettype(            pBHarrayhead,            pimmediatetarget);                    if (immediatetargettype != dg_targettypeimmediate)        {            dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }    }        if ( (firsttarget.direction != 0) ||         (secondsourcetarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondsourcetarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse != FORTH_FALSE)    {        pdestinationtarget = &thirdtarget;        psourcetarget = &firsttarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);            if ((destinationtargettype != dg_targettypemem) &&        (destinationtargettype != dg_targettypereg) &&        (destinationtargettype != dg_targettyperega))    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be a register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        if ((sourcetargettype != dg_targettypereg) &&        (sourcetargettype != dg_targettyperega) &&        (sourcetargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be a register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        if ((sourcetargettype == dg_targettypemem) &&        (destinationtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"both source and destination target can not be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        prslashmtarget = psourcetarget;    prtarget = pdestinationtarget;    rslashmtargettype = sourcetargettype;    rtargettype = destinationtargettype;        if (isreverse == FORTH_FALSE)  // forward opcode goes from morxmm source to xmm destination    {        // if it's forward and source is memory, and there is no opcode byte, then error out        if (morrsourceopcodebyte == (UINT64)-1)        {            if (sourcetargettype == dg_targettypemem)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or reg to reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);                return;            }        }                // if it is forward and the destination is memory then switch to using reverse opcode        //  or if there is no forward opcode then also switch to reverse        if ( (destinationtargettype == dg_targettypemem) ||             (morrsourceopcodebyte == (UINT64)-1) )        {            // if there is no reverse opcode then error out            if (morrdestinationopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"reg to memory or reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);                return;            }                        prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }    }    else    {        // if it's reverse and destination is memory, and there is no opcode byte, then error out        if (morrdestinationopcodebyte == (UINT64)-1)        {            if (destinationtargettype == dg_targettypemem)            {                dg_pusherror(pBHarrayhead, (const char*)"reg to memory or reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);                return;            }        }                // if it is reverse and the source is memory then switch to using forward opcode        //  or if there is no reverse opcode then also switch to using forward.        if ( (sourcetargettype == dg_targettypemem) ||             (morrdestinationopcodebyte == (UINT64)-1) )        {            // if there is no forward opcode then error out            if (morrsourceopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or reg to reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);                return;            }                        isreverse = FORTH_FALSE;        }        else        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;        }    }    /*    if (isreverse == FORTH_FALSE)    {        // if it is forward and the destination is memory then switch to using reverse opcode        if (destinationtargettype == dg_targettypemem)        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }    }    else    {        // if it is reverse and the source is memory then switch to using forward opcode        if (sourcetargettype == dg_targettypemem)        {            isreverse = FORTH_FALSE;        }        else        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;        }    }    */        if ((disallowedmodes & 0x20) == 0x20)    {        if (rslashmtargettype != dg_targettypemem)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be memory");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be memory");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }    }        if ((disallowedmodes & 0x40) == 0x40)    {        if ((rslashmtargettype != dg_targettypereg) &&            (rslashmtargettype != dg_targettyperega))        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be register");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be register");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }    }    /*    if ( ((disallowedmodes & 1) == 1) &&         (prtarget->size == 4) )    {        if (isreverse == FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target can't be a 32 bit register");        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"source target can't be a 32 bit register");        }        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ( ((disallowedmodes & 2) == 2) &&         (pxmmtarget->size == 8) )    {        if (isreverse == FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target can't be a 64 bit register");        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"source target can't be a 64 bit register");        }        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ( ((disallowedmodes & 4) == 4) &&         (sourcetargettype == dg_targettypexmmreg) &&         (destinationtargettype == dg_targettypexmmreg) &&         (psourcetarget->size != pdestinationtarget->size) )    {        dg_pusherror(pBHarrayhead, (const char*)"destination and source register must be the same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }    */                prslashmtarget->targetreg = prtarget->basereg;    prslashmtarget->secondsourcereg = psecondsourcetarget->basereg;  // check this for all...        // if(prslashmtarget->size == 0)    // {        prslashmtarget->size = prtarget->size;    // }        /*  // this check wont work for mem target....    if ( ((disallowedmodes & 4) == 4) &&         (psourcetarget->size != pdestinationtarget->size) )    {        dg_pusherror(pBHarrayhead, (const char*)"destination and source register must be the same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }    */        if (prslashmtarget->size == 8)    {        rexdotw = 1;    }        if ((disallowedmodes & 0x10) != 0x10)    {        // dg_formatpsf needs this for pc relative calculations        prslashmtarget->immediatesize = 1;    }        dg_formatpsf(        pBHarrayhead,        prslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        prslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        if (isreverse == FORTH_FALSE)    {        if (morrsourceopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no forward opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morrsourceopcodebyte), // assumes little endian            1);    }    else    {        if (morrdestinationopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no reverse opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morrdestinationopcodebyte), // assumes little endian            1);    }            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        dg_compilepsf(        pBHarrayhead,        prslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        if ((pimmediatetarget->immediatesize != 0) &&            (pimmediatetarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8rmorrtofromrname);            return;        }    }}const char* dg_forthbextrcommaname = "BEXTR,";void dg_forthbextrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexn8rmorrtofromr (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF7, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbextrcommaname);        return;    }}const char* dg_forthbzhicommaname = "BZHI,";void dg_forthbzhicomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexn8rmorrtofromr (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF5, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbzhicommaname);        return;    }}const char* dg_pullandcompilevexn8morrrtofromrname = "dg_pullandcompilevexn8morrrtofromr";void dg_pullandcompilevexn8morrrtofromr (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morrsourceopcodebyte,    UINT64 morrdestinationopcodebyte,    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_Sibformatter firsttarget;    dg_Sibformatter secondsourcetarget;    dg_Sibformatter thirdtarget;    dg_Sibformatter immediatetarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondsourcetarget);    dg_initSibformatter(&thirdtarget);    dg_initSibformatter(&immediatetarget);         dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pimmediatetarget = &immediatetarget;    dg_Sibformatter* psecondsourcetarget = &secondsourcetarget;        dg_Sibformatter* prslashmtarget = &thirdtarget;    dg_Sibformatter* prtarget = &firsttarget;        UINT64 sourcetargettype;    UINT64 secondsourcetargettype;    UINT64 destinationtargettype;    UINT64 immediatetargettype;    UINT64 rslashmtargettype;    UINT64 rtargettype;        UINT64 rexdotw = 0;        UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ((disallowedmodes & 8) != 8)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &secondsourcetarget); // top on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }                secondsourcetargettype = dg_gettargettype(            pBHarrayhead,            &secondsourcetarget); // second on stack if used                    if ((secondsourcetargettype != dg_targettyperega) &&            (secondsourcetargettype != dg_targettypereg))        {            dg_pusherror(pBHarrayhead, (const char*)"second source target must be a register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &immediatetarget); // fourth on stack if secondsource is used otherwise third on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }                immediatetargettype = dg_gettargettype(            pBHarrayhead,            pimmediatetarget);                    if (immediatetargettype != dg_targettypeimmediate)        {            dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }    }        if ( (firsttarget.direction != 0) ||         (secondsourcetarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondsourcetarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse != FORTH_FALSE)    {        pdestinationtarget = &thirdtarget;        psourcetarget = &firsttarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);            if ((destinationtargettype != dg_targettypemem) &&        (destinationtargettype != dg_targettypereg) &&        (destinationtargettype != dg_targettyperega))    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be a register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ((sourcetargettype != dg_targettypereg) &&        (sourcetargettype != dg_targettyperega) &&        (sourcetargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be a register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ((sourcetargettype == dg_targettypemem) &&        (destinationtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"both source and destination target can not be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        prslashmtarget = psourcetarget;    prtarget = pdestinationtarget;    rslashmtargettype = sourcetargettype;    rtargettype = destinationtargettype;        if (isreverse == FORTH_FALSE)  // forward opcode goes from morxmm source to xmm destination    {        // if it's forward and source is memory, and there is no opcode byte, then error out        if (morrsourceopcodebyte == (UINT64)-1)        {            if (sourcetargettype == dg_targettypemem)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or reg to reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);                return;            }        }                // if it is forward and the destination is memory then switch to using reverse opcode        //  or if there is no forward opcode then also switch to reverse        if ( (destinationtargettype == dg_targettypemem) ||             (morrsourceopcodebyte == (UINT64)-1) )        {            // if there is no reverse opcode then error out            if (morrdestinationopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"reg to memory or reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);                return;            }                        prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }    }    else    {        // if it's reverse and destination is memory, and there is no opcode byte, then error out        if (morrdestinationopcodebyte == (UINT64)-1)        {            if (destinationtargettype == dg_targettypemem)            {                dg_pusherror(pBHarrayhead, (const char*)"reg to memory or reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);                return;            }        }                // if it is reverse and the source is memory then switch to using forward opcode        //  or if there is no reverse opcode then also switch to using forward.        if ( (sourcetargettype == dg_targettypemem) ||             (morrdestinationopcodebyte == (UINT64)-1) )        {            // if there is no forward opcode then error out            if (morrsourceopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or reg to reg not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);                return;            }                        isreverse = FORTH_FALSE;        }        else        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;        }    }    /*    if (isreverse == FORTH_FALSE)    {        // if it is forward and the destination is memory then switch to using reverse opcode        if (destinationtargettype == dg_targettypemem)        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }    }    else    {        // if it is reverse and the source is memory then switch to using forward opcode        if (sourcetargettype == dg_targettypemem)        {            isreverse = FORTH_FALSE;        }        else        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            prtarget = psourcetarget;            rtargettype = sourcetargettype;        }    }    */        if ((disallowedmodes & 0x20) == 0x20)    {        if (rslashmtargettype != dg_targettypemem)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be memory");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be memory");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }    }        if ((disallowedmodes & 0x40) == 0x40)    {        if ((rslashmtargettype != dg_targettypereg) &&            (rslashmtargettype != dg_targettyperega))        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be register");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be register");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }    }    /*    if ( ((disallowedmodes & 1) == 1) &&         (prtarget->size == 4) )    {        if (isreverse == FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target can't be a 32 bit register");        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"source target can't be a 32 bit register");        }        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ( ((disallowedmodes & 2) == 2) &&         (pxmmtarget->size == 8) )    {        if (isreverse == FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target can't be a 64 bit register");        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"source target can't be a 64 bit register");        }        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ( ((disallowedmodes & 4) == 4) &&         (sourcetargettype == dg_targettypexmmreg) &&         (destinationtargettype == dg_targettypexmmreg) &&         (psourcetarget->size != pdestinationtarget->size) )    {        dg_pusherror(pBHarrayhead, (const char*)"destination and source register must be the same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }    */                prslashmtarget->targetreg = prtarget->basereg;    prslashmtarget->secondsourcereg = psecondsourcetarget->basereg;  // check this for all...        // if(prslashmtarget->size == 0)    // {        prslashmtarget->size = prtarget->size;    // }        /*  // this check wont work for mem target....    if ( ((disallowedmodes & 4) == 4) &&         (psourcetarget->size != pdestinationtarget->size) )    {        dg_pusherror(pBHarrayhead, (const char*)"destination and source register must be the same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }    */        if (prslashmtarget->size == 8)    {        rexdotw = 1;    }        if ((disallowedmodes & 0x10) != 0x10)    {        // dg_formatpsf needs this for pc relative calculations        prslashmtarget->immediatesize = 1;    }        dg_formatpsf(        pBHarrayhead,        prslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        prslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if (isreverse == FORTH_FALSE)    {        if (morrsourceopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no forward opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morrsourceopcodebyte), // assumes little endian            1);    }    else    {        if (morrdestinationopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no reverse opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morrdestinationopcodebyte), // assumes little endian            1);    }            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        dg_compilepsf(        pBHarrayhead,        prslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        if ((pimmediatetarget->immediatesize != 0) &&            (pimmediatetarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrrtofromrname);            return;        }    }}const char* dg_forthmulxcommaname = "MULX,";void dg_forthmulxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexn8morrrtofromr (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF6, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulxcommaname);        return;    }}const char* dg_forthpdepcommaname = "PDEP,";void dg_forthpdepcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexn8morrrtofromr (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF5, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpdepcommaname);        return;    }}const char* dg_forthpextcommaname = "PEXT,";void dg_forthpextcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexn8morrrtofromr (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF5, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextcommaname);        return;    }}const char* dg_forthandncommaname = "ANDN,";void dg_forthandncomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                dg_pullandcompilevexn8morrrtofromr (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF2, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source not used                                   // bit 1 = 1 no ymm forward destination or reverse source not used                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 r/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 r/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandncommaname);        return;    }}const char* dg_pullandcompilevexmoropextname = "dg_pullandcompilevexmor";void dg_pullandcompilevexmor (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,          // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 forwardopcodebyte,    UINT64 opcodeextension){    dg_Sibformatter firsttarget;           dg_initSibformatter(&firsttarget);           dg_Sibformatter* prslashmtarget = &firsttarget;        UINT64 rslashmtargettype;    UINT64 rexdotw = 0;           UINT64 addresssize;           UINT64 usethreebytevex = FORTH_FALSE;           UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);           if (baderrorcount == olderrorcount)    {        return;    }           addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }        if (firsttarget.usesthreebytevex != 0)    {        usethreebytevex = FORTH_TRUE;    }        rslashmtargettype = dg_gettargettype(        pBHarrayhead,        prslashmtarget);        if ((rslashmtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"target must be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }        prslashmtarget->targetreg = opcodeextension;        // ignoring memory target size and setting it to 4    prslashmtarget->size = 4;        // this is needed because the default is dg_noreg    prslashmtarget->secondsourcereg = 0;        dg_formatpsf(        pBHarrayhead,        prslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        prslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&(forwardopcodebyte), // assumes little endian        1);               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }        dg_compilepsf(        pBHarrayhead,        prslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmoropextname);        return;    }}const char* dg_forthvldmxcsrcommaname = "VLDMXCSR,";void dg_forthvldmxcsrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexmor (        pBHarrayhead,        0,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xAE,  // forwardopcodebyte,        2);    // opcode extension            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvldmxcsrcommaname);        return;    }}const char* dg_forthvstmxcsrcommaname = "VSTMXCSR,";void dg_forthvstmxcsrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexmor (        pBHarrayhead,        0,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xAE,  // forwardopcodebyte,        3);    // opcode extension    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvstmxcsrcommaname);        return;    }}const char* dg_pullandcompilevexmorrtoropextname = "dg_pullandcompilevexmorrtoropext";void dg_pullandcompilevexmorrtoropext (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,          // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 forwardopcodebyte,    UINT64 opcodeextension){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;           dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);               dg_Sibformatter* psourcetarget = &secondtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;           dg_Sibformatter* prslashmtarget = &secondtarget;        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 sourcetargettype;    UINT64 destinationtargettype;        UINT64 rslashmtargettype;    UINT64 vexregtargettype;           UINT64 rexdotw = 0;           UINT64 addresssize;           UINT64 isreverse = FORTH_FALSE;           UINT64 usethreebytevex = FORTH_FALSE;           UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);           if (baderrorcount == olderrorcount)    {        return;    }           addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;        pdestinationtarget = &secondtarget;        psourcetarget = &firsttarget;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);        if ((destinationtargettype != dg_targettyperega) &&        (destinationtargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be reg");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        if ((sourcetargettype != dg_targettypemem) &&        (sourcetargettype != dg_targettyperega) &&        (sourcetargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be reg or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        prslashmtarget = psourcetarget;        prslashmtarget->targetreg = opcodeextension;    prslashmtarget->secondsourcereg = pdestinationtarget->basereg;    if(prslashmtarget->size == 0)    {        prslashmtarget->size = pdestinationtarget->size;    }        if(prslashmtarget->size != pdestinationtarget->size)    {        dg_pusherror(pBHarrayhead, (const char*)"source and destination targets must be same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        if (prslashmtarget->size == 8)    {        rexdotw = 1;    }        dg_formatpsf(        pBHarrayhead,        prslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        prslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&(forwardopcodebyte), // assumes little endian        1);               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }        dg_compilepsf(        pBHarrayhead,        prslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexmorrtoropextname);        return;    }}const char* dg_forthblsicommaname = "BLSI,";void dg_forthblsicomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexmorrtoropext (        pBHarrayhead,        0,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF3,  // forwardopcodebyte,        3);    // opcode extension    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblsicommaname);        return;    }}const char* dg_forthblsmskcommaname = "BLSMSK,";void dg_forthblsmskcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexmorrtoropext (        pBHarrayhead,        0,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF3,  // forwardopcodebyte,        2);    // opcode extension    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblsmskcommaname);        return;    }}const char* dg_forthblsrcommaname = "BLSR,";void dg_forthblsrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexmorrtoropext (        pBHarrayhead,        0,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xF3,  // forwardopcodebyte,        1);    // opcode extension    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblsrcommaname);        return;    }}const char* dg_pullandcompilevexn8morrxmmtofromxmmname = "dg_pullandcompilevexn8morrxmmtofromxmm";void dg_pullandcompilevexn8morrxmmtofromxmm (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morxmmsourceopcodebyte,    UINT64 morxmmdestinationopcodebyte,    UINT64 memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_Sibformatter firsttarget;    dg_Sibformatter secondsourcetarget;    dg_Sibformatter thirdtarget;    dg_Sibformatter immediatetarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondsourcetarget);    dg_initSibformatter(&thirdtarget);    dg_initSibformatter(&immediatetarget);         dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pimmediatetarget = &immediatetarget;    dg_Sibformatter* psecondsourcetarget = &secondsourcetarget;        dg_Sibformatter* prslashmtarget = &thirdtarget;    dg_Sibformatter* pxmmtarget = &firsttarget;        UINT64 sourcetargettype;    UINT64 secondsourcetargettype;    UINT64 destinationtargettype;    UINT64 immediatetargettype;        UINT64 rslashmtargettype;    UINT64 xmmtargettype;        UINT64 rexdotw = 0;        UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        if ((disallowedmodes & 8) != 8)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &secondsourcetarget); // top on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }                secondsourcetargettype = dg_gettargettype(            pBHarrayhead,            &secondsourcetarget); // second on stack if used                    if (secondsourcetargettype != dg_targettypexmmreg)        {            dg_pusherror(pBHarrayhead, (const char*)"second source target must be an xmm/ymm register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }    }    else    {        secondsourcetarget.basereg = 0;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &immediatetarget); // fourth on stack if secondsource is used otherwise third on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }                immediatetargettype = dg_gettargettype(            pBHarrayhead,            pimmediatetarget);                    if (immediatetargettype != dg_targettypeimmediate)        {            dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }    }        if ( (firsttarget.direction != 0) ||         (secondsourcetarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondsourcetarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse != FORTH_FALSE)    {        psourcetarget = &firsttarget;        pdestinationtarget = &thirdtarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);        if ((sourcetargettype == dg_targettypemem) &&        (destinationtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"both source and destination targets can not be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        rslashmtargettype = sourcetargettype;    xmmtargettype = destinationtargettype;        if (isreverse == FORTH_FALSE)    {        // if it is forward and the destination is register or memory then switch to using reverse opcode        if ((destinationtargettype == dg_targettypemem) ||            (destinationtargettype == dg_targettyperega) ||            (destinationtargettype == dg_targettypereg))        {            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;                        pxmmtarget = psourcetarget;            xmmtargettype = sourcetargettype;                        isreverse = FORTH_TRUE;                        // if it is forward and the source is register or memory            //  and there is no forward opcode then give error            if (morxmmdestinationopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"xmm to memory or register not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);                return;            }        }        else        {            // if it is forward and the source is register or memory            //  and there is no forward opcode then give error            if (morxmmsourceopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or register to xmm not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);                return;            }        }            }    else    {        // if it is reverse and the source is memory or register then switch to using forward opcode        if ((destinationtargettype == dg_targettypemem) ||            (destinationtargettype == dg_targettyperega) ||            (destinationtargettype == dg_targettypereg))                {            isreverse = FORTH_FALSE;        }        else        {            // destination is register or memory            prslashmtarget = pdestinationtarget;            rslashmtargettype = destinationtargettype;            pxmmtarget = psourcetarget;            xmmtargettype = sourcetargettype;        }    }        if ((disallowedmodes & 0x20) == 0x20)    {        if (rslashmtargettype != dg_targettypemem)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be memory");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be memory");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }    }        if ((disallowedmodes & 0x40) == 0x40)    {        if ((rslashmtargettype != dg_targettypereg) &&            (rslashmtargettype != dg_targettyperega))        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be register");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be register");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }    }        prslashmtarget->targetreg = pxmmtarget->basereg;    prslashmtarget->secondsourcereg = psecondsourcetarget->basereg;        if (memtargetsize != 0)    {        // only going to make sure mem size is correct        //  going to ignore reg size and make it same as expected        //  VEXTRB and others can be different register sizes even though only a byte is moved        if (rslashmtargettype == dg_targettypemem)        {            if ((prslashmtarget->size != 0) &&                (prslashmtarget->size != memtargetsize))            {                dg_pusherror(pBHarrayhead, (const char*)"memory target size not expected size");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);                return;            }        }                prslashmtarget->size = memtargetsize;    }        if(prslashmtarget->size == 0)    {        prslashmtarget->size = addresssize;        // dg_pusherror(pBHarrayhead, (const char*)"memory target size must be specified");        // dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        // return;    }        if (prslashmtarget->size == 8)    {        rexdotw = 1;    }        // mdg_printzerostring(pBHarrayhead, (unsigned char*)"\n rexdotw = ");    // dg_writestdoutuinttodec(pBHarrayhead, rexdotw);    // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");            if ((disallowedmodes & 0x10) != 0x10)    {        // dg_formatpsf needs this for pc relative calculations        prslashmtarget->immediatesize = 1;    }        if ((rslashmtargettype != dg_targettyperega) &&        (rslashmtargettype != dg_targettypereg) &&        (rslashmtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        if ((xmmtargettype != dg_targettypexmmreg))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        dg_formatpsf(        pBHarrayhead,        prslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        prslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        if (isreverse == FORTH_FALSE)    {        if (morxmmsourceopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no forward opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmsourceopcodebyte), // assumes little endian            1);    }    else    {        if (morxmmdestinationopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no reverse opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmdestinationopcodebyte), // assumes little endian            1);    }            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        dg_compilepsf(        pBHarrayhead,        prslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        if ((pimmediatetarget->immediatesize != 0) &&            (pimmediatetarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morrxmmtofromxmmname);            return;        }    }}const char* dg_forthvextractpscommaname = "VEXTRACTPS,";void dg_forthvextractpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x17, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x0A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                           // bit 1 = 1 no ymm forward destination or reverse source                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target                           // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                           // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvextractpscommaname);        return;    }}const char* dg_forthvcvtsi2sdcommaname = "VCVTSI2SD,";void dg_forthvcvtsi2sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x2A, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x12); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                               // bit 1 = 1 no ymm forward destination or reverse source                               // bit 2 = 1 source and dest regs can't be different sizes                               // bit 3 = 1 no 2nd source target                               // bit 4 = 1 no immediate target                               // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                               // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtsi2sdcommaname);        return;    }}const char* dg_forthvcvtsi2sscommaname = "VCVTSI2SS,";void dg_forthvcvtsi2sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x2A, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x12); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                               // bit 1 = 1 no ymm forward destination or reverse source                               // bit 2 = 1 source and dest regs can't be different sizes                               // bit 3 = 1 no 2nd source target                               // bit 4 = 1 no immediate target                               // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                               // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtsi2sscommaname);        return;    }}const char* dg_forthvmovdcommaname = "VMOVD,";void dg_forthvmovdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x6E, // morxmmsourceopcodebyte,        0x7E, // morxmmdestinationopcodebyte,        4, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovdcommaname);        return;    }}const char* dg_forthvmovq2commaname = "VMOVQ2,";void dg_forthvmovq2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x6E, // morxmmsourceopcodebyte,        0x7E, // morxmmdestinationopcodebyte,        8, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovq2commaname);        return;    }}const char* dg_forthvpextrbcommaname = "VPEXTRB,";void dg_forthvpextrbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x14, // morxmmdestinationopcodebyte,        1, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x0A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpextrbcommaname);        return;    }}const char* dg_forthvpextrdcommaname = "VPEXTRD,";void dg_forthvpextrdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x16, // morxmmdestinationopcodebyte,        4, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x0A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpextrdcommaname);        return;    }}const char* dg_forthvpextrqcommaname = "VPEXTRQ,";void dg_forthvpextrqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x16, // morxmmdestinationopcodebyte,        8, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x0A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpextrqcommaname);        return;    }}const char* dg_forthvpextrwcommaname = "VPEXTRW,";void dg_forthvpextrwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x15, // morxmmdestinationopcodebyte,        2, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x0A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpextrwcommaname);        return;    }}const char* dg_pullandcompilevexn8morxmmxmmtofromrname = "dg_pullandcompilevexn8morxmmxmmtofromr";void dg_pullandcompilevexn8morxmmxmmtofromr (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morxmmsourceopcodebyte,    UINT64 morxmmdestinationopcodebyte,    UINT64 memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_Sibformatter firsttarget;    dg_Sibformatter secondsourcetarget;    dg_Sibformatter thirdtarget;    dg_Sibformatter immediatetarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondsourcetarget);    dg_initSibformatter(&thirdtarget);    dg_initSibformatter(&immediatetarget);         dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pimmediatetarget = &immediatetarget;    dg_Sibformatter* psecondsourcetarget = &secondsourcetarget;        dg_Sibformatter* prtarget = &firsttarget;    dg_Sibformatter* pxmmslashmtarget = &thirdtarget;        UINT64 sourcetargettype;    UINT64 secondsourcetargettype;    UINT64 destinationtargettype;    UINT64 immediatetargettype;    UINT64 xmmslashmtargettype;    UINT64 rtargettype;        UINT64 rexdotw = 0;        UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        if ((disallowedmodes & 8) != 8)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &secondsourcetarget); // top on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }                secondsourcetargettype = dg_gettargettype(            pBHarrayhead,            &secondsourcetarget); // second on stack if used                    if (secondsourcetargettype != dg_targettypexmmreg)        {            dg_pusherror(pBHarrayhead, (const char*)"second source target must be an xmm/ymm register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }    }    else    {        secondsourcetarget.basereg = 0;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &immediatetarget); // fourth on stack if secondsource is used otherwise third on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }                immediatetargettype = dg_gettargettype(            pBHarrayhead,            pimmediatetarget);                    if (immediatetargettype != dg_targettypeimmediate)        {            dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }    }        if ( (firsttarget.direction != 0) ||         (secondsourcetarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondsourcetarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse == FORTH_FALSE)    {        pdestinationtarget = &firsttarget;        psourcetarget = &thirdtarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);        if ((sourcetargettype == dg_targettypemem) &&        (destinationtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"both source and destination target can not be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        rtargettype = destinationtargettype;    xmmslashmtargettype = sourcetargettype;        if (isreverse == FORTH_FALSE)    {        // if it is forward and the destination is memory then switch to using reverse opcode        if (destinationtargettype == dg_targettypemem)        {            prtarget = pdestinationtarget;            rtargettype = destinationtargettype;            pxmmslashmtarget = psourcetarget;            xmmslashmtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }        else        {            // if it is forward and the destination is register            //  and there is no forward opcode then switch to using reverse opcode            if (morxmmsourceopcodebyte == (UINT64)-1)            {                prtarget = pdestinationtarget;                rtargettype = destinationtargettype;                pxmmslashmtarget = psourcetarget;                xmmslashmtargettype = sourcetargettype;                isreverse = FORTH_TRUE;            }        }            }    else    {        // if it is reverse and the source is memory then switch to using forward opcode        if (sourcetargettype == dg_targettypemem)        {            isreverse = FORTH_FALSE;        }        else        {            prtarget = pdestinationtarget;            rtargettype = destinationtargettype;            pxmmslashmtarget = psourcetarget;            xmmslashmtargettype = sourcetargettype;        }    }        if ((disallowedmodes & 0x20) == 0x20)    {        if (xmmslashmtargettype != dg_targettypemem)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be memory");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be memory");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }    }        if ((disallowedmodes & 0x40) == 0x40)    {        if ((xmmslashmtargettype != dg_targettypexmmreg))        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"r/m source target must be an xmm/ymm register");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"r/m destination target must be an xmm/ymm register");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }    }        pxmmslashmtarget->targetreg = prtarget->basereg;    pxmmslashmtarget->secondsourcereg = psecondsourcetarget->basereg;        if (memtargetsize != 0)    {        // only going to make sure mem size is correct        //  going to ignore reg size and make it same as expected        if (xmmslashmtargettype == dg_targettypemem)        {            if ((pxmmslashmtarget->size != 0) &&                (pxmmslashmtarget->size != memtargetsize))            {                dg_pusherror(pBHarrayhead, (const char*)"memory target size not expected size");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);                return;            }        }                pxmmslashmtarget->size = memtargetsize;    }        if(pxmmslashmtarget->size == 0)    {        // use register size if memory size not specified and if opcode didn't set it        pxmmslashmtarget->size = prtarget->size;    }        if (pxmmslashmtarget->size == 8)    {        rexdotw = 1;    }        if ((disallowedmodes & 0x10) != 0x10)    {        // dg_formatpsf needs this for pc relative calculations        pxmmslashmtarget->immediatesize = 1;    }        dg_formatpsf(        pBHarrayhead,        pxmmslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        pxmmslashmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        if (isreverse == FORTH_FALSE)    {        if (morxmmsourceopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no forward opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmsourceopcodebyte), // assumes little endian            1);    }    else    {        if (morxmmdestinationopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no reverse opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmdestinationopcodebyte), // assumes little endian            1);    }            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        dg_compilepsf(        pBHarrayhead,        pxmmslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        if ((pimmediatetarget->immediatesize != 0) &&            (pimmediatetarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromrname);            return;        }    }}const char* dg_forthvcvtsd2sicommaname = "VCVTSD2SI,";void dg_forthvcvtsd2sicomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromr (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x2D, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x1A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtsd2sicommaname);        return;    }}const char* dg_forthvcvtss2sicommaname = "VCVTSS2SI,";void dg_forthvcvtss2sicomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromr (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x2D, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x1A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtss2sicommaname);        return;    }}const char* dg_forthvcvttsd2sicommaname = "VCVTTSD2SI,";void dg_forthvcvttsd2sicomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromr (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x2C, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x1A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvttsd2sicommaname);        return;    }}const char* dg_forthvcvttss2sicommaname = "VCVTTSS2SI,";void dg_forthvcvttss2sicomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromr (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x2C, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x1A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvttss2sicommaname);        return;    }}const char* dg_forthvpextrw2commaname = "VPEXTRW2,";void dg_forthvpextrw2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromr (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xC5, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        2, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x4A); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpextrw2commaname);        return;    }}const char* dg_forthvpinsrbcommaname = "VPINSRB,";void dg_forthvpinsrbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x20, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        1, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x02); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpinsrbcommaname);        return;    }}const char* dg_forthvpinsrdcommaname = "VPINSRD,";void dg_forthvpinsrdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x22, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        4, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x02); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpinsrdcommaname);        return;    }}const char* dg_forthvpinsrqcommaname = "VPINSRQ,";void dg_forthvpinsrqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x22, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        8, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x02); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpinsrqcommaname);        return;    }}const char* dg_forthvpinsrwcommaname = "VPINSRW,";void dg_forthvpinsrwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0xC4, // morxmmsourceopcodebyte,        (UINT64)-1, // morxmmdestinationopcodebyte,        2, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x02); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpinsrwcommaname);        return;    }}const char* dg_forthvpmovmskbcommaname = "VPMOVMSKB,";void dg_forthvpmovmskbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0xD7, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x58); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovmskbcommaname);        return;    }}const char* dg_forthvmovmskpdcommaname = "VMOVMSKPD,";void dg_forthvmovmskpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x50, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x58); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovmskpdcommaname);        return;    }}const char* dg_forthvmovmskpscommaname = "VMOVMSKPS,";void dg_forthvmovmskpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morrxmmtofromxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        (UINT64)-1, // morxmmsourceopcodebyte,        0x50, // morxmmdestinationopcodebyte,        0, // memtargetsize,   // if 0 then mem target size is specified and is either 32BIT or 64BIT        0x58); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovmskpscommaname);        return;    }}const char* dg_pullandcompilevexn8morxmmxmmtofromxmm2name = "dg_pullandcompilevexn8morxmmxmmtofromxmm2";void dg_pullandcompilevexn8morxmmxmmtofromxmm2 (    Bufferhandle* pBHarrayhead,    UINT64 morxmmsourcesimdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 morxmmsourceleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morxmmsourcerexdotw,    UINT64 morxmmsourceopcodebyte,    UINT64 morxmmdestinationsimdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 morxmmdestinationleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 morxmmdestinationrexdotw,    UINT64 morxmmdestinationopcodebyte,    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only)                            // bit 7 = 1 immediate target can be xmm reg but gets converted to immediate{    dg_Sibformatter firsttarget;    dg_Sibformatter secondsourcetarget;    dg_Sibformatter thirdtarget;    dg_Sibformatter immediatetarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondsourcetarget);    dg_initSibformatter(&thirdtarget);    dg_initSibformatter(&immediatetarget);         dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pimmediatetarget = &immediatetarget;    dg_Sibformatter* psecondsourcetarget = &secondsourcetarget;        dg_Sibformatter* pxmmslashmtarget = &thirdtarget;    dg_Sibformatter* pxmmtarget = &firsttarget;        UINT64 sourcetargettype;    UINT64 secondsourcetargettype;    UINT64 destinationtargettype;    UINT64 immediatetargettype;        UINT64 xmmslashmtargettype;    UINT64 xmmtargettype;            UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ((disallowedmodes & 8) != 8)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &secondsourcetarget); // top on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                secondsourcetargettype = dg_gettargettype(            pBHarrayhead,            &secondsourcetarget); // second on stack if used                    if (secondsourcetargettype != dg_targettypexmmreg)        {            dg_pusherror(pBHarrayhead, (const char*)"second srouce target must be an xmm/ymm register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }    }    else    {        secondsourcetarget.basereg = 0;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        dg_pulloneaddressingmode(            pBHarrayhead,            &immediatetarget); // fourth on stack if secondsource is used otherwise third on stack                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                immediatetargettype = dg_gettargettype(            pBHarrayhead,            pimmediatetarget);                    if ((disallowedmodes & 0x80) != 0x80)        {            if (immediatetargettype != dg_targettypeimmediate)            {                dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);                return;            }        }        else         {            if (immediatetargettype == dg_targettypexmmreg)            {                immediatetarget.immediatevalue = (immediatetarget.basereg & 0x0f) << 4;                immediatetarget.immediatesize = 1;            }            else             {                 if (immediatetargettype != dg_targettypeimmediate)                {                       dg_pusherror(pBHarrayhead, (const char*)"first target pushed must be immediate or an xmm register");                    dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);                    return;                }            }        }    }        if ( (firsttarget.direction != 0) ||         (secondsourcetarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondsourcetarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse != FORTH_FALSE)    {        pdestinationtarget = &thirdtarget;        psourcetarget = &firsttarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);            if ((destinationtargettype != dg_targettypemem) &&        (destinationtargettype != dg_targettypexmmreg))    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be an xmm/ymm register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ((sourcetargettype != dg_targettypexmmreg) &&        (sourcetargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be an xmm/ymm register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ((sourcetargettype == dg_targettypemem) &&        (destinationtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"both source and destination target can not be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        // third target  first target  direction  (source) (destination)  (xmmslashm)  (xmm)   (opcode)    //  memory         xmm          forward    third     first         third        first   mtoxmm    //  xmm            memory       forward    third     first         first        third   xmmtom        //  xmm            memory       reverse    first     third         first        third   mtoxmm    //  memory         xmm          reverse    first     third         third        first   xmmtom        pxmmslashmtarget = psourcetarget;    pxmmtarget = pdestinationtarget;    xmmslashmtargettype = sourcetargettype;    xmmtargettype = destinationtargettype;        if (isreverse == FORTH_FALSE)  // forward opcode goes from morxmm source to xmm destination    {        // if it's forward and source is memory, and there is no opcode byte, then error out        if (morxmmsourceopcodebyte == (UINT64)-1)        {            if (sourcetargettype == dg_targettypemem)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or xmm to xmm not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);                return;            }        }                // if it is forward and the destination is memory then switch to using reverse opcode        //  or if there is no forward opcode then also switch to reverse        if ( (destinationtargettype == dg_targettypemem) ||             (morxmmsourceopcodebyte == (UINT64)-1) )        {            // if there is no reverse opcode then error out            if (morxmmdestinationopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"xmm to memory or xmm not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);                return;            }                        pxmmslashmtarget = pdestinationtarget;            xmmslashmtargettype = destinationtargettype;            pxmmtarget = psourcetarget;            xmmtargettype = sourcetargettype;            isreverse = FORTH_TRUE;        }    }    else    {        // if it's reverse and destination is memory, and there is no opcode byte, then error out        if (morxmmdestinationopcodebyte == (UINT64)-1)        {            if (destinationtargettype == dg_targettypemem)            {                dg_pusherror(pBHarrayhead, (const char*)"xmm to memory or xmm not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);                return;            }        }                // if it is reverse and the source is memory then switch to using forward opcode        //  or if there is no reverse opcode then also switch to using forward.        if ( (sourcetargettype == dg_targettypemem) ||             (morxmmdestinationopcodebyte == (UINT64)-1) )        {            // if there is no forward opcode then error out            if (morxmmsourceopcodebyte == (UINT64)-1)            {                dg_pusherror(pBHarrayhead, (const char*)"memory or xmm to xmm not supported for this instruction (opcode not set)");                dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);                return;            }                        isreverse = FORTH_FALSE;        }        else        {            pxmmslashmtarget = pdestinationtarget;            xmmslashmtargettype = destinationtargettype;            pxmmtarget = psourcetarget;            xmmtargettype = sourcetargettype;        }    }        if ((disallowedmodes & 0x20) == 0x20)    {        if (xmmslashmtargettype != dg_targettypemem)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"m/xmm source target must be memory");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"m/xmm destination target must be memory");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }    }        if ((disallowedmodes & 0x40) == 0x40)    {        if (xmmslashmtargettype != dg_targettypexmmreg)        {            if (isreverse == FORTH_FALSE)            {                dg_pusherror(pBHarrayhead, (const char*)"m/xmm source target must be register");            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"m/xmm destination target must be register");            }            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }    }        if ( ((disallowedmodes & 1) == 1) &&         (pxmmtarget->size == 16) )    {        if (isreverse == FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target can't be an xmm register");        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"source target can't be an xmm register");        }        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ( ((disallowedmodes & 2) == 2) &&         (pxmmtarget->size == 32) )    {        if (isreverse == FORTH_FALSE)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target can't be an ymm register");        }        else        {            dg_pusherror(pBHarrayhead, (const char*)"source target can't be an ymm register");        }        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ( ((disallowedmodes & 4) == 4) &&         (sourcetargettype == dg_targettypexmmreg) &&         (destinationtargettype == dg_targettypexmmreg) &&         (psourcetarget->size != pdestinationtarget->size) )    {        dg_pusherror(pBHarrayhead, (const char*)"destination and source register must be the same size");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }            // ignoring second source reg size....        pxmmslashmtarget->targetreg = pxmmtarget->basereg;    pxmmslashmtarget->secondsourcereg = secondsourcetarget.basereg;        // going to ignore xmmslashm target size just use xmm size    pxmmslashmtarget->size = pxmmtarget->size;        if ((disallowedmodes & 0x10) != 0x10)    {        // dg_formatpsf needs this for pc relative calculations        pxmmslashmtarget->immediatesize = 1;    }        dg_formatpsf(        pBHarrayhead,        pxmmslashmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if (isreverse == FORTH_FALSE)    {        if (morxmmsourceopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no forward opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                // compilevex figures out size from psf->size        dg_compilevex (            pBHarrayhead,            pxmmslashmtarget,            addresssize,            morxmmsourcesimdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2            morxmmsourceleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A            morxmmsourcerexdotw,            usethreebytevex);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmsourceopcodebyte), // assumes little endian            1);    }    else    {        if (morxmmdestinationopcodebyte == (UINT64)-1)        {            dg_pusherror(pBHarrayhead, (const char*)"no reverse opcode set");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                // compilevex figures out size from psf->size        dg_compilevex (            pBHarrayhead,            pxmmslashmtarget,            addresssize,            morxmmdestinationsimdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2            morxmmdestinationleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A            morxmmdestinationrexdotw,            usethreebytevex);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmdestinationopcodebyte), // assumes little endian            1);    }            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        dg_compilepsf(        pBHarrayhead,        pxmmslashmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);        return;    }        if ((disallowedmodes & 0x10) != 0x10)    {        if ((pimmediatetarget->immediatesize != 0) &&            (pimmediatetarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8morxmmxmmtofromxmm2name);            return;        }    }}const char* dg_pullandcompilevexn8morxmmxmmtofromxmmname = "dg_pullandcompilevexn8morxmmxmmtofromxmm";void dg_pullandcompilevexn8morxmmxmmtofromxmm (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 rexdotw,    UINT64 morxmmsourceopcodebyte,    UINT64 morxmmdestinationopcodebyte,    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_pullandcompilevexn8morxmmxmmtofromxmm2 (        pBHarrayhead,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        morxmmsourceopcodebyte,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        morxmmdestinationopcodebyte,        disallowedmodes); // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only)                            // bit 7 = 1 immediate target can be xmm reg but gets converted to immediate}const char* dg_forthvextractf128commaname = "VEXTRACTF128,";void dg_forthvextractf128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }                                       dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x19, // morxmmdestinationopcodebyte,        0x09); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                           // bit 1 = 1 no ymm forward destination or reverse source                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target                           // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                           // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvextractf128commaname);        return;    }}const char* dg_forthvextracti128commaname = "VEXTRACTI128,";void dg_forthvextracti128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x39, // morxmmdestinationopcodebyte,        0x09); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                               // bit 1 = 1 no ymm forward destination or reverse source                               // bit 2 = 1 source and dest regs can't be different sizes                               // bit 3 = 1 no 2nd source target                               // bit 4 = 1 no immediate target                               // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                               // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvextracti128commaname);        return;    }}const char* dg_forthvmovdqacommaname = "VMOVDQA,";void dg_forthvmovdqacomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x6F, // morxmmsourceopcodebyte,        0x7F, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovdqacommaname);        return;    }}const char* dg_forthvmovdqucommaname = "VMOVDQU,";void dg_forthvmovdqucomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x6F, // morxmmsourceopcodebyte,        0x7F, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovdqucommaname);        return;    }}const char* dg_forthvmovqcommaname = "VMOVQ,";void dg_forthvmovqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm2 (        pBHarrayhead,        2, // morxmmsourcesimdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // morxmmsourceleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // morxmmsourcerexdotw,        0x7E, // morxmmsourceopcodebyte,        1, // morxmmdestinationsimdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // morxmmdestinationleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // morxmmdestinationrexdotw,        0xD6, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes);   // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovqcommaname);        return;    }}const char* dg_forthvmovapdcommaname = "VMOVAPD,";void dg_forthvmovapdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x28, // morxmmsourceopcodebyte,        0x29, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovapdcommaname);        return;    }}const char* dg_forthvmovapscommaname = "VMOVAPS,";void dg_forthvmovapscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source        // bit 1 = 1 no ymm forward destination or reverse source        // bit 2 = 1 source and dest regs can't be different sizes        // bit 3 = 1 no 2nd source target        // bit 4 = 1 no immediate target        // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg        // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovapscommaname);        return;    }}const char* dg_forthvmovupdcommaname = "VMOVUPD,";void dg_forthvmovupdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovupdcommaname);        return;    }}const char* dg_forthvmovupscommaname = "VMOVUPS,";void dg_forthvmovupscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source        // bit 1 = 1 no ymm forward destination or reverse source        // bit 2 = 1 source and dest regs can't be different sizes        // bit 3 = 1 no 2nd source target        // bit 4 = 1 no immediate target        // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg        // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovupscommaname);        return;    }}const char* dg_forthvmaskmovpscommaname = "VMASKMOVPS,";void dg_forthvmaskmovpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x2C, // morxmmsourceopcodebyte,        0x2E, // morxmmdestinationopcodebyte,        0x34); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source        // bit 1 = 1 no ymm forward destination or reverse source        // bit 2 = 1 source and dest regs can't be different sizes        // bit 3 = 1 no 2nd source target        // bit 4 = 1 no immediate target        // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg        // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaskmovpscommaname);        return;    }}const char* dg_forthvmaskmovpdcommaname = "VMASKMOVPD,";void dg_forthvmaskmovpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x2D, // morxmmsourceopcodebyte,        0x2F, // morxmmdestinationopcodebyte,        0x34); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source        // bit 1 = 1 no ymm forward destination or reverse source        // bit 2 = 1 source and dest regs can't be different sizes        // bit 3 = 1 no 2nd source target        // bit 4 = 1 no immediate target        // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg        // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaskmovpdcommaname);        return;    }}const char* dg_forthvpmaskmovdcommaname = "VPMASKMOVD,";void dg_forthvpmaskmovdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x8C, // morxmmsourceopcodebyte,        0x8E, // morxmmdestinationopcodebyte,        0x34); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source        // bit 1 = 1 no ymm forward destination or reverse source        // bit 2 = 1 source and dest regs can't be different sizes        // bit 3 = 1 no 2nd source target        // bit 4 = 1 no immediate target        // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg        // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaskmovdcommaname);        return;    }}const char* dg_forthvpmaskmovqcommaname = "VPMASKMOVQ,";void dg_forthvpmaskmovqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x8C, // morxmmsourceopcodebyte,        0x8E, // morxmmdestinationopcodebyte,        0x34); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source        // bit 1 = 1 no ymm forward destination or reverse source        // bit 2 = 1 source and dest regs can't be different sizes        // bit 3 = 1 no 2nd source target        // bit 4 = 1 no immediate target        // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg        // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaskmovqcommaname);        return;    }}const char* dg_forthvmovntdqcommaname = "VMOVNTDQ,";void dg_forthvmovntdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0xE7, // morxmmdestinationopcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovntdqcommaname);        return;    }}const char* dg_forthvmovntpdcommaname = "VMOVNTPD,";void dg_forthvmovntpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x2B, // morxmmdestinationopcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovntpdcommaname);        return;    }}const char* dg_forthvmovntpscommaname = "VMOVNTPS,";void dg_forthvmovntpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x2B, // morxmmdestinationopcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovntpscommaname);        return;    }}const char* dg_forthvmovhpd2commaname = "VMOVHPD2,";void dg_forthvmovhpd2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x17, // morxmmdestinationopcodebyte,        0x3E); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovhpd2commaname);        return;    }}const char* dg_forthvmovhps2commaname = "VMOVHPS2,";void dg_forthvmovhps2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x17, // morxmmdestinationopcodebyte,        0x3E); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovhps2commaname);        return;    }}const char* dg_forthvmovlpd2commaname = "VMOVLPD2,";void dg_forthvmovlpd2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x13, // morxmmdestinationopcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovlpd2commaname);        return;    }}const char* dg_forthvmovlps2commaname = "VMOVLPS2,";void dg_forthvmovlps2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x13, // morxmmdestinationopcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovlps2commaname);        return;    }}const char* dg_forthvmovsd2commaname = "VMOVSD2,";void dg_forthvmovsd2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x3E); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsd2commaname);        return;    }}const char* dg_forthvmovsdcommaname = "VMOVSD,";void dg_forthvmovsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x56); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsdcommaname);        return;    }}const char* dg_forthvmovss2commaname = "VMOVSS2,";void dg_forthvmovss2comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x3E); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovss2commaname);        return;    }}const char* dg_forthvmovsscommaname = "VMOVSS,";void dg_forthvmovsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x10, // morxmmsourceopcodebyte,        0x11, // morxmmdestinationopcodebyte,        0x56); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsscommaname);        return;    }}const char* dg_forthvcvtps2phcommaname = "VCVTPS2PH,";void dg_forthvcvtps2phcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtofromxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        (UINT64)-1, // morxmmsourceopcodebyte,        0x1D, // morxmmdestinationopcodebyte,        0x08); // disallowedmodes) // bit 0 = 1 no xmm forward destination or reverse source                                   // bit 1 = 1 no ymm forward destination or reverse source                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 xmm/m target (forward source or reverse destination) can't be reg                                   // bit 6 = 1 xmm/m target (forward source or reverse destination) can't be mem            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtps2phcommaname);        return;    }}const char* dg_pullandcompilevexshiftopname = "dg_pullandcompilevexshiftop";void dg_pullandcompilevexshiftop (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 rexdotw,    UINT64 immediatecountopcodebyte, // if > 255 then morxmm count not available    UINT64 immediatecountopcodeextension,    UINT64 morxmmcountopcodebyte,  // if > 255 then morxmm count not available    UINT64 disallowedmodes)        // bit 0 not used                                   // bit 1 = 1 no ymm destination                                   // bit 2 not used                                   // bit 3 not used                                   // bit 4 not used                                   // bit 5 not used                                   // bit 6 not used{    dg_Sibformatter firsttarget;         // default destination    dg_Sibformatter secondtarget;        // default source (morxmm if immediate count, xmm if not)    dg_Sibformatter thirdtarget;         // immediate or morxmm count        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);         dg_Sibformatter* psourcetarget = &secondtarget;    dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* pcounttarget = &thirdtarget;  // immediate or morxmm count target        dg_Sibformatter* pmorxmmtarget = &thirdtarget;  // if immediate, source target is morxmm        UINT64 sourcetargettype;    UINT64 destinationtargettype;    UINT64 counttargettype;        UINT64 addresssize;        UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack if secondsource is used otherwise second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondtarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse != FORTH_FALSE)    {        pdestinationtarget = &secondtarget;        psourcetarget = &firsttarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);            counttargettype = dg_gettargettype(        pBHarrayhead,        pcounttarget);                    if ((counttargettype != dg_targettypeimmediate) &&        (counttargettype != dg_targettypexmmreg) &&        (counttargettype != dg_targettypemem))           {        dg_pusherror(pBHarrayhead, (const char*)"count target must be immediate, xmm/ymm register, or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        // source must by morxmm, dest must be xmm    if (destinationtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be an xmm/ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        if (sourcetargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be an xmm/ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }            if (counttargettype == dg_targettypeimmediate)    {        if (immediatecountopcodebyte > 255)        {            dg_pusherror(pBHarrayhead, (const char*)"immediate count target not supported");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);            return;        }                pmorxmmtarget = psourcetarget;        pmorxmmtarget->targetreg = immediatecountopcodeextension;        pmorxmmtarget->secondsourcereg = pdestinationtarget->basereg;    }    else    {        if (morxmmcountopcodebyte > 255)        {            dg_pusherror(pBHarrayhead, (const char*)"morxmm count target not supported");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);            return;        }                // pmorxmmtarget is already set, and count is the base reg        pmorxmmtarget->targetreg = pdestinationtarget->basereg;        pmorxmmtarget->secondsourcereg = psourcetarget->basereg;    }        if (((disallowedmodes & 2) == 2) &&        (psourcetarget->size == 32))    {        dg_pusherror(pBHarrayhead, (const char*)"source target can not be a ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        // going to ignore source size just use destination size    pmorxmmtarget->size = pdestinationtarget->size;        if (counttargettype == dg_targettypeimmediate)    {        // dg_formatpsf needs this for pc relative calculations        pmorxmmtarget->immediatesize = 1;    }        dg_formatpsf(        pBHarrayhead,        pmorxmmtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        pmorxmmtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        if (counttargettype == dg_targettypeimmediate)    {        dg_compilesegment(            pBHarrayhead,            (const char*)&(immediatecountopcodebyte), // assumes little endian            1);    }    else    {        dg_compilesegment(            pBHarrayhead,            (const char*)&(morxmmcountopcodebyte), // assumes little endian            1);    }        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        dg_compilepsf(        pBHarrayhead,        pmorxmmtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);        return;    }        if (counttargettype == dg_targettypeimmediate)    {        if ((pcounttarget->immediatesize != 0) &&            (pcounttarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(pcounttarget->immediatevalue), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexshiftopname);            return;        }    }}const char* dg_forthvpslldqcommaname = "VPSLLDQ,";void dg_forthvpslldqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,           // simdprefixcode,          // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,           // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,           //`rexdotw,        0x73,        // immediatecountopcodebyte,        7,           // immediatecountopcodeextension        (UINT64)-1,  // morxmmcountopcodebyte        0);          // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpslldqcommaname);        return;    }}const char* dg_forthvpsllwcommaname = "VPSLLW,";void dg_forthvpsllwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,           // simdprefixcode,          // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,           // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,           //`rexdotw,        0x71,        // immediatecountopcodebyte,        6,           // immediatecountopcodeextension        0xF1,  // morxmmcountopcodebyte        0);          // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsllwcommaname);        return;    }}const char* dg_forthvpslldcommaname = "VPSLLD,";void dg_forthvpslldcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,           // simdprefixcode,          // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,           // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,           //`rexdotw,        0x72,        // immediatecountopcodebyte,        6,           // immediatecountopcodeextension        0xF2,  // morxmmcountopcodebyte        0);          // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpslldcommaname);        return;    }}const char* dg_forthvpsllqcommaname = "VPSLLQ,";void dg_forthvpsllqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,           // simdprefixcode,          // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,           // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,           //`rexdotw,        0x73,        // immediatecountopcodebyte,        6,           // immediatecountopcodeextension        0xF3,  // morxmmcountopcodebyte        0);          // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsllqcommaname);        return;    }}const char* dg_forthvpsrawcommaname = "VPSRAW,";void dg_forthvpsrawcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     //`rexdotw,        0x71,  // immediatecountopcodebyte,        4,     // immediatecountopcodeextension        0xE1,  // morxmmcountopcodebyte        0);    // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrawcommaname);        return;    }}const char* dg_forthvpsradcommaname = "VPSRAD,";void dg_forthvpsradcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     //`rexdotw,        0x72,  // immediatecountopcodebyte,        4,     // immediatecountopcodeextension        0xE2,  // morxmmcountopcodebyte)        0);    // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsradcommaname);        return;    }}const char* dg_forthvpsrldqcommaname = "VPSRLDQ,";void dg_forthvpsrldqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,           // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,           // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,           //`rexdotw,        0x73,        // immediatecountopcodebyte,        3,           // immediatecountopcodeextension        (UINT64)-1,  // morxmmcountopcodebyte        0);          // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrldqcommaname);        return;    }}const char* dg_forthvpsrlwcommaname = "VPSRLW,";void dg_forthvpsrlwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     //`rexdotw,        0x71,  // immediatecountopcodebyte,        2,     // immediatecountopcodeextension        0xD1,  // morxmmcountopcodebyte)        0);    // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrlwcommaname);        return;    }}const char* dg_forthvpsrldcommaname = "VPSRLD,";void dg_forthvpsrldcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     //`rexdotw,        0x72,  // immediatecountopcodebyte,        2,     // immediatecountopcodeextension        0xD2,  // morxmmcountopcodebyte)        0);    // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrldcommaname);        return;    }}const char* dg_forthvpsrlqcommaname = "VPSRLQ,";void dg_forthvpsrlqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexshiftop (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     //`rexdotw,        0x73,  // immediatecountopcodebyte,        2,     // immediatecountopcodeextension        0xD3,  // morxmmcountopcodebyte)        0);    // disallowedmodes            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrlqcommaname);        return;    }}const char* dg_pullandcompilevexn8morxmmxmmtoxmmname = "dg_pullandcompilevexn8morxmmxmmtoxmm";void dg_pullandcompilevexn8morxmmxmmtoxmm (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 rexdotw,    UINT64 opcodebyte,    UINT64 disallowedmodes) // bit 0 = 1 no xmm destination                            // bit 1 = 1 no ymm destination                            // bit 2 = 1 source and dest regs can't be different sizes                            // bit 3 = 1 no 2nd source target                            // bit 4 = 1 no immediate target                            // bit 5 = 1 no register first source (mem only)                            // bit 6 = 1 no memory first source (reg only){    dg_pullandcompilevexn8morxmmxmmtofromxmm2 (        pBHarrayhead,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        opcodebyte, // morxmmsourceopcodebyte,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        (UINT64)-1,        disallowedmodes);}const char* dg_forthvaddpdcommaname = "VADDPD,";void dg_forthvaddpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x58, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaddpdcommaname);        return;    }}const char* dg_forthvaddpscommaname = "VADDPS,";void dg_forthvaddpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x58, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaddpscommaname);        return;    }}const char* dg_forthvaddsdcommaname = "VADDSD,";void dg_forthvaddsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x58, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaddsdcommaname);        return;    }}const char* dg_forthvaddsscommaname = "VADDSS,";void dg_forthvaddsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x58, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaddsscommaname);        return;    }}const char* dg_forthvaddsubpdcommaname = "VADDSUBPD,";void dg_forthvaddsubpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xD0, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaddsubpdcommaname);        return;    }}const char* dg_forthvaddsubpscommaname = "VADDSUBPS,";void dg_forthvaddsubpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xD0, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaddsubpscommaname);        return;    }}const char* dg_forthvaesdeccommaname = "VAESDEC,";void dg_forthvaesdeccomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xDE, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaesdeccommaname);        return;    }}const char* dg_forthvaesdeclastcommaname = "VAESDECLAST,";void dg_forthvaesdeclastcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xDF, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaesdeclastcommaname);        return;    }}const char* dg_forthvaesenccommaname = "VAESENC,";void dg_forthvaesenccomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xDC, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaesenccommaname);        return;    }}const char* dg_forthvaesenclastcommaname = "VAESENCLAST,";void dg_forthvaesenclastcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xDD, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaesenclastcommaname);        return;    }}const char* dg_forthvaesimccommaname = "VAESIMC,";void dg_forthvaesimccomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xDB, // opcodebyte,        0x1E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaesimccommaname);        return;    }}const char* dg_forthvaeskeygenassistcommaname = "VAESKEYGENASSIST,";void dg_forthvaeskeygenassistcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xDF, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvaeskeygenassistcommaname);        return;    }}const char* dg_forthvandpdcommaname = "VANDPD,";void dg_forthvandpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x54, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvandpdcommaname);        return;    }}const char* dg_forthvandpscommaname = "VANDPS,";void dg_forthvandpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x54, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvandpscommaname);        return;    }}const char* dg_forthvandnpdcommaname = "VANDNPD,";void dg_forthvandnpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x55, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvandnpdcommaname);        return;    }}const char* dg_forthvandnpscommaname = "VANDNPS,";void dg_forthvandnpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x55, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvandnpscommaname);        return;    }}const char* dg_forthvblendpdcommaname = "VBLENDPD,";void dg_forthvblendpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x0D, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvblendpdcommaname);        return;    }}const char* dg_forthvblendpscommaname = "VBLENDPS,";void dg_forthvblendpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x0C, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvblendpscommaname);        return;    }}const char* dg_forthvblendvpdcommaname = "VBLENDVPD,";void dg_forthvblendvpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x4B, // opcodebyte,        0x84); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 7 = 1 immediate target can be xmm reg but gets converted to immediate            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvblendvpdcommaname);        return;    }}const char* dg_forthvblendvpscommaname = "VBLENDVPS,";void dg_forthvblendvpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x4A, // opcodebyte,        0x84); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 7 = 1 immediate target can be xmm reg but gets converted to immediate            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvblendvpscommaname);        return;    }}const char* dg_forthvcmppdcommaname = "VCMPPD,";void dg_forthvcmppdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xC2, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcmppdcommaname);        return;    }}const char* dg_forthvcmppscommaname = "VCMPPS,";void dg_forthvcmppscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xC2, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcmppscommaname);        return;    }}const char* dg_forthvcmpsdcommaname = "VCMPSD,";void dg_forthvcmpsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xC2, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcmpsdcommaname);        return;    }}const char* dg_forthvcmpsscommaname = "VCMPSS,";void dg_forthvcmpsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xC2, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcmpsscommaname);        return;    }}const char* dg_forthvcomisdcommaname = "VCOMISD,";void dg_forthvcomisdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x2F, // opcodebyte,        0x1E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcomisdcommaname);        return;    }}const char* dg_forthvcomisscommaname = "VCOMISS,";void dg_forthvcomisscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x2F, // opcodebyte,        0x1E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcomisscommaname);        return;    }}const char* dg_forthvcvtdq2pdcommaname = "VCVTDQ2PD,";void dg_forthvcvtdq2pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xE6, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtdq2pdcommaname);        return;    }}const char* dg_forthvcvtdq2pscommaname = "VCVTDQ2PS,";void dg_forthvcvtdq2pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5B, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtdq2pscommaname);        return;    }}const char* dg_forthvcvtpd2dqcommaname = "VCVTPD2DQ,";void dg_forthvcvtpd2dqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xE6, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtpd2dqcommaname);        return;    }}const char* dg_forthvcvtpd2pscommaname = "VCVTPD2PS,";void dg_forthvcvtpd2pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5A, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtpd2pscommaname);        return;    }}const char* dg_forthvcvtps2dqcommaname = "VCVTPS2DQ,";void dg_forthvcvtps2dqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5B, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtps2dqcommaname);        return;    }}const char* dg_forthvcvtps2pdcommaname = "VCVTPS2PD,";void dg_forthvcvtps2pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5A, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtps2pdcommaname);        return;    }}const char* dg_forthvcvtsd2sscommaname = "VCVTSD2SS,";void dg_forthvcvtsd2sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5A, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtsd2sscommaname);        return;    }}const char* dg_forthvcvtss2sdcommaname = "VCVTSS2SD,";void dg_forthvcvtss2sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5A, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtss2sdcommaname);        return;    }}const char* dg_forthvcvttpd2dqcommaname = "VCVTTPD2DQ,";void dg_forthvcvttpd2dqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xE6, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvttpd2dqcommaname);        return;    }}const char* dg_forthvcvttps2dqcommaname = "VCVTTPS2DQ,";void dg_forthvcvttps2dqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5B, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvttps2dqcommaname);        return;    }}const char* dg_forthvdivpdcommaname = "VDIVPD,";void dg_forthvdivpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5E, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvdivpdcommaname);        return;    }}const char* dg_forthvdivpscommaname = "VDIVPS,";void dg_forthvdivpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5E, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvdivpscommaname);        return;    }}const char* dg_forthvdivsdcommaname = "VDIVSD,";void dg_forthvdivsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5E, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvdivsdcommaname);        return;    }}const char* dg_forthvdivsscommaname = "VDIVSS,";void dg_forthvdivsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x5E, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvdivsscommaname);        return;    }}const char* dg_forthvdppdcommaname = "VDPPD,";void dg_forthvdppdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x41, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvdppdcommaname);        return;    }}const char* dg_forthvdppscommaname = "VDPPS,";void dg_forthvdppscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x40, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvdppscommaname);        return;    }}const char* dg_forthvhaddpdcommaname = "VHADDPD,";void dg_forthvhaddpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x7C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvhaddpdcommaname);        return;    }}const char* dg_forthvhaddpscommaname = "VHADDPS,";void dg_forthvhaddpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x7C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvhaddpdcommaname);        return;    }}const char* dg_forthvhsubpdcommaname = "VHSUBPD,";void dg_forthvhsubpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x7D, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvhsubpdcommaname);        return;    }}const char* dg_forthvhsubpscommaname = "VHSUBPS,";void dg_forthvhsubpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x7D, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvhsubpscommaname);        return;    }}const char* dg_forthvinsertpscommaname = "VINSERTPS,";void dg_forthvinsertpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0x21, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvinsertpscommaname);        return;    }}const char* dg_forthvlddqucommaname = "VLDDQU,";void dg_forthvlddqucomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,  // ignored.... don't care...        0xF0, // opcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvlddqucommaname);        return;    }}const char* dg_forthvmaskmovdqucommaname = "VMASKMOVDQU,";void dg_forthvmaskmovdqucomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xF7, // opcodebyte,        0x5E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaskmovdqucommaname);        return;    }}const char* dg_forthvmaxpdcommaname = "VMAXPD,";void dg_forthvmaxpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5F, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaxpdcommaname);        return;    }}const char* dg_forthvmaxpscommaname = "VMAXPS,";void dg_forthvmaxpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5F, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaxpscommaname);        return;    }}const char* dg_forthvmaxsdcommaname = "VMAXSD,";void dg_forthvmaxsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5F, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaxsdcommaname);        return;    }}const char* dg_forthvmaxsscommaname = "VMAXSS,";void dg_forthvmaxsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5F, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmaxsscommaname);        return;    }}const char* dg_forthvminpdcommaname = "VMINPD,";void dg_forthvminpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5D, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvminpdcommaname);        return;    }}const char* dg_forthvminpscommaname = "VMINPS,";void dg_forthvminpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5D, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvminpscommaname);        return;    }}const char* dg_forthvminsdcommaname = "VMINSD,";void dg_forthvminsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5D, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvminsdcommaname);        return;    }}const char* dg_forthvminsscommaname = "VMINSS,";void dg_forthvminsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5D, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvminsscommaname);        return;    }}const char* dg_forthvmovddupcommaname = "VMOVDDUP,";void dg_forthvmovddupcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x12, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovddupcommaname);        return;    }}const char* dg_forthvmovhlpscommaname = "VMOVHLPS,";void dg_forthvmovhlpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x12, // opcodebyte,        0x52); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory             if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovhlpscommaname);        return;    }}const char* dg_forthvmovhpdcommaname = "VMOVHPD,";void dg_forthvmovhpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x16, // opcodebyte,        0x36); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovhpdcommaname);        return;    }}const char* dg_forthvmovhpscommaname = "VMOVHPS,";void dg_forthvmovhpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x16, // opcodebyte,        0x36); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovhpscommaname);        return;    }}const char* dg_forthvmovlhpscommaname = "VMOVLHPS,";void dg_forthvmovlhpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x16, // opcodebyte,        0x56); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovlhpscommaname);        return;    }}const char* dg_forthvmovlpdcommaname = "VMOVLPD,";void dg_forthvmovlpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x12, // opcodebyte,        0x36); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovlpdcommaname);        return;    }}const char* dg_forthvmovlpscommaname = "VMOVLPS,";void dg_forthvmovlpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x12, // opcodebyte,        0x36); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovlpscommaname);        return;    }}const char* dg_forthvmovntdqacommaname = "VMOVNTDQA,";void dg_forthvmovntdqacomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x2A, // opcodebyte,        0x3C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovntdqacommaname);        return;    }}const char* dg_forthvmovshdupcommaname = "VMOVSHDUP,";void dg_forthvmovshdupcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x16, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovshdupcommaname);        return;    }}const char* dg_forthvmovsldupcommaname = "VMOVSLDUP,";void dg_forthvmovsldupcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x12, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsldupcommaname);        return;    }}const char* dg_forthvmpsadbwcommaname = "VMPSADBW,";void dg_forthvmpsadbwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x42, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmpsadbwcommaname);        return;    }}const char* dg_forthvmulpdcommaname = "VMULPD,";void dg_forthvmulpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x59, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmulpdcommaname);        return;    }}const char* dg_forthvmulpscommaname = "VMULPS,";void dg_forthvmulpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x59, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmulpscommaname);        return;    }}const char* dg_forthvmulsdcommaname = "VMULSD,";void dg_forthvmulsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x59, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmulsdcommaname);        return;    }}const char* dg_forthvmulsscommaname = "VMULSS,";void dg_forthvmulsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x59, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmulsscommaname);        return;    }}const char* dg_forthvorpdcommaname = "VORPD,";void dg_forthvorpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x56, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvorpdcommaname);        return;    }}const char* dg_forthvorpscommaname = "VORPS,";void dg_forthvorpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x56, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvorpscommaname);        return;    }}const char* dg_forthvpabsbcommaname = "VPABSB,";void dg_forthvpabsbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x1C, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpabsbcommaname);        return;    }}const char* dg_forthvpabswcommaname = "VPABSW,";void dg_forthvpabswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x1D, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpabswcommaname);        return;    }}const char* dg_forthvpabsdcommaname = "VPABSD,";void dg_forthvpabsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x1E, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpabsdcommaname);        return;    }}const char* dg_forthvpacksswbcommaname = "VPACKSSWB,";void dg_forthvpacksswbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x63, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpacksswbcommaname);        return;    }}const char* dg_forthvpackssdwcommaname = "VPACKSSDW,";void dg_forthvpackssdwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x6B, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpackssdwcommaname);        return;    }}const char* dg_forthvpackusdwcommaname = "VPACKUSDW,";void dg_forthvpackusdwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x2B, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpackusdwcommaname);        return;    }}const char* dg_forthvpackuswbcommaname = "VPACKUSWB,";void dg_forthvpackuswbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x67, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpackuswbcommaname);        return;    }}const char* dg_forthvpaddbcommaname = "VPADDB,";void dg_forthvpaddbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xFC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpaddbcommaname);        return;    }}const char* dg_forthvpaddwcommaname = "VPADDW,";void dg_forthvpaddwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xFD, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpaddwcommaname);        return;    }}const char* dg_forthvpadddcommaname = "VPADDD,";void dg_forthvpadddcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xFE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpadddcommaname);        return;    }}const char* dg_forthvpaddqcommaname = "VPADDQ,";void dg_forthvpaddqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xD4, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpaddqcommaname);        return;    }}const char* dg_forthvpaddsbcommaname = "VPADDSB,";void dg_forthvpaddsbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xEC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpaddsbcommaname);        return;    }}const char* dg_forthvpaddswcommaname = "VPADDSW,";void dg_forthvpaddswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xED, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpaddswcommaname);        return;    }}const char* dg_forthvpaddusbcommaname = "VPADDUSB,";void dg_forthvpaddusbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xDC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpaddusbcommaname);        return;    }}const char* dg_forthvpadduswcommaname = "VPADDUSW,";void dg_forthvpadduswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xDD, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpadduswcommaname);        return;    }}const char* dg_forthvpalignrcommaname = "VPALIGNR,";void dg_forthvpalignrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x0F, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpalignrcommaname);        return;    }}const char* dg_forthvpandcommaname = "VPAND,";void dg_forthvpandcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xDB, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpandcommaname);        return;    }}const char* dg_forthvpandncommaname = "VPANDN,";void dg_forthvpandncomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xDF, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpandncommaname);        return;    }}const char* dg_forthvpavgbcommaname = "VPAVGB,";void dg_forthvpavgbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xE0, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpavgbcommaname);        return;    }}const char* dg_forthvpavgwcommaname = "VPAVGW,";void dg_forthvpavgwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xE3, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpavgwcommaname);        return;    }}const char* dg_forthvpblendvbcommaname = "VPBLENDVB,";void dg_forthvpblendvbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x4C, // opcodebyte,        0x84); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory                                   // bit 7 = 1 immediate target can be xmm reg but gets converted to immediate            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpblendvbcommaname);        return;    }}const char* dg_forthvpblendwcommaname = "VPBLENDW,";void dg_forthvpblendwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x0E, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpblendwcommaname);        return;    }}const char* dg_forthvpclmulqdqcommaname = "VPCLMULQDQ,";void dg_forthvpclmulqdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x44, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpclmulqdqcommaname);        return;    }}const char* dg_forthvpcmpeqbcommaname = "VPCMPEQB,";void dg_forthvpcmpeqbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x74, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpeqbcommaname);        return;    }}const char* dg_forthvpcmpeqwcommaname = "VPCMPEQW,";void dg_forthvpcmpeqwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x75, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpeqwcommaname);        return;    }}const char* dg_forthvpcmpeqdcommaname = "VPCMPEQD,";void dg_forthvpcmpeqdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x76, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpeqdcommaname);        return;    }}const char* dg_forthvpcmpeqqcommaname = "VPCMPEQQ,";void dg_forthvpcmpeqqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x29, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpeqqcommaname);        return;    }}const char* dg_forthvpcmpestricommaname = "VPCMPESTRI,";void dg_forthvpcmpestricomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x61, // opcodebyte,        0x0E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpestricommaname);        return;    }}const char* dg_forthvpcmpestrmcommaname = "VPCMPESTRM,";void dg_forthvpcmpestrmcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x60, // opcodebyte,        0x0E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpestrmcommaname);        return;    }}const char* dg_forthvpcmpgtbcommaname = "VPCMPGTB,";void dg_forthvpcmpgtbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x64, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpgtbcommaname);        return;    }}const char* dg_forthvpcmpgtwcommaname = "VPCMPGTW,";void dg_forthvpcmpgtwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x65, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpgtwcommaname);        return;    }}const char* dg_forthvpcmpgtdcommaname = "VPCMPGTD,";void dg_forthvpcmpgtdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x66, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpgtdcommaname);        return;    }}const char* dg_forthvpcmpgtqcommaname = "VPCMPGTQ,";void dg_forthvpcmpgtqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x37, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpgtqcommaname);        return;    }}const char* dg_forthvpcmpistricommaname = "VPCMPISTRI,";void dg_forthvpcmpistricomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x63, // opcodebyte,        0x0E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpistricommaname);        return;    }}const char* dg_forthvpcmpistrmcommaname = "VPCMPISTRM,";void dg_forthvpcmpistrmcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x62, // opcodebyte,        0x0E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpcmpistrmcommaname);        return;    }}const char* dg_forthvphadddcommaname = "VPHADDD,";void dg_forthvphadddcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x02, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphadddcommaname);        return;    }}const char* dg_forthvphaddswcommaname = "VPHADDSW,";void dg_forthvphaddswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x03, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphaddswcommaname);        return;    }}const char* dg_forthvphaddwcommaname = "VPHADDW,";void dg_forthvphaddwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x01, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphaddwcommaname);        return;    }}const char* dg_forthvphminposuwcommaname = "VPHMINPOSUW,";void dg_forthvphminposuwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x41, // opcodebyte,        0x1E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphminposuwcommaname);        return;    }}const char* dg_forthvphsubwcommaname = "VPHSUBW,";void dg_forthvphsubwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x05, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphsubwcommaname);        return;    }}const char* dg_forthvphsubdcommaname = "VPHSUBD,";void dg_forthvphsubdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x06, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphsubdcommaname);        return;    }}const char* dg_forthvphsubswcommaname = "VPHSUBSW,";void dg_forthvphsubswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x07, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvphsubswcommaname);        return;    }}/*const char* dg_forthvpinsrbcommaname = "VPINSRB,";void dg_forthvpinsrbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x20, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpinsrbcommaname);        return;    }}*/const char* dg_forthvpmaddubswcommaname = "VPMADDUBSW,";void dg_forthvpmaddubswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x04, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaddubswcommaname);        return;    }}const char* dg_forthvpmaddwdcommaname = "VPMADDWD,";void dg_forthvpmaddwdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xF5, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaddwdcommaname);        return;    }}const char* dg_forthvpmaxsbcommaname = "VPMAXSB,";void dg_forthvpmaxsbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x3C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaxsbcommaname);        return;    }}const char* dg_forthvpmaxsdcommaname = "VPMAXSD,";void dg_forthvpmaxsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x3D, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaxsdcommaname);        return;    }}const char* dg_forthvpmaxswcommaname = "VPMAXSW,";void dg_forthvpmaxswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xEE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaxswcommaname);        return;    }}const char* dg_forthvpmaxubcommaname = "VPMAXUB,";void dg_forthvpmaxubcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xDE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaxubcommaname);        return;    }}const char* dg_forthvpmaxudcommaname = "VPMAXUD,";void dg_forthvpmaxudcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x3F, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaxudcommaname);        return;    }}const char* dg_forthvpmaxuwcommaname = "VPMAXUW,";void dg_forthvpmaxuwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x3E, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmaxuwcommaname);        return;    }}const char* dg_forthvpminsbcommaname = "VPMINSB,";void dg_forthvpminsbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x38, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpminsbcommaname);        return;    }}const char* dg_forthvpminsdcommaname = "VPMINSD,";void dg_forthvpminsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x39, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpminsdcommaname);        return;    }}const char* dg_forthvpminswcommaname = "VPMINSW,";void dg_forthvpminswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xEA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpminswcommaname);        return;    }}const char* dg_forthvpminubcommaname = "VPMINUB,";void dg_forthvpminubcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xDA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpminubcommaname);        return;    }}const char* dg_forthvpminudcommaname = "VPMINUD,";void dg_forthvpminudcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x3B, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpminudcommaname);        return;    }}const char* dg_forthvpminuwcommaname = "VPMINUW,";void dg_forthvpminuwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x3A, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpminuwcommaname);        return;    }}const char* dg_forthvpmovsxbwcommaname = "VPMOVSXBW,";void dg_forthvpmovsxbwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x20, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovsxbwcommaname);        return;    }}const char* dg_forthvpmovsxbdcommaname = "VPMOVSXBD,";void dg_forthvpmovsxbdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x21, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovsxbdcommaname);        return;    }}const char* dg_forthvpmovsxbqcommaname = "VPMOVSXBQ,";void dg_forthvpmovsxbqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x22, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovsxbqcommaname);        return;    }}const char* dg_forthvpmovsxwdcommaname = "VPMOVSXWD,";void dg_forthvpmovsxwdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x23, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovsxwdcommaname);        return;    }}const char* dg_forthvpmovsxwqcommaname = "VPMOVSXWQ,";void dg_forthvpmovsxwqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x24, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovsxwqcommaname);        return;    }}const char* dg_forthvpmovsxdqcommaname = "VPMOVSXDQ,";void dg_forthvpmovsxdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x25, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovsxdqcommaname);        return;    }}const char* dg_forthvpmovzxbwcommaname = "VPMOVZXBW,";void dg_forthvpmovzxbwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x30, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovzxbwcommaname);        return;    }}const char* dg_forthvpmovzxbdcommaname = "VPMOVZXBD,";void dg_forthvpmovzxbdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x31, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovzxbdcommaname);        return;    }}const char* dg_forthvpmovzxbqcommaname = "VPMOVZXBQ,";void dg_forthvpmovzxbqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x32, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovzxbqcommaname);        return;    }}const char* dg_forthvpmovzxwdcommaname = "VPMOVZXWD,";void dg_forthvpmovzxwdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x33, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovzxwdcommaname);        return;    }}const char* dg_forthvpmovzxwqcommaname = "VPMOVZXWQ,";void dg_forthvpmovzxwqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x34, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovzxwqcommaname);        return;    }}const char* dg_forthvpmovzxdqcommaname = "VPMOVZXDQ,";void dg_forthvpmovzxdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x35, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmovzxdqcommaname);        return;    }}const char* dg_forthvpmuldqcommaname = "VPMULDQ,";void dg_forthvpmuldqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x28, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmuldqcommaname);        return;    }}const char* dg_forthvpmulhrswcommaname = "VPMULHRSW,";void dg_forthvpmulhrswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x0B, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmulhrswcommaname);        return;    }}const char* dg_forthvpmulhuwcommaname = "VPMULHUW,";void dg_forthvpmulhuwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xE4, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmulhuwcommaname);        return;    }}const char* dg_forthvpmulhwcommaname = "VPMULHW,";void dg_forthvpmulhwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xE5, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmulhwcommaname);        return;    }}const char* dg_forthvpmulldcommaname = "VPMULLD,";void dg_forthvpmulldcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x40, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmulldcommaname);        return;    }}const char* dg_forthvpmullwcommaname = "VPMULLW,";void dg_forthvpmullwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xD5, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmullwcommaname);        return;    }}const char* dg_forthvpmuludqcommaname = "VPMULUDQ,";void dg_forthvpmuludqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xF4, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpmuludqcommaname);        return;    }}const char* dg_forthvporcommaname = "VPOR,";void dg_forthvporcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xEB, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvporcommaname);        return;    }}const char* dg_forthvpsadbwcommaname = "VPSADBW,";void dg_forthvpsadbwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xF6, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsadbwcommaname);        return;    }}const char* dg_forthvpshufbcommaname = "VPSHUFB,";void dg_forthvpshufbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x00, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpshufbcommaname);        return;    }}const char* dg_forthvpshufdcommaname = "VPSHUFD,";void dg_forthvpshufdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x70, // opcodebyte,        0x0C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpshufdcommaname);        return;    }}const char* dg_forthvpshufhwcommaname = "VPSHUFHW,";void dg_forthvpshufhwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x70, // opcodebyte,        0x0C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpshufhwcommaname);        return;    }}const char* dg_forthvpshuflwcommaname = "VPSHUFLW,";void dg_forthvpshuflwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x70, // opcodebyte,        0x0C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpshuflwcommaname);        return;    }}const char* dg_forthvpsignbcommaname = "VPSIGNB,";void dg_forthvpsignbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x08, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsignbcommaname);        return;    }}const char* dg_forthvpsignwcommaname = "VPSIGNW,";void dg_forthvpsignwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x09, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsignwcommaname);        return;    }}const char* dg_forthvpsigndcommaname = "VPSIGND,";void dg_forthvpsigndcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x0A, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsigndcommaname);        return;    }}const char* dg_forthvpsubbcommaname = "VPSUBB,";void dg_forthvpsubbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xF8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubbcommaname);        return;    }}const char* dg_forthvpsubwcommaname = "VPSUBW,";void dg_forthvpsubwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xF9, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubwcommaname);        return;    }}const char* dg_forthvpsubdcommaname = "VPSUBD,";void dg_forthvpsubdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xFA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubdcommaname);        return;    }}const char* dg_forthvpsubqcommaname = "VPSUBQ,";void dg_forthvpsubqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xFB, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubqcommaname);        return;    }}const char* dg_forthvpsubsbcommaname = "VPSUBSB,";void dg_forthvpsubsbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xE8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubsbcommaname);        return;    }}const char* dg_forthvpsubswcommaname = "VPSUBSW,";void dg_forthvpsubswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xE9, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubswcommaname);        return;    }}const char* dg_forthvpsubusbcommaname = "VPSUBUSB,";void dg_forthvpsubusbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xD8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubusbcommaname);        return;    }}const char* dg_forthvpsubuswcommaname = "VPSUBUSW,";void dg_forthvpsubuswcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xD9, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsubuswcommaname);        return;    }}const char* dg_forthvptestcommaname = "VPTEST,";void dg_forthvptestcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x17, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvptestcommaname);        return;    }}const char* dg_forthvpunpckhbwcommaname = "VPUNPCKHBW,";void dg_forthvpunpckhbwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x68, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpckhbwcommaname);        return;    }}const char* dg_forthvpunpckhwdcommaname = "VPUNPCKHWD,";void dg_forthvpunpckhwdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x69, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpckhwdcommaname);        return;    }}const char* dg_forthvpunpckhdqcommaname = "VPUNPCKHDQ,";void dg_forthvpunpckhdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x6A, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpckhdqcommaname);        return;    }}const char* dg_forthvpunpckhqdqcommaname = "VPUNPCKHQDQ,";void dg_forthvpunpckhqdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x6D, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpckhqdqcommaname);        return;    }}const char* dg_forthvpunpcklbwcommaname = "VPUNPCKLBW,";void dg_forthvpunpcklbwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x60, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpcklbwcommaname);        return;    }}const char* dg_forthvpunpcklwdcommaname = "VPUNPCKLWD,";void dg_forthvpunpcklwdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x61, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpcklwdcommaname);        return;    }}const char* dg_forthvpunpckldqcommaname = "VPUNPCKLDQ,";void dg_forthvpunpckldqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x62, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpckldqcommaname);        return;    }}const char* dg_forthvpunpcklqdqcommaname = "VPUNPCKLQDQ,";void dg_forthvpunpcklqdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x6C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpunpcklqdqcommaname);        return;    }}const char* dg_forthvpxorcommaname = "VPXOR,";void dg_forthvpxorcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xEF, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpxorcommaname);        return;    }}const char* dg_forthvrcppscommaname = "VRCPPS,";void dg_forthvrcppscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x53, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvrcppscommaname);        return;    }}const char* dg_forthvrcpsscommaname = "VRCPSS,";void dg_forthvrcpsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x53, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvrcpsscommaname);        return;    }}const char* dg_forthvroundpdcommaname = "VROUNDPD,";void dg_forthvroundpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x09, // opcodebyte,        0x0C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvroundpdcommaname);        return;    }}const char* dg_forthvroundpscommaname = "VROUNDPS,";void dg_forthvroundpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x08, // opcodebyte,        0x0C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvroundpscommaname);        return;    }}const char* dg_forthvroundsdcommaname = "VROUNDSD,";void dg_forthvroundsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x0B, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvroundsdcommaname);        return;    }}const char* dg_forthvroundsscommaname = "VROUNDSS,";void dg_forthvroundsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x0A, // opcodebyte,        0x06); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvroundsscommaname);        return;    }}const char* dg_forthvrsqrtpscommaname = "VRSQRTPS,";void dg_forthvrsqrtpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x52, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvrsqrtpscommaname);        return;    }}const char* dg_forthvrsqrtsscommaname = "VRSQRTSS,";void dg_forthvrsqrtsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x52, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvrsqrtsscommaname);        return;    }}const char* dg_forthvshufpdcommaname = "VSHUFPD,";void dg_forthvshufpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xC6, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvshufpdcommaname);        return;    }}const char* dg_forthvshufpscommaname = "VSHUFPS,";void dg_forthvshufpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xC6, // opcodebyte,        0x04); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvshufpscommaname);        return;    }}const char* dg_forthvsqrtpdcommaname = "VSQRTPD,";void dg_forthvsqrtpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x51, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsqrtpdcommaname);        return;    }}const char* dg_forthvsqrtpscommaname = "VSQRTPS,";void dg_forthvsqrtpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x51, // opcodebyte,        0x1C); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsqrtpscommaname);        return;    }}const char* dg_forthvsqrtsdcommaname = "VSQRTSD,";void dg_forthvsqrtsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x51, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsqrtsdcommaname);        return;    }}const char* dg_forthvsqrtsscommaname = "VSQRTSS,";void dg_forthvsqrtsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x51, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsqrtsscommaname);        return;    }}const char* dg_forthvsubpdcommaname = "VSUBPD,";void dg_forthvsubpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsubpdcommaname);        return;    }}const char* dg_forthvsubpscommaname = "VSUBPS,";void dg_forthvsubpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsubpscommaname);        return;    }}const char* dg_forthvsubsdcommaname = "VSUBSD,";void dg_forthvsubsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5C, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsubsdcommaname);        return;    }}const char* dg_forthvsubsscommaname = "VSUBSS,";void dg_forthvsubsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x5C, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvsubsscommaname);        return;    }}const char* dg_forthvucomisdcommaname = "VUCOMISD,";void dg_forthvucomisdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x2E, // opcodebyte,        0x1E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvucomisdcommaname);        return;    }}const char* dg_forthvucomisscommaname = "VUCOMISS,";void dg_forthvucomisscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x2E, // opcodebyte,        0x1E); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvucomisscommaname);        return;    }}const char* dg_forthvunpckhpdcommaname = "VUNPCKHPD,";void dg_forthvunpckhpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x15, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvunpckhpdcommaname);        return;    }}const char* dg_forthvunpckhpscommaname = "VUNPCKHPS,";void dg_forthvunpckhpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x15, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvunpckhpscommaname);        return;    }}const char* dg_forthvunpcklpdcommaname = "VUNPCKLPD,";void dg_forthvunpcklpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x14, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvunpcklpdcommaname);        return;    }}const char* dg_forthvunpcklpscommaname = "VUNPCKLPS,";void dg_forthvunpcklpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x14, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvunpcklpscommaname);        return;    }}const char* dg_forthvbroadcastsscommaname = "VBROADCASTSS,";void dg_forthvbroadcastsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x18, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvbroadcastsscommaname);        return;    }}const char* dg_forthvbroadcastsdcommaname = "VBROADCASTSD,";void dg_forthvbroadcastsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x19, // opcodebyte,        0x19); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvbroadcastsdcommaname);        return;    }}const char* dg_forthvbroadcastf128commaname = "VBROADCASTF128,";void dg_forthvbroadcastf128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x1A, // opcodebyte,        0x19); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvbroadcastf128commaname);        return;    }}const char* dg_forthvcvtph2pscommaname = "VCVTPH2PS,";void dg_forthvcvtph2pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x13, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target                                   // bit 5 = 1 first source can't be reg                                   // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtph2pscommaname);        return;    }}/*const char* dg_forthvcvtph2pscommaname = "VCVTPH2PS,";void dg_forthvcvtph2pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x13, // opcodebyte,        0x18); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvcvtph2pscommaname);        return;    }}*/const char* dg_forthvfmadd132pdcommaname = "VFMADD132PD,";void dg_forthvfmadd132pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x98, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd132pdcommaname);        return;    }}const char* dg_forthvfmadd213pdcommaname = "VFMADD213PD,";void dg_forthvfmadd213pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xA8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd213pdcommaname);        return;    }}const char* dg_forthvfmadd231pdcommaname = "VFMADD231PD,";void dg_forthvfmadd231pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xB8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd231pdcommaname);        return;    }}const char* dg_forthvfmadd132pscommaname = "VFMADD132PS,";void dg_forthvfmadd132pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x98, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd132pscommaname);        return;    }}const char* dg_forthvfmadd213pscommaname = "VFMADD213PS,";void dg_forthvfmadd213pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xA8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd213pscommaname);        return;    }}const char* dg_forthvfmadd231pscommaname = "VFMADD231PS,";void dg_forthvfmadd231pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xB8, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd231pscommaname);        return;    }}const char* dg_forthvfmadd132sdcommaname = "VFMADD132SD,";void dg_forthvfmadd132sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x99, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                                   // bit 1 = 1 no ymm destination                                   // bit 2 = 1 source and dest regs can't be different sizes                                   // bit 3 = 1 no 2nd source target                                   // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd132sdcommaname);        return;    }}const char* dg_forthvfmadd213sdcommaname = "VFMADD213SD,";void dg_forthvfmadd213sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xA9, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd213sdcommaname);        return;    }}const char* dg_forthvfmadd231sdcommaname = "VFMADD231SD,";void dg_forthvfmadd231sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xB9, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd231sdcommaname);        return;    }}const char* dg_forthvfmadd132sscommaname = "VFMADD132SS,";void dg_forthvfmadd132sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x99, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd132sscommaname);        return;    }}const char* dg_forthvfmadd213sscommaname = "VFMADD213SS,";void dg_forthvfmadd213sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xA9, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd213sscommaname);        return;    }}const char* dg_forthvfmadd231sscommaname = "VFMADD231SS,";void dg_forthvfmadd231sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xB9, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmadd231sscommaname);        return;    }}const char* dg_forthvfmaddsub132pdcommaname = "VFMADDSUB132PD,";void dg_forthvfmaddsub132pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x96, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmaddsub132pdcommaname);        return;    }}const char* dg_forthvfmaddsub213pdcommaname = "VFMADDSUB213PD,";void dg_forthvfmaddsub213pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xA6, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmaddsub213pdcommaname);        return;    }}const char* dg_forthvfmaddsub231pdcommaname = "VFMADDSUB231PD,";void dg_forthvfmaddsub231pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xB6, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmaddsub231pdcommaname);        return;    }}const char* dg_forthvfmaddsub132pscommaname = "VFMADDSUB132PS,";void dg_forthvfmaddsub132pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x96, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmaddsub132pscommaname);        return;    }}const char* dg_forthvfmaddsub213pscommaname = "VFMADDSUB213PS,";void dg_forthvfmaddsub213pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xA6, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmaddsub213pscommaname);        return;    }}const char* dg_forthvfmaddsub231pscommaname = "VFMADDSUB231PS,";void dg_forthvfmaddsub231pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xB6, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmaddsub231pscommaname);        return;    }}const char* dg_forthvfmsubadd132pdcommaname = "VFMSUBADD132PD,";void dg_forthvfmsubadd132pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x97, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsubadd132pdcommaname);        return;    }}const char* dg_forthvfmsubadd213pdcommaname = "VFMSUBADD213PD,";void dg_forthvfmsubadd213pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xA7, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsubadd213pdcommaname);        return;    }}const char* dg_forthvfmsubadd231pdcommaname = "VFMSUBADD231PD,";void dg_forthvfmsubadd231pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xB7, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsubadd231pdcommaname);        return;    }}const char* dg_forthvfmsubadd132pscommaname = "VFMSUBADD132PS,";void dg_forthvfmsubadd132pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x97, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsubadd132pscommaname);        return;    }}const char* dg_forthvfmsubadd213pscommaname = "VFMSUBADD213PS,";void dg_forthvfmsubadd213pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xA7, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsubadd213pscommaname);        return;    }}const char* dg_forthvfmsubadd231pscommaname = "VFMSUBADD231PS,";void dg_forthvfmsubadd231pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xB7, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsubadd231pscommaname);        return;    }}const char* dg_forthvfmsub132pdcommaname = "VFMSUB132PD,";void dg_forthvfmsub132pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x9A, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub132pdcommaname);        return;    }}const char* dg_forthvfmsub213pdcommaname = "VFMSUB213PD,";void dg_forthvfmsub213pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xAA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub213pdcommaname);        return;    }}const char* dg_forthvfmsub231pdcommaname = "VFMSUB231PD,";void dg_forthvfmsub231pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xBA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub231pdcommaname);        return;    }}const char* dg_forthvfmsub132pscommaname = "VFMSUB132PS,";void dg_forthvfmsub132pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x9A, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub132pscommaname);        return;    }}const char* dg_forthvfmsub213pscommaname = "VFMSUB213PS,";void dg_forthvfmsub213pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xAA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub213pscommaname);        return;    }}const char* dg_forthvfmsub231pscommaname = "VFMSUB231PS,";void dg_forthvfmsub231pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xBA, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub231pscommaname);        return;    }}const char* dg_forthvfmsub132sdcommaname = "VFMSUB132SD,";void dg_forthvfmsub132sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x9B, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub132sdcommaname);        return;    }}const char* dg_forthvfmsub213sdcommaname = "VFMSUB213SD,";void dg_forthvfmsub213sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xAB, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub213sdcommaname);        return;    }}const char* dg_forthvfmsub231sdcommaname = "VFMSUB231SD,";void dg_forthvfmsub231sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xBB, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub231sdcommaname);        return;    }}const char* dg_forthvfmsub132sscommaname = "VFMSUB132SS,";void dg_forthvfmsub132sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x9B, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub132sscommaname);        return;    }}const char* dg_forthvfmsub213sscommaname = "VFMSUB213SS,";void dg_forthvfmsub213sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xAB, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub213sscommaname);        return;    }}const char* dg_forthvfmsub231sscommaname = "VFMSUB231SS,";void dg_forthvfmsub231sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xBB, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfmsub231sscommaname);        return;    }}const char* dg_forthvfnmadd132pdcommaname = "VFNMADD132PD,";void dg_forthvfnmadd132pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x9C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd132pdcommaname);        return;    }}const char* dg_forthvfnmadd213pdcommaname = "VFNMADD213PD,";void dg_forthvfnmadd213pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xAC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd213pdcommaname);        return;    }}const char* dg_forthvfnmadd231pdcommaname = "VFNMADD231PD,";void dg_forthvfnmadd231pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xBC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd231pdcommaname);        return;    }}const char* dg_forthvfnmadd132pscommaname = "VFNMADD132PS,";void dg_forthvfnmadd132pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x9C, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd132pscommaname);        return;    }}const char* dg_forthvfnmadd213pscommaname = "VFNMADD213PS,";void dg_forthvfnmadd213pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xAC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd213pscommaname);        return;    }}const char* dg_forthvfnmadd231pscommaname = "VFNMADD231PS,";void dg_forthvfnmadd231pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xBC, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd231pscommaname);        return;    }}const char* dg_forthvfnmadd132sdcommaname = "VFNMADD132SD,";void dg_forthvfnmadd132sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x9D, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd132sdcommaname);        return;    }}const char* dg_forthvfnmadd213sdcommaname = "VFNMADD213SD,";void dg_forthvfnmadd213sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xAD, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd213sdcommaname);        return;    }}const char* dg_forthvfnmadd231sdcommaname = "VFNMADD231SD,";void dg_forthvfnmadd231sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xBD, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd231sdcommaname);        return;    }}const char* dg_forthvfnmadd132sscommaname = "VFNMADD132SS,";void dg_forthvfnmadd132sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x9D, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd132sscommaname);        return;    }}const char* dg_forthvfnmadd213sscommaname = "VFNMADD213SS,";void dg_forthvfnmadd213sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xAD, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd213sscommaname);        return;    }}const char* dg_forthvfnmadd231sscommaname = "VFNMADD231SS,";void dg_forthvfnmadd231sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xBD, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmadd231sscommaname);        return;    }}const char* dg_forthvfnmsub132pdcommaname = "VFNMSUB132PD,";void dg_forthvfnmsub132pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x9E, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub132pdcommaname);        return;    }}const char* dg_forthvfnmsub213pdcommaname = "VFNMSUB213PD,";void dg_forthvfnmsub213pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xAE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub213pdcommaname);        return;    }}const char* dg_forthvfnmsub231pdcommaname = "VFNMSUB231PD,";void dg_forthvfnmsub231pdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xBE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub231pdcommaname);        return;    }}const char* dg_forthvfnmsub132pscommaname = "VFNMSUB132PS,";void dg_forthvfnmsub132pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x9E, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub132pscommaname);        return;    }}const char* dg_forthvfnmsub213pscommaname = "VFNMSUB213PS,";void dg_forthvfnmsub213pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xAE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub213pscommaname);        return;    }}const char* dg_forthvfnmsub231pscommaname = "VFNMSUB231PS,";void dg_forthvfnmsub231pscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xBE, // opcodebyte,        0x14); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub231pscommaname);        return;    }}const char* dg_forthvfnmsub132sdcommaname = "VFNMSUB132SD,";void dg_forthvfnmsub132sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0x9F, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                           // bit 1 = 1 no ymm destination                           // bit 2 = 1 source and dest regs can't be different sizes                           // bit 3 = 1 no 2nd source target                           // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub132sdcommaname);        return;    }}const char* dg_forthvfnmsub213sdcommaname = "VFNMSUB213SD,";void dg_forthvfnmsub213sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xAF, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub213sdcommaname);        return;    }}const char* dg_forthvfnmsub231sdcommaname = "VFNMSUB231SD,";void dg_forthvfnmsub231sdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1, // rexdotw,        0xBF, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub231sdcommaname);        return;    }}const char* dg_forthvfnmsub132sscommaname = "VFNMSUB132SS,";void dg_forthvfnmsub132sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0x9F, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub132sscommaname);        return;    }}const char* dg_forthvfnmsub213sscommaname = "VFNMSUB213SS,";void dg_forthvfnmsub213sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xAF, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub213sscommaname);        return;    }}const char* dg_forthvfnmsub231sscommaname = "VFNMSUB231SS,";void dg_forthvfnmsub231sscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1, // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2, // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0, // rexdotw,        0xBF, // opcodebyte,        0x16); // disallowedmodes) // bit 0 = 1 no xmm destination                       // bit 1 = 1 no ymm destination                       // bit 2 = 1 source and dest regs can't be different sizes                       // bit 3 = 1 no 2nd source target                       // bit 4 = 1 no immediate target            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvfnmsub231sscommaname);        return;    }}const char* dg_forthvinsertf128commaname = "VINSERTF128,";void dg_forthvinsertf128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x18,  // opcodebyte,        0x01); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvinsertf128commaname);        return;    }}const char* dg_forthvinserti128commaname = "VINSERTI128,";void dg_forthvinserti128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x38,  // opcodebyte,        0x01); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvinserti128commaname);        return;    }}const char* dg_forthvpblenddcommaname = "VPBLENDD,";void dg_forthvpblenddcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x02,  // opcodebyte,        0x04); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpblenddcommaname);        return;    }}const char* dg_forthvpbroadcastbcommaname = "VPBROADCASTB,";void dg_forthvpbroadcastbcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x78,  // opcodebyte,        0x18); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpbroadcastbcommaname);        return;    }}const char* dg_forthvpbroadcastwcommaname = "VPBROADCASTW,";void dg_forthvpbroadcastwcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x79,  // opcodebyte,        0x18); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpbroadcastwcommaname);        return;    }}const char* dg_forthvpbroadcastdcommaname = "VPBROADCASTD,";void dg_forthvpbroadcastdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x58,  // opcodebyte,        0x18); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpbroadcastdcommaname);        return;    }}const char* dg_forthvpbroadcastqcommaname = "VPBROADCASTQ,";void dg_forthvpbroadcastqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x59,  // opcodebyte,        0x18); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpbroadcastqcommaname);        return;    }}const char* dg_forthvpbroadcasti128commaname = "VPBROADCASTI128,";void dg_forthvpbroadcasti128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x5A,  // opcodebyte,        0x39); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpbroadcasti128commaname);        return;    }}const char* dg_forthvpermdcommaname = "VPERMD,";void dg_forthvpermdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x36,  // opcodebyte,        0x15); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpermdcommaname);        return;    }}const char* dg_forthvpermpdcommaname = "VPERMPD,";void dg_forthvpermpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x01,  // opcodebyte,        0x0D); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpermpdcommaname);        return;    }}const char* dg_forthvpermpscommaname = "VPERMPS,";void dg_forthvpermpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x16,  // opcodebyte,        0x15); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpermpscommaname);        return;    }}const char* dg_forthvpermqcommaname = "VPERMQ,";void dg_forthvpermqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x00,  // opcodebyte,        0x0D); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpermqcommaname);        return;    }}const char* dg_forthvperm2i128commaname = "VPERM2I128,";void dg_forthvperm2i128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x46,  // opcodebyte,        0x05); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvperm2i128commaname);        return;    }}const char* dg_forthvperm2f128commaname = "VPERM2F128,";void dg_forthvperm2f128comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        3,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x06,  // opcodebyte,        0x05); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvperm2f128commaname);        return;    }}const char* dg_forthvpsllvdcommaname = "VPSLLVD,";void dg_forthvpsllvdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x47,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsllvdcommaname);        return;    }}const char* dg_forthvpsllvqcommaname = "VPSLLVQ,";void dg_forthvpsllvqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x47,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsllvqcommaname);        return;    }}const char* dg_forthvpsravdcommaname = "VPSRAVD,";void dg_forthvpsravdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x46,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsravdcommaname);        return;    }}const char* dg_forthvpsrlvdcommaname = "VPSRLVD,";void dg_forthvpsrlvdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x45,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrlvdcommaname);        return;    }}const char* dg_forthvpsrlvqcommaname = "VPSRLVQ,";void dg_forthvpsrlvqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x45,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpsrlvqcommaname);        return;    }}const char* dg_forthvtestpdcommaname = "VTESTPD,";void dg_forthvtestpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x0F,  // opcodebyte,        0x1C); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvtestpdcommaname);        return;    }}const char* dg_forthvtestpscommaname = "VTESTPS,";void dg_forthvtestpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x0E,  // opcodebyte,        0x1C); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvtestpscommaname);        return;    }}const char* dg_forthvzeroallcommaname = "VZEROALL,";void dg_forthvzeroallcomma (Bufferhandle* pBHarrayhead){    UINT64 x;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        x = dg_packtwobytevex (        0, // simdprefixcode, // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1, // vectorlength, // 0 = 128, 1 = 256        0, // psf->secondsourcereg, // 0-15        0); // rexdotr); // 0 or 1        dg_compilesegment (        pBHarrayhead,        (const char*)&x,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvzeroallcommaname);        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)"\x77",        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvzeroallcommaname);        return;    }}const char* dg_forthvzerouppercommaname = "VZEROUPPER,";void dg_forthvzerouppercomma (Bufferhandle* pBHarrayhead){    UINT64 x;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        x = dg_packtwobytevex (        0, // simdprefixcode, // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        0, // vectorlength, // 0 = 128, 1 = 256        0, // psf->secondsourcereg, // 0-15        0); // rexdotr); // 0 or 1        dg_compilesegment (        pBHarrayhead,        (const char*)&x,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvzerouppercommaname);        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)"\x77",        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvzeroallcommaname);        return;    }}const char* dg_forthvxorpdcommaname = "VXORPD,";void dg_forthvxorpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x57,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvxorpdcommaname);        return;    }}const char* dg_forthvxorpscommaname = "VXORPS,";void dg_forthvxorpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        0,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x57,  // opcodebyte,        0x14); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvxorpscommaname);        return;    }}/*const char* dg_forthvmovsdcommaname = "VMOVSD,";void dg_forthvmovsdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x10,  // opcodebyte,        0x56); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsdcommaname);        return;    }}const char* dg_forthvmovsd3commaname = "VMOVSD3,";void dg_forthvmovsd3comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        3,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x11,  // opcodebyte,        0x56); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsd3commaname);        return;    }}const char* dg_forthvmovsscommaname = "VMOVSS,";void dg_forthvmovsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x10,  // opcodebyte,        0x56); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovsscommaname);        return;    }}const char* dg_forthvmovss3commaname = "VMOVSS3,";void dg_forthvmovss3comma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8morxmmxmmtoxmm (        pBHarrayhead,        2,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        1,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x11,  // opcodebyte,        0x56); // disallowedmodes)                 // bit 0 = 1 no xmm destination                 // bit 1 = 1 no ymm destination                 // bit 2 = 1 source and dest regs can't be different sizes                 // bit 3 = 1 no 2nd source target                 // bit 4 = 1 no immediate target                 // bit 5 = 1 first source can't be reg                 // bit 6 = 1 first source can't be memory            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvmovss3commaname);        return;    }}*/const char* dg_formatvsibname = "dg_formatvsib";void dg_formatvsib (    Bufferhandle* pBHarrayhead,    dg_Sibformatter* psf){    UINT64 newscale;     // there has to be a base reg    if (psf->basereg == dg_noreg)    {        dg_pusherror(pBHarrayhead, (const char*)"have to have a base register");        dg_pusherror(pBHarrayhead, dg_formatvsibname);        return;    }        // bumping displacement size if needed based on value of the displacement    dg_bumpdisplacementsizeifneeded (psf);        // memmode should already be vsib    // r/m is always 4    psf->rslashm = 4;        // scale doesn't change, (could force it to be 0-3)    // basereg doesn't change after this point, all 7 are ok        dg_setmod(psf);        switch (psf->scale)    {        case 1:           newscale = 0;           break;        case 2:            newscale = 1;            break;        case 4:            newscale = 2;            break;        case 8:            newscale = 3;            break;        default:            newscale = 0;            dg_pusherror(pBHarrayhead, (const char*)"unknown scale - must be one of 1, 2, 4, or 8");            dg_pusherror(pBHarrayhead, dg_formatsibname);            break;    }        psf->scale = newscale;    }const char* dg_pullandcompilevexxmmsibtoxmmname = "dg_pullandcompilevexxmmsibtoxmm";void dg_pullandcompilevexxmmsibtoxmm (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 rexdotw,    UINT64 opcodebyte){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        dg_Sibformatter* pdestinationtarget = &firsttarget;    dg_Sibformatter* psourcetarget = &thirdtarget;    dg_Sibformatter* psibtarget = &secondtarget;        UINT64 sourcetargettype;    UINT64 destinationtargettype;    UINT64 sibtargettype;        UINT64 addresssize;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 isreverse = FORTH_FALSE;        unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }    dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }     dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondtarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        if (isreverse != FORTH_FALSE)    {        pdestinationtarget = &thirdtarget;        psourcetarget = &firsttarget;    }        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);            sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        //sibtargettype = dg_gettargettype(    //    pBHarrayhead,    //    psibtarget);        if (sourcetargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be an xmm/ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }                if (destinationtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be an xmm/ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        if (psibtarget->memmode != dg_memmodevsib)    {        dg_pusherror(pBHarrayhead, (const char*)"vsib target must be a vsib memory target");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        // could make sure everything is the same size... if they are regs        psibtarget->targetreg = pdestinationtarget->basereg;    psibtarget->secondsourcereg = psourcetarget->basereg;        // going to ignore sib size just use destination size    psibtarget->size = pdestinationtarget->size;        // encoding has to be sib so going to force encoding to sib    //  not sure what happens if user specifies noreg for base or index... :-)    // psibtarget->memmode = dg_memmodevsib;  // should arlready be dg_memmodevib from pulling vsib target        // can't do formatpsf... have to do something else...    dg_formatvsib(        pBHarrayhead,        psibtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        // compilevex figures out size from psf->size, and handles vsib index reg    dg_compilevex (        pBHarrayhead,        psibtarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&(opcodebyte), // assumes little endian        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        // can't do dg_compilepsf... but since we know what the mem mode is...        c = dg_calculatemodrslashm(psibtarget);        dg_compilesegment(        pBHarrayhead,        (const char*)&c,        sizeof(unsigned char));        c = dg_calculatesib(psibtarget);        dg_compilesegment(        pBHarrayhead,        (const char*)&c,        sizeof(unsigned char));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }        dg_compiledisplacement(        pBHarrayhead,        psibtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexxmmsibtoxmmname);        return;    }}const char* dg_forthvgatherdpdcommaname = "VGATHERDPD,";void dg_forthvgatherdpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x92); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvgatherdpdcommaname);        return;    }}const char* dg_forthvgatherqpdcommaname = "VGATHERQPD,";void dg_forthvgatherqpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x93); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvgatherqpdcommaname);        return;    }}const char* dg_forthvgatherdpscommaname = "VGATHERDPS,";void dg_forthvgatherdpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x92); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvgatherdpscommaname);        return;    }}const char* dg_forthvgatherqpscommaname = "VGATHERQPS,";void dg_forthvgatherqpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x93); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvgatherqpscommaname);        return;    }}const char* dg_forthvpgatherddcommaname = "VPGATHERDD,";void dg_forthvpgatherddcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x90); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpgatherddcommaname);        return;    }}const char* dg_forthvpgatherqdcommaname = "VPGATHERQD,";void dg_forthvpgatherqdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0,     // rexdotw,        0x91); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpgatherqdcommaname);        return;    }}const char* dg_forthvpgatherdqcommaname = "VPGATHERDQ,";void dg_forthvpgatherdqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x90); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpgatherdqcommaname);        return;    }}const char* dg_forthvpgatherqqcommaname = "VPGATHERQQ,";void dg_forthvpgatherqqcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexxmmsibtoxmm (        pBHarrayhead,        1,     // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        2,     // leadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        1,     // rexdotw,        0x91); // opcodebyte,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpgatherqqcommaname);        return;    }}const char* dg_pullandcompilevexn8ormorxmmxmmtoxmmname = "dg_pullandcompilevexn8ormorxmmxmmtoxmm";void dg_pullandcompilevexn8ormorxmmxmmtoxmm (    Bufferhandle* pBHarrayhead,    UINT64 simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2    UINT64 rexdotw,    UINT64 usesmorxmmleadingopcodebytescode,     // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 usesmorxmmopcodebyte,    UINT64 usesimmediateleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A    UINT64 usesimmediateopcodebyte){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        dg_Sibformatter* pdestinationtarget = &firsttarget; // always forward destination    dg_Sibformatter* psourcetarget = &secondtarget; // may be moved to third target if not immediate    dg_Sibformatter* psecondtarget = &secondtarget;    dg_Sibformatter* pimmediatetarget = &thirdtarget; // always third target if used        UINT64 thirdtargettype;        UINT64 sourcetargettype;    UINT64 secondtargettype;    UINT64 destinationtargettype;        UINT64 addresssize;        // UINT64 usingimmediate = FORTH_FALSE;    UINT64 isreverse = FORTH_FALSE;        UINT64 usethreebytevex = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }    dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }     dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        if ( (firsttarget.usesthreebytevex != 0) ||         (secondtarget.usesthreebytevex != 0) ||         (thirdtarget.usesthreebytevex != 0)       )    {        usethreebytevex = FORTH_TRUE;    }        thirdtargettype = dg_gettargettype(        pBHarrayhead,        &thirdtarget);            if (thirdtargettype == dg_targettypeimmediate)    {        // using immediate        pdestinationtarget = &firsttarget; // always forward destination        psourcetarget = &secondtarget; // may be moved to third target if not immediate        dg_Sibformatter* pimmediatetarget = &thirdtarget; // always third target if used                if ( (firsttarget.direction != 0) ||             (secondtarget.direction != 0)  )        {            isreverse = FORTH_TRUE;        }                if (isreverse != FORTH_FALSE)        {            psourcetarget = &firsttarget;            pdestinationtarget = &secondtarget;        }                sourcetargettype = dg_gettargettype(            pBHarrayhead,            psourcetarget);                destinationtargettype = dg_gettargettype(            pBHarrayhead,            pdestinationtarget);                    if (destinationtargettype != dg_targettypexmmreg)        {            dg_pusherror(pBHarrayhead, (const char*)"destination target must be an xmm/ymm register");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                if ((sourcetargettype != dg_targettypexmmreg) &&            (sourcetargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"source target must be an xmm/ymm register or memory");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                // could make sure everything is the same size... if they are regs                psourcetarget->targetreg = pdestinationtarget->basereg;                psourcetarget->secondsourcereg = dg_xmm0; // probably don't need to do this            // going to ignore source size just use destination size        psourcetarget->size = pdestinationtarget->size;                if ((pimmediatetarget->immediatesize != 0) &&            (pimmediatetarget->immediatesize != 1))        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported...");            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                psourcetarget->immediatesize = 1;                dg_formatpsf(            pBHarrayhead,            psourcetarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                // compilevex figures out size from psf->size        dg_compilevex (            pBHarrayhead,            psourcetarget,            addresssize,            simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2            usesimmediateleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A            rexdotw,            usethreebytevex);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(usesimmediateopcodebyte), // assumes little endian            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                dg_compilepsf(            pBHarrayhead,            psourcetarget);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                    dg_compilesegment(            pBHarrayhead,            (const char*)&(pimmediatetarget->immediatevalue), // assumes little endian            1);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);            return;        }                    return;    }        // not immediate    psourcetarget = &thirdtarget; // really the mask    psecondtarget = &secondtarget; // really the source    pdestinationtarget = &firsttarget;     if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) ||         (thirdtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        psecondtarget);                if (secondtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second source target must be an xmm/ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        if (isreverse != FORTH_FALSE)    {        psourcetarget = &firsttarget;        pdestinationtarget = &thirdtarget;    }        sourcetargettype = dg_gettargettype(        pBHarrayhead,        psourcetarget);        destinationtargettype = dg_gettargettype(        pBHarrayhead,        pdestinationtarget);            if (destinationtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"destination target must be an xmm/ymm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        if ((sourcetargettype != dg_targettypexmmreg) &&        (sourcetargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"source target must be an xmm/ymm register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        // could make sure everything is the same size... if they are regs        psourcetarget->targetreg = pdestinationtarget->basereg;    psourcetarget->secondsourcereg = psecondtarget->basereg;       // going to ignore source size just use destination size    psourcetarget->size = pdestinationtarget->size;        dg_formatpsf(        pBHarrayhead,        psourcetarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        // compilevex figures out size from psf->size    dg_compilevex (        pBHarrayhead,        psourcetarget,        addresssize,        simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        usesmorxmmleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        rexdotw,        usethreebytevex);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&(usesmorxmmopcodebyte), // assumes little endian        1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }        dg_compilepsf(        pBHarrayhead,        psourcetarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilevexn8ormorxmmxmmtoxmmname);        return;    }}const char* dg_forthvpermilpdcommaname = "VPERMILPD,";void dg_forthvpermilpdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8ormorxmmxmmtoxmm (        pBHarrayhead,        1,      // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        0,      // rexdotw,        2,      // usesmorxmmleadingopcodebytescode,     // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x0D,   // usesmorxmmopcodebyte,        3,      // usesimmediateleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x05);  // usesimmediateopcodebyte)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpermilpdcommaname);        return;    }}const char* dg_forthvpermilpscommaname = "VPERMILPS,";void dg_forthvpermilpscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilevexn8ormorxmmxmmtoxmm (        pBHarrayhead,        1,      // simdprefixcode,  // 0 = none, 1 = 0x66, 2 = 0xF3, 3 = 0xF2        0,      // rexdotw,        2,      // usesmorxmmleadingopcodebytescode,     // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x0C,   // usesmorxmmopcodebyte,        3,      // usesimmediateleadingopcodebytescode,  // 1 = 0x0F, 2 = 0x0F 0x38, 3 = 0x0F 0x3A        0x04);  // usesimmediateopcodebyte)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthvpermilpscommaname);        return;    }}const char* dg_pullandcompiletwotargetsname = "dg_pullandcompiletwotargets";void dg_pullandcompiletwotargets (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsname);        return;    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsname);        return;    }}const char* dg_forthmovcrcommaname = "MOVCR,";void dg_forthmovcrcomma (Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);     dg_Sibformatter* pregtarget;    dg_Sibformatter* pcregtarget;        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 c;     const char* perror;        UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype != dg_targettypecontrolreg) &&        (secondtargettype != dg_targettypecontrolreg))    {        dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a control register");        dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);        return;    }        if (firsttargettype == dg_targettypecontrolreg)    {        // default destination is a control reg, default source is r/m        if ((secondtargettype != dg_targettyperega) &&            (secondtargettype != dg_targettypereg) &&            (secondtargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);        }         pcregtarget = &firsttarget;        pregtarget = &secondtarget;                // if user specified reverse then the control reg is the source and r/m is the destination        // the isreverse flag will show the direction    }    else    {        // default source is a control reg, default destination is r/m        if ((firsttargettype != dg_targettyperega) &&            (firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);        }         pregtarget = &firsttarget;        pcregtarget = &secondtarget;                // if the user specified reverse then the control reg is the destination and the source is r/m        // toggling is reverse so that the isreverse flag will show the direction        if (isreverse != FORTH_FALSE)        {            isreverse = FORTH_FALSE;        }        else        {            isreverse = FORTH_TRUE;        }    }    // the control reg target can be pushed as a default reg or as a number followed by CR    //  the actual value of the basereg will be different for each way... so..    //  to determine the target type you have to look at the mem mode...    //  and for target's value, only the lower 4 bits of base reg are used...    if (((pcregtarget->basereg & 0xF) != 0) &&        ((pcregtarget->basereg & 0xF) != 2) &&        ((pcregtarget->basereg & 0xF) != 3) &&        ((pcregtarget->basereg & 0xF) != 4) &&        ((pcregtarget->basereg & 0xF) != 8))    {        dg_pusherror(pBHarrayhead, (const char*)"only control registers 0, 2, 3, 4, and 8 are allowed");        dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);    }        // register size is ignored for this instruction    if (pcregtarget->basereg == dg_cr8)    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x44", // REX.R            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);            return;        }    }        // if isreverse is FORTH_FALSE then the control reg is the destination    if (isreverse == FORTH_FALSE)    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x0F\x22",            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);            return;        }    }    else    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x0F\x20",            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);            return;        }    }        // the upper two bits of the modr/m field are ignored... but since it's register to register... I'm gonna set them    //  just so it is consistent...    c = 0xC0 | ((pcregtarget->basereg & 0x7) << 3) | (pregtarget->basereg & 0x7);        dg_compilesegment(        pBHarrayhead,        (const char*)&c, // assumes little endian        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovcrcommaname);        return;    }}const char* dg_forthmovdrcommaname = "MOVDR,";void dg_forthmovdrcomma (Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);     dg_Sibformatter* pregtarget;    dg_Sibformatter* pdregtarget;        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 c;     const char* perror;        UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype != dg_targettypedebugreg) &&        (secondtargettype != dg_targettypedebugreg))    {        dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a debug register");        dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);        return;    }        if (firsttargettype == dg_targettypedebugreg)    {        // default destination is a control reg, default source is r/m        if ((secondtargettype != dg_targettyperega) &&            (secondtargettype != dg_targettypereg) &&            (secondtargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);        }         pdregtarget = &firsttarget;        pregtarget = &secondtarget;                // if user specified reverse then the control reg is the source and r/m is the destination        // the isreverse flag will show the direction    }    else    {        // default source is a control reg, default destination is r/m        if ((firsttargettype != dg_targettyperega) &&            (firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);        }         pregtarget = &firsttarget;        pdregtarget = &secondtarget;                // if the user specified reverse then the control reg is the destination and the source is r/m        // toggling is reverse so that the isreverse flag will show the direction        if (isreverse != FORTH_FALSE)        {            isreverse = FORTH_FALSE;        }        else        {            isreverse = FORTH_TRUE;        }    }        // if isreverse is FORTH_FALSE then the control reg is the destination    if (isreverse == FORTH_FALSE)    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x0F\x23",            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);            return;        }    }    else    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x0F\x21",            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);            return;        }    }        // the upper two bits of the modr/m field are ignored... but since it's register to register... I'm gonna set them    //  just so it is consistent...    c = 0xC0 | ((pdregtarget->basereg & 0x7) << 3) | (pregtarget->basereg & 0x7);        dg_compilesegment(        pBHarrayhead,        (const char*)&c, // assumes little endian        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdrcommaname);        return;    }}const char* dg_forthmovsrcommaname = "MOVSR,";void dg_forthmovsrcomma (Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);     dg_Sibformatter* pregtarget;    dg_Sibformatter* psregtarget;        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 c;     const char* perror;        UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype != dg_targettypesegmentreg) &&        (secondtargettype != dg_targettypesegmentreg))    {        dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a segment register");        dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);        return;    }        if (firsttargettype == dg_targettypesegmentreg)    {        // default destination is a control reg, default source is r/m        if ((secondtargettype != dg_targettyperega) &&            (secondtargettype != dg_targettypereg) &&            (secondtargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);            return;        }         psregtarget = &firsttarget;        pregtarget = &secondtarget;                // if user specified reverse then the control reg is the source and r/m is the destination        // the isreverse flag will show the direction    }    else    {        // default source is a control reg, default destination is r/m        if ((firsttargettype != dg_targettyperega) &&            (firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"one of the targets must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);            return;        }         pregtarget = &firsttarget;        psregtarget = &secondtarget;                // if the user specified reverse then the control reg is the destination and the source is r/m        // toggling is reverse so that the isreverse flag will show the direction        if (isreverse != FORTH_FALSE)        {            isreverse = FORTH_FALSE;        }        else        {            isreverse = FORTH_TRUE;        }    }        if (psregtarget->size == 2) // this means the user chose  n SR  J.N. 3/17/2020                                //  ... I should come up with a better way to mark whether or not the user used the default reg mode    {        if (pregtarget->size == 1)        {            dg_pusherror(pBHarrayhead, (const char*)"need at least a 16 bit register for this instruction");            dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);            return;        }                if (pregtarget->size == 2) // the user wants the 16 bit prefix        {            dg_compilesegment(                pBHarrayhead,                (const char*)"\x66",                1);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);                return;            }        }                if (pregtarget->size == 8) // the user wants the 64bit rex.w prefix        {            dg_compilesegment(                pBHarrayhead,                (const char*)"\x48",                1);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);                return;            }        }    }        // if isreverse is FORTH_FALSE then the control reg is the destination    if (isreverse == FORTH_FALSE)    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x8E",            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);            return;        }    }    else    {        dg_compilesegment(            pBHarrayhead,            (const char*)"\x8C",            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);            return;        }    }        // the upper two bits of the modr/m field are ignored... but since it's register to register... I'm gonna set them    //  just so it is consistent...    c = 0xC0 | ((psregtarget->basereg & 0x7) << 3) | (pregtarget->basereg & 0x7);        dg_compilesegment(        pBHarrayhead,        (const char*)&c, // assumes little endian        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsrcommaname);        return;    }}const char* dg_pullandcompilemorrtorignoresizename = "dg_pullandcompilemorrtorignoresize";void dg_pullandcompilemorrtorignoresize (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype == dg_targettypemem) &&        (secondtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"memory to memory not supported");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);        return;    }        if (isreverse == FORTH_FALSE)    {        if (firsttargettype == dg_targettypemem)        {            dg_pusherror(pBHarrayhead, (const char*)"destination can not be memory");            dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);            return;        }                // size is ignored        secondtarget.size = 4;        firsttarget.size = 4;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget, // mem target            &secondtarget); // reg target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);            return;        }    }    else    {        if (secondtargettype == dg_targettypemem)        {            dg_pusherror(pBHarrayhead, (const char*)"destination can not be memory");            dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);            return;        }                // size is ignored        secondtarget.size = 4;        firsttarget.size = 4;        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &secondtarget, // reg target            &firsttarget); // mem target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtorignoresizename);            return;        }    }}const char* dg_pullandcompilemtoronlyname = "dg_pullandcompilemtoronly";void dg_pullandcompilemtoronly (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);        return;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype == dg_targettypemem) &&        (secondtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);        return;    }        if ((firsttargettype != dg_targettypemem) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);        return;    }        if (secondtargettype == dg_targettypemem)    {        // m to r case        if ((firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettyperega))        {            dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);            return;        }                // memory target size is ignored        secondtarget.size = firsttarget.size;                // direction is ignored        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget, // mem target            &secondtarget); // reg target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);            return;        }    }    else    {        // r to m case.. gonna force it to be reverse.        if ((secondtargettype != dg_targettypereg) &&            (secondtargettype != dg_targettyperega))        {            dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);            return;        }                // memory target size is ignored        firsttarget.size = secondtarget.size;                // direction is ignored        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &secondtarget, // reg target            &firsttarget); // mem target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyname);            return;        }    }}const char* dg_pullandcompilemtoronlyno64name = "dg_pullandcompilemtoronlyno64";void dg_pullandcompilemtoronlyno64 (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);        return;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype == dg_targettypemem) &&        (secondtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);        return;    }        if ((firsttargettype != dg_targettypemem) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);        return;    }        if (secondtargettype == dg_targettypemem)    {        // m to r case        if ((firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettyperega))        {            dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);            return;        }                if ((firsttarget.size != 2) &&            (firsttarget.size != 4))        {            dg_pusherror(pBHarrayhead, (const char*)"register size must be 16 or 32 bits");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);            return;        }                // memory target size is ignored        secondtarget.size = firsttarget.size;                // direction is ignored        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget, // mem target            &secondtarget); // reg target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);            return;        }    }    else    {        // r to m case.. gonna force it to be reverse.        if ((secondtargettype != dg_targettypereg) &&            (secondtargettype != dg_targettyperega))        {            dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);            return;        }                if ((secondtarget.size != 2) &&            (secondtarget.size != 4))        {            dg_pusherror(pBHarrayhead, (const char*)"register size must be 16 or 32 bits");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);            return;        }                // memory target size is ignored        firsttarget.size = secondtarget.size;                // direction is ignored        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &secondtarget, // reg target            &firsttarget); // mem target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyno64name);            return;        }    }}const char* dg_pullandcompilemtoronlyignoresizename = "dg_pullandcompilemtoronlyignoresize";void dg_pullandcompilemtoronlyignoresize (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);        return;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ((firsttargettype == dg_targettypemem) &&        (secondtargettype == dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);        return;    }        if ((firsttargettype != dg_targettypemem) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);        return;    }        if (secondtargettype == dg_targettypemem)    {        // m to r case        if ((firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettyperega))        {            dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);            return;        }                // size is ignored and direction is ignored        secondtarget.size = 4;        firsttarget.size = 4;        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget, // mem target            &secondtarget); // reg target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);            return;        }    }    else    {        // r to m case.. gonna force it to be reverse.        if ((secondtargettype != dg_targettypereg) &&            (secondtargettype != dg_targettyperega))        {            dg_pusherror(pBHarrayhead, (const char*)"one target must be memory, the other a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);            return;        }                secondtarget.size = 4;        firsttarget.size = 4;        firsttarget.direction = 0;        secondtarget.direction = 0;                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &secondtarget, // reg target            &firsttarget); // mem target                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilemtoronlyignoresizename);            return;        }    }}const char* dg_fillmtoronlyignoresizename = "dg_fillmtoronlyignoresize";void dg_fillmtoronlyignoresize (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    unsigned char* pr32prefixstring,    UINT64 r32prefixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        popcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_fillmtoronlyignoresizename);        return;    }        popcodes->m32tor32.prefixstringlength = r32prefixstringlength;        perror = dg_movebytes(        pr32prefixstring,        (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),        r32prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillmtoronlyignoresizename);        return;    }        popcodes->m32tor32.opcodestringlength = r32opcodestringlength;        perror = dg_movebytes(        pr32opcodestring,        (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),        r32opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillmtoronlyignoresizename);        return;    }        popcodes->m32tor32.opcodeextension = (UINT64)-1;}const char* dg_domtoronlyinstructionname = "dg_domtoronlyinstruction";void dg_domtoronlyinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pr32prefixstring,    UINT64 r32prefixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fillmtoronlyignoresize (        pBHarrayhead,        &myopcodes,        pr32prefixstring,        r32prefixstringlength,        pr32opcodestring,        r32opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtoronlyinstructionname);        return;    }        dg_pullandcompilemtoronly (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtoronlyinstructionname);        return;    }}const char* dg_forthlfscommaname = "LFS,";void dg_forthlfscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtoronlyinstruction(        pBHarrayhead,        (unsigned char*)"", // pr32prefixstring,        0, // r32prefixstringlength        (unsigned char*)"\x0F\xB4", // pr32opcodestring,        2); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlfscommaname);        return;    }}const char* dg_forthlgscommaname = "LGS,";void dg_forthlgscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtoronlyinstruction(        pBHarrayhead,        (unsigned char*)"", // pr32prefixstring,        0, // r32prefixstringlength        (unsigned char*)"\x0F\xB5", // pr32opcodestring,        2); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlgscommaname);        return;    }}const char* dg_forthlsscommaname = "LSS,";void dg_forthlsscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtoronlyinstruction(        pBHarrayhead,        (unsigned char*)"", // pr32prefixstring,        0, // r32prefixstringlength        (unsigned char*)"\x0F\xB2", // pr32opcodestring,        2); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlsscommaname);        return;    }}const char* dg_domtoronlyno64instructionname = "dg_domtoronlyno64instruction";void dg_domtoronlyno64instruction(    Bufferhandle* pBHarrayhead,    unsigned char* pr32prefixstring,    UINT64 r32prefixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fillmtoronlyignoresize (        pBHarrayhead,        &myopcodes,        pr32prefixstring,        r32prefixstringlength,        pr32opcodestring,        r32opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtoronlyno64instructionname);        return;    }        dg_pullandcompilemtoronlyno64 (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtoronlyno64instructionname);        return;    }}const char* dg_forthldscommaname = "LDS,";void dg_forthldscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtoronlyno64instruction(        pBHarrayhead,        (unsigned char*)"", // pr32prefixstring,        0, // r32prefixstringlength        (unsigned char*)"\xC5", // pr32opcodestring,        1); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthldscommaname);        return;    }}const char* dg_forthlescommaname = "LES,";void dg_forthlescomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtoronlyno64instruction(        pBHarrayhead,        (unsigned char*)"", // pr32prefixstring,        0, // r32prefixstringlength        (unsigned char*)"\xC4", // pr32opcodestring,        1); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlescommaname);        return;    }}const char* dg_domorrtorignoresizeinstructionname = "dg_domorrtorignoresizeinstruction";void dg_domorrtorignoresizeinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pr32prefixstring,    UINT64 r32prefixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fillmtoronlyignoresize (        pBHarrayhead,        &myopcodes,        pr32prefixstring,        r32prefixstringlength,        pr32opcodestring,        r32opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorrtorignoresizeinstructionname);        return;    }        dg_pullandcompilemorrtorignoresize (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorrtorignoresizeinstructionname);        return;    }}// size is ignored, direction supported but mem can not be destinationconst char* dg_forthlarcommaname = "LAR,";void dg_forthlarcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorrtorignoresizeinstruction(        pBHarrayhead,        (unsigned char*)"", // pr32prefixstring,        0, // r32prefixstringlength        (unsigned char*)"\x0F\x02", // pr32opcodestring,        2); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlarcommaname);        return;    }}const char* dg_domtoronlyignoresizeinstructionname = "dg_domtoronlyignoresizeinstruction";void dg_domtoronlyignoresizeinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pr32prefixstring,    UINT64 r32prefixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fillmtoronlyignoresize (        pBHarrayhead,        &myopcodes,        pr32prefixstring,        r32prefixstringlength,        pr32opcodestring,        r32opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtoronlyignoresizeinstructionname);        return;    }        dg_pullandcompilemtoronlyignoresize (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtoronlyignoresizeinstructionname);        return;    }}// size is ignored, direction is ignored (reg is always dest), src can not be memconst char* dg_forthinvpcidcommaname = "INVPCID,";void dg_forthinvpcidcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtoronlyignoresizeinstruction(        pBHarrayhead,        (unsigned char*)"\x66", // pr32prefixstring,        1, // r32prefixstringlength        (unsigned char*)"\x0F\x38\x82", // pr32opcodestring,        3); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinvpcidcommaname);        return;    }}const char* dg_pullandcompiletwotargetsignoredestsizename = "dg_pullandcompiletwotargetsignoredestsize";void dg_pullandcompiletwotargetsignoredestsize (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 isreverse = FORTH_FALSE;    UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);        return;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        if (isreverse == FORTH_FALSE)    {        if ((firsttargettype != dg_targettyperega) &&            (firsttargettype != dg_targettypereg))        {            dg_pusherror(pBHarrayhead, (const char*)"destination must be a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);            return;        }                // first target is destination        if (secondtarget.size == 0)        {            dg_pusherror(pBHarrayhead, (const char*)"source size must be specified, either 8BIT 16BIT 32BIT or 64BIT");            dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);            return;        }                firsttarget.size = secondtarget.size;  // destination is always 32 bits, to get it compile making the sizes equal    }    else    {        if ((secondtargettype != dg_targettyperega) &&            (secondtargettype != dg_targettypereg))        {            dg_pusherror(pBHarrayhead, (const char*)"destination must be a regular register");            dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);            return;        }                // second target is destination        if (firsttarget.size == 0)        {            dg_pusherror(pBHarrayhead, (const char*)"source size must be specified, either 8BIT 16BIT 32BIT or 64BIT");            dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);            return;        }                secondtarget.size = firsttarget.size; // destination is always 32 bits, to get it compile making the sizes equal    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiletwotargetsignoredestsizename);        return;    }}const char* dg_fillcrccommaoptblname = "dg_fillcrccommaoptbl";void dg_fillcrccommaoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    unsigned char* pr8prefixstring,    UINT64 pr8refixstringlength,    unsigned char* pr8opcodestring,    UINT64 r8opcodestringlength,    unsigned char* pr32prefixstring,    UINT64 pr32refixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        popcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_fillcrccommaoptblname);        return;    }        popcodes->m8tor8.prefixstringlength = pr8refixstringlength;        perror = dg_movebytes(        pr8prefixstring,        (unsigned char*)(&(popcodes->m8tor8.pprefixstring[0])),        pr8refixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillcrccommaoptblname);        return;    }        popcodes->m8tor8.opcodestringlength = r8opcodestringlength;        perror = dg_movebytes(        pr8opcodestring,        (unsigned char*)(&(popcodes->m8tor8.popcodestring[0])),        r8opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillcrccommaoptblname);        return;    }    popcodes->m8tor8.opcodeextension = (UINT64)-1;            popcodes->m32tor32.prefixstringlength = pr32refixstringlength;        perror = dg_movebytes(        pr32prefixstring,        (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),        pr32refixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillcrccommaoptblname);        return;    }        popcodes->m32tor32.opcodestringlength = r32opcodestringlength;        perror = dg_movebytes(        pr32opcodestring,        (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),        r32opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fillcrccommaoptblname);        return;    }    popcodes->m32tor32.opcodeextension = (UINT64)-1;}const char* dg_docrccommainstructionname = "dg_docrccommainstruction";void dg_docrccommainstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pr8prefixstring,    UINT64 r8prefixstringlength,    unsigned char* pr8opcodestring,    UINT64 r8opcodestringlength,    unsigned char* pr32prefixstring,    UINT64 r32prefixstringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fillcrccommaoptbl (        pBHarrayhead,        &myopcodes,        pr8prefixstring,        r8prefixstringlength,        pr8opcodestring,        r8opcodestringlength,        pr32prefixstring,        r32prefixstringlength,        pr32opcodestring,        r32opcodestringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_docrccommainstructionname);        return;    }        dg_pullandcompiletwotargetsignoredestsize (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_docrccommainstructionname);        return;    }}const char* dg_forthcrc32commaname = "CRC32,";void dg_forthcrc32comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_docrccommainstruction(        pBHarrayhead,        (unsigned char*)"\xF2", // pr8prefixstring,        1, // r8prefixstringlength        (unsigned char*)"\x0F\x38\xF0", // pr8opcodestring,        3, // r8opcodestringlength,        (unsigned char*)"\xF2", // pr32prefixstring,        1, // r32prefixstringlength        (unsigned char*)"\x0F\x38\xF1", // pr32opcodestring,        3); // r32opcodestringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcrc32commaname);        return;    }}const char* dg_fill2targetmorrtor32optblname = "dg_fill2targetmorrtor32optbl";void dg_fill2targetmorrtor32optbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        popcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_fill2targetmorrtor32optblname);        return;    }        popcodes->m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fill2targetmorrtor32optblname);        return;    }        popcodes->m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fill2targetmorrtor32optblname);        return;    }    popcodes->m32tor32.opcodeextension = (UINT64)-1;}const char* dg_domorrtor32instructionname = "dg_domorrtor32instruction";void dg_domorrtor32instruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmorrtor32optbl (        pBHarrayhead,        &myopcodes,        popcodestring,        opcodestringlength,        pprefixstring,        prefixstringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorrtor32instructionname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorrtor32instructionname);        return;    }}const char* dg_forthpopcntcommaname = "POPCNT,";void dg_forthpopcntcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorrtor32instruction(        pBHarrayhead,        (unsigned char*)"\x0F\xB8", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1); // prefixstringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpopcntcommaname);        return;    }}const char* dg_fill2targetrtomorroptblname = "dg_fill2targetrtomorroptbl";void dg_fill2targetrtomorroptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    unsigned char* pr8opcodestring,    UINT64 r8opcodestringlength,    unsigned char* pr32opcodestring,    UINT64 r32opcodestringlength){    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        popcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_fill2targetrtomorroptblname);        return;    }            popcodes->r8tom8.opcodestringlength = r8opcodestringlength;        perror = dg_movebytes(        pr8opcodestring,        (unsigned char*)(&(popcodes->r8tom8.popcodestring[0])),        r8opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fill2targetrtomorroptblname);        return;    }    popcodes->r8tom8.opcodeextension = (UINT64)-1;            popcodes->r32tom32.opcodestringlength = r32opcodestringlength;        perror = dg_movebytes(        pr32opcodestring,        (unsigned char*)(&(popcodes->r32tom32.popcodestring[0])),        r32opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_fill2targetrtomorroptblname);        return;    }    popcodes->r32tom32.opcodeextension = (UINT64)-1;}const char* dg_forthxaddcommaname = "XADD,";void dg_forthxaddcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetrtomorroptbl (        pBHarrayhead,        &myopcodes,        (unsigned char*)"\x0F\xC0", // pr8opcodestring,        2, // r8opcodestringlength,        (unsigned char*)"\x0F\xC1", // pr32opcodestring,        2); // r32opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack - forward destination            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack - forward source            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if (        ( (isreverse == FORTH_FALSE) &&          (secondtargettype == dg_targettypemem) ) ||        ( (isreverse != FORTH_FALSE) &&          (firsttargettype == dg_targettypemem) )       )    {        dg_pusherror(pBHarrayhead, (const char*)"source target for this instruction can not be memory");        dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);        return;    }        if (0 == firsttarget.size)    {        firsttarget.size = secondtarget.size;    }        if (0 == secondtarget.size)    {        secondtarget.size = firsttarget.size;    }        // this shouldn't happen because one of the targets is supposed to be a reg    /*    if ( (0 == firsttarget.size) &&         (0 == secondtarget.size) )    {        if (4 == addresssize)        {            // use default size dword            firsttarget.size = 4;            secondtarget.size = 4;        }        else        {            firsttarget.size = 8;            secondtarget.size = 8;        }                // I thinking this should be an error instead...        //dg_pusherror(pBHarrayhead, (const char*)"size for operation must be specified");        //dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);        //return;    }    */        if ((firsttargettype != dg_targettypemem) &&        (secondtargettype != dg_targettypemem) )    {        // it's register to register, because dg_compiletwotargets does not promote from mtor to rtom        //  when mtor is missing, and the default is mtor for rtor, have to make this reverse                // just in case the user specifies reverse... gonna do this so that the expected register is        //  the destination                if (isreverse == FORTH_FALSE)        {            dg_compilertom (                pBHarrayhead,                &myopcodes,                &secondtarget,                &firsttarget);        }        else        {            secondtarget.direction = 0;            firsttarget.direction = 0;                        dg_compilertom (                pBHarrayhead,                &myopcodes,                &firsttarget,                &secondtarget);        }                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);            return;        }                return;    }    if (isreverse == FORTH_FALSE)    {        dg_compilertom (            pBHarrayhead,            &myopcodes,            &secondtarget, // reg target            &firsttarget); // mem target    }    else    {        secondtarget.direction = 0;        firsttarget.direction = 0;                dg_compilertom (            pBHarrayhead,            &myopcodes,            &firsttarget, // reg target            &secondtarget); // mem target    }        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);        return;    }}const char* dg_forthmovnticommaname = "MOVNTI,";void dg_forthmovnticomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetrtomorroptbl (        pBHarrayhead,        &myopcodes,        (unsigned char*)"", // pr8opcodestring,        0, // r8opcodestringlength,        (unsigned char*)"\x0F\xC3", // pr32opcodestring,        2); // r32opcodestringlength);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack - forward destination            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack - forward source            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);        return;    }        if ( (firsttarget.direction != 0) ||         (secondtarget.direction != 0) )    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype( // top on stack - forward destination        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype( // second on stack - forward source        pBHarrayhead,        &secondtarget);        if (        ( (isreverse == FORTH_FALSE) &&          (secondtargettype == dg_targettypemem) ) ||        ( (isreverse != FORTH_FALSE) &&          (firsttargettype == dg_targettypemem) )       )    {        dg_pusherror(pBHarrayhead, (const char*)"source target for this instruction can not be memory");        dg_pusherror(pBHarrayhead, dg_forthxaddcommaname);        return;    }        if (0 == firsttarget.size)    {        firsttarget.size = secondtarget.size;    }        if (0 == secondtarget.size)    {        secondtarget.size = firsttarget.size;    }        if (isreverse == FORTH_FALSE)    {        if (firsttargettype != dg_targettypemem)        {            // it's register to register,            dg_pusherror(pBHarrayhead, (const char*)"destination target must be memory");            dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);            return;        }                if ((secondtarget.size != 4) &&            (secondtarget.size != 8))        {            // it's register to register,            dg_pusherror(pBHarrayhead, (const char*)"source register size must be 32 or 64 bits");            dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);            return;        }                dg_compilertom (            pBHarrayhead,            &myopcodes,            &secondtarget, // reg target            &firsttarget); // mem target    }    else    {        if (secondtargettype != dg_targettypemem)        {            // it's register to register,            dg_pusherror(pBHarrayhead, (const char*)"destination target must be memory");            dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);            return;        }                if ((firsttarget.size != 4) &&            (firsttarget.size != 8))        {            // it's register to register,            dg_pusherror(pBHarrayhead, (const char*)"source register size must be 32 or 64 bits");            dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);            return;        }                secondtarget.direction = 0;        firsttarget.direction = 0;                dg_compilertom (            pBHarrayhead,            &myopcodes,            &firsttarget, // reg target            &secondtarget); // mem target    }        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovnticommaname);        return;    }}const char* dg_filln8toxmmoptblname = "dg_filln8toxmmoptbl";void dg_filln8toxmmoptbl (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 opcodeextension){    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        popcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_filln8toxmmoptblname);        return;    }        popcodes->n8toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(popcodes->n8toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_filln8toxmmoptblname);        return;    }        popcodes->n8toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(popcodes->n8toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_filln8toxmmoptblname);        return;    }    popcodes->n8toxmm.opcodeextension = opcodeextension;}const char* dg_don8toxmminstructionname = "dg_don8toxmminstruction";void dg_don8toxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 opcodeextension){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_filln8toxmmoptbl (        pBHarrayhead,        &myopcodes,        popcodestring,        opcodestringlength,        pprefixstring,        prefixstringlength,        opcodeextension);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8toxmminstructionname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8toxmminstructionname);        return;    }}const char* dg_forthpsrldqcommaname = "PSRLDQ,";void dg_forthpsrldqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8toxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x73", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength        3); // opcode extension            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsrldqcommaname);        return;    }}const char* dg_pullandcompilefptomonlyname = "dg_pullandcompilefptomonly";void dg_pullandcompilefptomonly (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefptomonlyname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefptomonlyname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilefptomonlyname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (secondtargettype != dg_targettypefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a floating point reg");        dg_pusherror(pBHarrayhead, dg_pullandcompilefptomonlyname);        return;    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &secondtarget, // reg target        &firsttarget); // mem on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefptomonlyname);        return;    }}const char* dg_dofptomonlyinstructionname = "dg_dofptomonlyinstruction";void dg_dofptomonlyinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    unsigned char* popcodestring,    UINT64 opcodestringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dofptomonlyinstructionname);        return;    }        myopcodes.m64tofpr.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64tofpr.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dofptomonlyinstructionname);        return;    }        myopcodes.m64tofpr.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64tofpr.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dofptomonlyinstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = xmmmemtargetsize;        dg_pullandcompilefptomonly (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dofptomonlyinstructionname);        return;    }}const char* dg_forthmovntqcommaname = "MOVNTQ,";void dg_forthmovntqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_dofptomonlyinstruction(        pBHarrayhead,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        (unsigned char*)"\x0F\xE7", // popcodestring,        2, // opcodestringlength,        0); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovntqcommaname);        return;    }}const char* dg_pullandcompilefptoxmmname = "dg_pullandcompilefptoxmm";void dg_pullandcompilefptoxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefptoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefptoxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilefptoxmmname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (secondtargettype != dg_targettypefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a floating point register");        dg_pusherror(pBHarrayhead, dg_pullandcompilefptoxmmname);        return;    }        if (dg_targettypefpsreg == secondtargettype)    {        secondtarget.memmode = dg_memmodexmmreg; // going to use a regular morxmmtoxmm instruction    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefptoxmmname);        return;    }}const char* dg_dofptoxmminstructionname = "dg_dofptoxmminstruction";void dg_dofptoxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dofptoxmminstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dofptoxmminstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dofptoxmminstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = xmmmemtargetsize;        dg_pullandcompilefptoxmm (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dofptoxmminstructionname);        return;    }}const char* dg_forthmovq2dqcommaname = "MOVQ2DQ,";void dg_forthmovq2dqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_dofptoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD6", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1, // prefixstringlength,        0); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovq2dqcommaname);        return;    }}const char* dg_pullandcompilemorfptoxmmname = "dg_pullandcompilemorfptoxmm";void dg_pullandcompilemorfptoxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorfptoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorfptoxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorfptoxmmname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettypefpsreg) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a floating point reg or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorfptoxmmname);        return;    }        if (dg_targettypefpsreg == secondtargettype)    {        secondtarget.memmode = dg_memmodexmmreg; // going to use a regular morxmmtoxmm instruction    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorfptoxmmname);        return;    }}const char* dg_domorfptoxmminstructionname = "dg_domorfptoxmminstruction";void dg_domorfptoxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorfptoxmminstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorfptoxmminstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorfptoxmminstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = xmmmemtargetsize;        dg_pullandcompilemorfptoxmm (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorfptoxmminstructionname);        return;    }}const char* dg_forthcvtpi2pdcommaname = "CVTPI2PD,";void dg_forthcvtpi2pdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorfptoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2A", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtpi2pdcommaname);        return;    }}const char* dg_forthcvtpi2pscommaname = "CVTPI2PS,";void dg_forthcvtpi2pscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorfptoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2A", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtpi2pscommaname);        return;    }}const char* dg_pullandcompilemorxmmtofpname = "dg_pullandcompilemorxmmtofp";void dg_pullandcompilemorxmmtofp (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        if (firsttargettype != dg_targettypefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a floating point register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        if ((secondtargettype != dg_targettypexmmreg) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be an xmm register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        firsttarget.memmode = dg_memmodexmmreg; // going to use a regular morxmmtoxmm instruction        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }}const char* dg_domorxmmtofpinstructionname = "dg_domorxmmtofpinstruction";void dg_domorxmmtofpinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = xmmmemtargetsize;        dg_pullandcompilemorxmmtofp (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }}const char* dg_forthcvtps2picommaname = "CVTPS2PI,";void dg_forthcvtps2picomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtofpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2C", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtps2picommaname);        return;    }}const char* dg_forthcvttpd2picommaname = "CVTTPD2PI,";void dg_forthcvttpd2picomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtofpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2C", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvttpd2picommaname);        return;    }}const char* dg_forthcvttps2picommaname = "CVTTPS2PI,";void dg_forthcvttps2picomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtofpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2C", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvttps2picommaname);        return;    }}const char* dg_pullandcompilexmmtofpname = "dg_pullandcompilexmmtofp";void dg_pullandcompilexmmtofp (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        if (firsttargettype != dg_targettypefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a floating point register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        if (secondtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        firsttarget.memmode = dg_memmodexmmreg; // going to use a regular morxmmtoxmm instruction        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }}const char* dg_doxmmtofpinstructionname = "dg_doxmmtofpinstruction";void dg_doxmmtofpinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = 0;        dg_pullandcompilexmmtofp (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }}const char* dg_forthmovdq2qcommaname = "MOVDQ2Q,";void dg_forthmovdq2qcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmtofpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD6", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1); // prefixstringlength            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdq2qcommaname);        return;    }}const char* dg_pullandcompilexmmtoxmmname = "dg_pullandcompilexmmtoxmm";void dg_pullandcompilexmmtoxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        if (firsttargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        if (secondtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtofpname);        return;    }}const char* dg_doxmmtoxmminstructionname = "dg_doxmmtoxmminstruction";void dg_doxmmtoxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = 0;        dg_pullandcompilexmmtoxmm (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtofpinstructionname);        return;    }}const char* dg_forthmovhlpscommaname = "MOVHLPS,";void dg_forthmovhlpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x12", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0); // prefixstringlength            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovhlpscommaname);        return;    }}const char* dg_forthmovlhpscommaname = "MOVLHPS,";void dg_forthmovlhpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x16", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0); // prefixstringlength            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovlhpscommaname);        return;    }}const char* dg_pullandcompilemtofromxmmname = "dg_pullandcompilemtofromxmm";void dg_pullandcompilemtofromxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtofromxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtofromxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtofromxmmname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtofromxmmname);        return;    }        if ((firsttargettype == dg_targettypexmmreg) &&        (secondtargettype == dg_targettypexmmreg))    {        dg_pusherror(pBHarrayhead, (const char*)"one target for this instruction must be memory, the other an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemtofromxmmname);        return;    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemtofromxmmname);        return;    }}  const char* dg_domtofromxmminstructionname = "dg_domtofromxmminstruction";void dg_domtofromxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pforwardxmmopcodestring,    UINT64 forwardxmmopcodestringlength,    unsigned char* pforwardxmmprefixstring,    UINT64 forwardxmmprefixstringlength,    unsigned char* preversexmmopcodestring,    UINT64 reversexmmopcodestringlength,    unsigned char* preversexmmprefixstring,    UINT64 reversexmmprefixstringlength,    UINT64 usesxmmandmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtofromxmminstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = forwardxmmprefixstringlength;        perror = dg_movebytes(        pforwardxmmprefixstring,        (unsigned char*)myopcodes.m64toxmm.pprefixstring,        forwardxmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domtofromxmminstructionname);        return;    }            myopcodes.m64toxmm.opcodestringlength = forwardxmmopcodestringlength;        perror = dg_movebytes(        pforwardxmmopcodestring,        (unsigned char*)myopcodes.m64toxmm.popcodestring,        forwardxmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domtofromxmminstructionname);        return;    }            myopcodes.xmmtom64.prefixstringlength = reversexmmprefixstringlength;        perror = dg_movebytes(        preversexmmprefixstring,        (unsigned char*)myopcodes.xmmtom64.pprefixstring,        reversexmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domtofromxmminstructionname);        return;    }            myopcodes.xmmtom64.opcodestringlength = reversexmmopcodestringlength;        perror = dg_movebytes(        preversexmmopcodestring,        (unsigned char*)myopcodes.xmmtom64.popcodestring,        reversexmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domtofromxmminstructionname);        return;    }     myopcodes.usesxmmandmemtargetsize = usesxmmandmemtargetsize;        dg_pullandcompilemtofromxmm (        pBHarrayhead,        &myopcodes);             if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domtofromxmminstructionname);        return;    }}const char* dg_forthlddqucommaname = "LDDQU,";void dg_forthlddqucomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF0", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1, // prefixstringlength,        (unsigned char*)"", // popcodestring,        0, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength        16);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlddqucommaname);        return;    }}const char* dg_forthmovhpdcommaname = "MOVHPD,";void dg_forthmovhpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x16", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        (unsigned char*)"\x0F\x17", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovhpdcommaname);        return;    }}const char* dg_forthmovhpscommaname = "MOVHPS,";void dg_forthmovhpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x16", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        (unsigned char*)"\x0F\x17", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovhpscommaname);        return;    }}const char* dg_forthmovlpdcommaname = "MOVLPD,";void dg_forthmovlpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x12", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        (unsigned char*)"\x0F\x13", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovlpdcommaname);        return;    }}const char* dg_forthmovlpscommaname = "MOVLPS,";void dg_forthmovlpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x12", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        (unsigned char*)"\x0F\x13", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovlpscommaname);        return;    }}const char* dg_forthmovntdqacommaname = "MOVNTDQA,";void dg_forthmovntdqacomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x2A", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        (unsigned char*)"", // popcodestring,        0, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength        16);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovntdqacommaname);        return;    }}const char* dg_forthmovntdqcommaname = "MOVNTDQ,";void dg_forthmovntdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"", // popcodestring,        0, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        (unsigned char*)"\x0F\xE7", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength        16);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovntdqcommaname);        return;    }}const char* dg_forthmovntpdcommaname = "MOVNTPD,";void dg_forthmovntpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"", // popcodestring,        0, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        (unsigned char*)"\x0F\x2B", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength        16);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovntpdcommaname);        return;    }}const char* dg_forthmovntpscommaname = "MOVNTPS,";void dg_forthmovntpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domtofromxmminstruction(        pBHarrayhead,        (unsigned char*)"", // popcodestring,        0, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        (unsigned char*)"\x0F\x2B", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength        16);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovntpscommaname);        return;    }}const char* dg_copyfpropcodetom32name = "dg_copyfpropcodetom32";void dg_copyfpropcodetom32 (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    const char* perror;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        popcodes->m32tor32.prefixstringlength = popcodes->m64tofpr.prefixstringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->m64tofpr.pprefixstring[0])),        (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),        popcodes->m64tofpr.prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyfpropcodetom32name);        return;    }        popcodes->m32tor32.opcodestringlength = popcodes->m64tofpr.opcodestringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->m64tofpr.popcodestring[0])),        (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),        popcodes->m64tofpr.opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyfpropcodetom32name);        return;    }        popcodes->r32tom32.prefixstringlength = popcodes->fprtom64.prefixstringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->fprtom64.pprefixstring[0])),        (unsigned char*)(&(popcodes->r32tom32.pprefixstring[0])),        popcodes->m64tofpr.prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyfpropcodetom32name);        return;    }        popcodes->r32tom32.opcodestringlength = popcodes->fprtom64.opcodestringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->fprtom64.popcodestring[0])),        (unsigned char*)(&(popcodes->r32tom32.popcodestring[0])),        popcodes->m64tofpr.opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyfpropcodetom32name);        return;    }}const char* dg_copyxmmopcodetom32name = "dg_copyxmmopcodetom32";void dg_copyxmmopcodetom32 (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes){    const char* perror;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        popcodes->m32tor32.prefixstringlength = popcodes->m64toxmm.prefixstringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->m64toxmm.pprefixstring[0])),        (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),        popcodes->m64toxmm.prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyxmmopcodetom32name);        return;    }        popcodes->m32tor32.opcodestringlength = popcodes->m64toxmm.opcodestringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->m64toxmm.popcodestring[0])),        (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),        popcodes->m64toxmm.opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyxmmopcodetom32name);        return;    }        popcodes->r32tom32.prefixstringlength = popcodes->xmmtom64.prefixstringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->xmmtom64.pprefixstring[0])),        (unsigned char*)(&(popcodes->r32tom32.pprefixstring[0])),        popcodes->xmmtom64.prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyxmmopcodetom32name);        return;    }        popcodes->r32tom32.opcodestringlength = popcodes->xmmtom64.opcodestringlength;        perror = dg_movebytes(        (unsigned char*)(&(popcodes->xmmtom64.popcodestring[0])),        (unsigned char*)(&(popcodes->r32tom32.popcodestring[0])),        popcodes->xmmtom64.opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_copyxmmopcodetom32name);        return;    }}/*const char* dg_pullandcompilem64orrtofromfporxmmname = "dg_pullandcompilem64orrtofromfporxmm";void dg_pullandcompilem64orrtofromfporxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 defaultsize){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack xmm or fp for forward, m or r for reverse            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or r for forward, xmm or fp for reverse            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        // if first target (destination) is r/m32    if ((firsttargettype == dg_targettyperega) ||        (firsttargettype == dg_targettypereg) ||        (firsttargettype == dg_targettypemem))    {        if ((secondtargettype != dg_targettypexmmreg) &&            (secondtargettype != dg_targettypefpsreg))        {            dg_pusherror(pBHarrayhead, (const char*)"if second target is r or m then first must be fp or xmm");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                if (secondtargettype == dg_targettypexmmreg)        {            // copy m64toxmm to m32tor32            dg_copyxmmopcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }        else        {            // copy m64tofp to m32tor32            dg_copyfpropcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }                if (firsttarget.size == 0)        {            firsttarget.size = defaultsize;        }                if ((firsttarget.size != 0) &&            (firsttarget.size != 4) &&  // I'm going to allow users to specify 32 bit targets            (firsttarget.size != 8))        {            dg_pusherror(pBHarrayhead, (const char*)"only 32 and 64 bit memory and register targets are supported for this instruction");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                secondtarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction                secondtarget.size = firsttarget.size; // if second target was a reg, it's size is set                // xmm/mm is the source case        dg_compiletwotargets(            pBHarrayhead,            popcodes,             &secondtarget,              &firsttarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }    }    else if ((secondtargettype == dg_targettyperega) ||        (secondtargettype == dg_targettypereg) ||        (secondtargettype == dg_targettypemem))    {        if ((firsttargettype != dg_targettypexmmreg) &&            (firsttargettype != dg_targettypefpsreg))        {            dg_pusherror(pBHarrayhead, (const char*)"if first target is r or m then second must be fp or xmm");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                if (firsttargettype == dg_targettypexmmreg)        {            // copy m64toxmm to m32tor32            dg_copyxmmopcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }        else        {            // copy m64tofp to m32tor32            dg_copyfpropcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }                if (secondtarget.size == 0)        {            secondtarget.size = defaultsize;        }                if ((secondtarget.size != 0) &&            (secondtarget.size != 4) &&            (secondtarget.size != 8))        {            dg_pusherror(pBHarrayhead, (const char*)"only 32 and 64 bit memory and register targets are supported for this instruction");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                firsttarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction                firsttarget.size = secondtarget.size; // if second target was a reg, it's size is set                // xmm/mm is the destination case        dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget,            &secondtarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }    }    else    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be r or m and the other fp or xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);        return;    }}*/const char* dg_pullandcompilem64orrtofromfporxmmname = "dg_pullandcompilem64orrtofromfporxmm";void dg_pullandcompilem64orrtofromfporxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,    UINT64 defaultsize){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;    UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack xmm or fp for forward, m or r for reverse            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or r for forward, xmm or fp for reverse            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);        return;    }    if ((firsttarget.direction != 0) ||        (secondtarget.direction != 0))    {        isreverse = FORTH_TRUE;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        // if first target (destination) is r/m32    if ((firsttargettype == dg_targettyperega) ||        (firsttargettype == dg_targettypereg) ||        (firsttargettype == dg_targettypemem))    {        if ((secondtargettype != dg_targettypexmmreg) &&            (secondtargettype != dg_targettypefpsreg))        {            dg_pusherror(pBHarrayhead, (const char*)"if second target is r or m then first must be fp or xmm");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                if (secondtargettype == dg_targettypexmmreg)        {            // copy m64toxmm to m32tor32            dg_copyxmmopcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }        else        {            // copy m64tofp to m32tor32            dg_copyfpropcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }                if (firsttarget.size == 0)        {            firsttarget.size = defaultsize;        }                if ((firsttarget.size != 0) &&            (firsttarget.size != 4) &&  // I'm going to allow users to specify 32 bit targets            (firsttarget.size != 8))        {            dg_pusherror(pBHarrayhead, (const char*)"only 32 and 64 bit memory and register targets are supported for this instruction");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                secondtarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction                secondtarget.size = firsttarget.size; // if second target was a reg, it's size is set        // dg_compiletwotargets can not tell what direction to use for the register to register case  (2022 April 7 J.N.)        //  so you have to figure it out here or else dg_compiletwotargets may use the wrong opcode.        //  if it's rax->xmm then you want the forward opcode        //  if it's rax<-xmm then you want the reverse opcode        // xmm is the second target... at this point direction is backwards so you have to switch the direction        //  and swap the targets        if (FORTH_FALSE == isreverse)        {            firsttarget.direction = 1; // just need to do one...        }        else        {            firsttarget.direction = 0;            secondtarget.direction = 0;        }                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &secondtarget,            &firsttarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }    }    else if ((secondtargettype == dg_targettyperega) ||        (secondtargettype == dg_targettypereg) ||        (secondtargettype == dg_targettypemem))    {        if ((firsttargettype != dg_targettypexmmreg) &&            (firsttargettype != dg_targettypefpsreg))        {            dg_pusherror(pBHarrayhead, (const char*)"if first target is r or m then second must be fp or xmm");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                if (firsttargettype == dg_targettypexmmreg)        {            // copy m64toxmm to m32tor32            dg_copyxmmopcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }        else        {            // copy m64tofp to m32tor32            dg_copyfpropcodetom32 (                pBHarrayhead,                popcodes);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);                return;            }        }                if (secondtarget.size == 0)        {            secondtarget.size = defaultsize;        }                if ((secondtarget.size != 0) &&            (secondtarget.size != 4) &&            (secondtarget.size != 8))        {            dg_pusherror(pBHarrayhead, (const char*)"only 32 and 64 bit memory and register targets are supported for this instruction");            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }                firsttarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction                firsttarget.size = secondtarget.size; // if second target was a reg, it's size is set                dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget,            &secondtarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);            return;        }    }    else    {        dg_pusherror(pBHarrayhead, (const char*)"one target must be r or m and the other fp or xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilem64orrtofromfporxmmname);        return;    }}const char* dg_dom64orrtofromfporxmminstructionname = "dg_dom64orrtofromfporxmminstruction";void dg_dom64orrtofromfporxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pforwardmmopcodestring,    UINT64 forwardmmopcodestringlength,    unsigned char* preversemmopcodestring,    UINT64 reversemmopcodestringlength,    unsigned char* pforwardxmmprefixstring,    UINT64 forwardxmmprefixstringlength,    unsigned char* pforwardxmmopcodestring,    UINT64 forwardxmmopcodestringlength,    unsigned char* preversexmmprefixstring,    UINT64 reversexmmprefixstringlength,    unsigned char* preversexmmopcodestring,    UINT64 reversexmmopcodestringlength,    UINT64 defaultsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }        myopcodes.m64tofpr.opcodestringlength = forwardmmopcodestringlength;        perror = dg_movebytes(        pforwardmmopcodestring,        (unsigned char*)(&(myopcodes.m64tofpr.popcodestring[0])),        forwardmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }        myopcodes.fprtom64.opcodestringlength = reversemmopcodestringlength;        perror = dg_movebytes(        preversemmopcodestring,        (unsigned char*)(&(myopcodes.fprtom64.popcodestring[0])),        reversemmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }            myopcodes.m64toxmm.prefixstringlength = forwardxmmprefixstringlength;        perror = dg_movebytes(        pforwardxmmprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        forwardxmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = forwardxmmopcodestringlength;        perror = dg_movebytes(        pforwardxmmopcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        forwardxmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }            myopcodes.xmmtom64.prefixstringlength = reversexmmprefixstringlength;        perror = dg_movebytes(        preversexmmprefixstring,        (unsigned char*)(&(myopcodes.xmmtom64.pprefixstring[0])),        reversexmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }        myopcodes.xmmtom64.opcodestringlength = reversexmmopcodestringlength;        perror = dg_movebytes(        preversexmmopcodestring,        (unsigned char*)(&(myopcodes.xmmtom64.popcodestring[0])),        reversexmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }        dg_pullandcompilem64orrtofromfporxmm (        pBHarrayhead,        &myopcodes,        defaultsize); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dom64orrtofromfporxmminstructionname);        return;    }}const char* dg_forthmovdcommaname = "MOVD,";    void dg_forthmovdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dom64orrtofromfporxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x6E",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x7E",   // preversemmopcodestring,        2,                            // reversemmopcodestringlength,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x6E",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // preversexmmprefixstring,        1,                            // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x7E",   // preversexmmopcodestring,        2,                            // reversexmmopcodestringlength,        4);                           // defaultsize        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdcommaname);        return;    }}const char* dg_forthmovq2commaname = "MOVQ2,";    void dg_forthmovq2comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dom64orrtofromfporxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x6E",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x7E",   // preversemmopcodestring,        2,                            // reversemmopcodestringlength,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x6E",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // preversexmmprefixstring,        1,                            // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x7E",   // preversexmmopcodestring,        2,                            // reversexmmopcodestringlength,        8);                           // defaultsize        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovq2commaname);        return;    }}                                const char* dg_pullandcompilemorrtoxmmname = "dg_pullandcompilemorrtoxmm";void dg_pullandcompilemorrtoxmm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack xmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettyperega) &&        (secondtargettype != dg_targettypereg) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a regular 32 or 64 bit register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }        if ((secondtarget.size != 0) &&        (secondtarget.size != 4) &&        (secondtarget.size != 8))    {        dg_pusherror(pBHarrayhead, (const char*)"only 32 bit and 64 bit memory and register targets are supported for this instruction");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }            firsttarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction        firsttarget.size = secondtarget.size; // if second target was a reg, it's size is set    firsttarget.direction = 0;  // ignoring direction because of explicit target checks above    secondtarget.direction = 0;        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }}const char* dg_domorrtoxmminstructionname = "dg_domorrtoxmminstruction";void dg_domorrtoxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorrtoxmminstructionname);        return;    }        myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorrtoxmminstructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorrtoxmminstructionname);        return;    }        dg_pullandcompilemorrtoxmm (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorrtoxmminstructionname);        return;    }}const char* dg_forthcvtsi2sdcommaname = "CVTSI2SD,";void dg_forthcvtsi2sdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorrtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2A", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtsi2sdcommaname);        return;    }}const char* dg_forthcvtsi2sscommaname = "CVTSI2SS,";void dg_forthcvtsi2sscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorrtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2A", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtsi2sscommaname);        return;    }}const char* dg_pullandcompilen8morrtoxmmname = "dg_pullandcompilen8morrtoxmm";void dg_pullandcompilen8morrtoxmm (    Bufferhandle* pBHarrayhead,    UINT64 sourcetargetsize,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;    UINT64 thirdtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack xmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"third target pushed for this instruction must be xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettyperega) &&        (secondtargettype != dg_targettypereg) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a regular register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        // I think I'm going to ignore register size... but check to see if they specified the correct size...    /*    if ((secondtarget.size != 0) &&        (secondtarget.size != sourcetargetsize))    {        dg_pusherror(pBHarrayhead, (const char*)"if a source size is specified for this instruction, it must be the correct one.");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }    */        // forcing source size to 32 unless it's a 64 bit source... need 64 for REX.W    if (sourcetargetsize != 8)    {        secondtarget.size = 4;    }    else    {        secondtarget.size = 8;    }        firsttarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction    firsttarget.size = secondtarget.size;        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        thirdtargettype = dg_gettargettype(        pBHarrayhead,        &thirdtarget);        if (thirdtargettype != dg_targettypeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be immediate");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        if ((thirdtarget.immediatesize != 1) &&        (thirdtarget.immediatesize != 0))    {        dg_pusherror(pBHarrayhead, (const char*)"The size of the immediate value for this instruction is 1 byte. If you specify the minimum immediate size, it must be zero or one. E.g. mybytevalue 1 IMMEDIATE.");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        // really just need to do the r/mem target    firsttarget.immediatesize = 1;    firsttarget.immediatevalue = thirdtarget.immediatevalue;    secondtarget.immediatesize = 1;    secondtarget.immediatevalue = thirdtarget.immediatevalue;        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }}const char* dg_don8morrtoxmminstructionname = "dg_don8morrtoxmminstruction";void dg_don8morrtoxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 sourcetargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8morrtoxmminstructionname);        return;    }        myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8morrtoxmminstructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8morrtoxmminstructionname);        return;    }        dg_pullandcompilen8morrtoxmm (        pBHarrayhead,        sourcetargetsize,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8morrtoxmminstructionname);        return;    }}const char* dg_forthpinsrbcommaname = "PINSRB,";void dg_forthpinsrbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8morrtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x20", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        1); // source target size            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpinsrbcommaname);        return;    }}const char* dg_forthpinsrdcommaname = "PINSRD,";void dg_forthpinsrdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8morrtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x22", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        4); // source target size            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpinsrdcommaname);        return;    }}const char* dg_forthpinsrqcommaname = "PINSRQ,";void dg_forthpinsrqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8morrtoxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x22", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        8); // source target size            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpinsrqcommaname);        return;    }}const char* dg_pullandcompilen8morrtofporxmmname = "dg_pullandcompilen8morrtofporxmm";void dg_pullandcompilen8morrtofporxmm (    Bufferhandle* pBHarrayhead,    unsigned char* pfpopcodestring,    UINT64 fpopcodestringlength,    unsigned char* pxmmprefixstring,    UINT64 xmmprefixstringlength,    unsigned char* pxmmopcodestring,    UINT64 xmmopcodestringlength,    UINT64 sourcetargetsize){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;    UINT64 thirdtargettype;        struct Twotargetopcodestrings myopcodes;    const char* perror;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack xmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettypexmmreg) &&        (firsttargettype != dg_targettypefpsreg))    {        dg_pusherror(pBHarrayhead, (const char*)"third target pushed for this instruction must be fp or xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettyperega) &&        (secondtargettype != dg_targettypereg) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a regular register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        // I think I'm going to ignore register size... but check to see if they specified the correct size...    /*    if ((secondtarget.size != 0) &&        (secondtarget.size != sourcetargetsize))    {        dg_pusherror(pBHarrayhead, (const char*)"if a source size is specified for this instruction, it must be the correct one.");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorrtoxmmname);        return;    }    */        // forcing source size to 32 unless it's a 64 bit source... need 64 for REX.W    if (sourcetargetsize != 8)    {        secondtarget.size = 4;    }    else    {        secondtarget.size = 8;    }        firsttarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction    firsttarget.size = secondtarget.size;        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        thirdtargettype = dg_gettargettype(        pBHarrayhead,        &thirdtarget);        if (thirdtargettype != dg_targettypeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be immediate");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        if ((thirdtarget.immediatesize != 1) &&        (thirdtarget.immediatesize != 0))    {        dg_pusherror(pBHarrayhead, (const char*)"The size of the immediate value for this instruction is 1 byte. If you specify the minimum immediate size, it must be zero or one. E.g. mybytevalue 1 IMMEDIATE.");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        // really just need to do the r/mem target    firsttarget.immediatesize = 1;    firsttarget.immediatevalue = thirdtarget.immediatevalue;    secondtarget.immediatesize = 1;    secondtarget.immediatevalue = thirdtarget.immediatevalue;            dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }        if (firsttargettype == dg_targettypexmmreg)    {        myopcodes.m32tor32.prefixstringlength = xmmprefixstringlength;                perror = dg_movebytes(            pxmmprefixstring,            (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),            xmmprefixstringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);            return;        }                myopcodes.m32tor32.opcodestringlength = xmmopcodestringlength;                perror = dg_movebytes(            pxmmopcodestring,            (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),            xmmopcodestringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);            return;        }    }    else    {        myopcodes.m32tor32.opcodestringlength = fpopcodestringlength;                perror = dg_movebytes(            pfpopcodestring,            (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),            fpopcodestringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);            return;        }    }        dg_compiletwotargets (        pBHarrayhead,        &myopcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8morrtoxmmname);        return;    }}const char* dg_forthpinsrwcommaname = "PINSRW,";void dg_forthpinsrwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompilen8morrtofporxmm(        pBHarrayhead,        (unsigned char*)"\x0F\xC4", // pfpopcodestring,        2, // fpopcodestringlength,        (unsigned char*)"\x66", // pxmmprefixstring,        1, // xmmprefixstringlength,        (unsigned char*)"\x0F\xC4", // pxmmopcodestring,        2, // xmmopcodestringlength,        2); // source target size            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpinsrqcommaname);        return;    }}const char* dg_pullandcompilexmmtorname = "dg_pullandcompilexmmtor";void dg_pullandcompilexmmtor (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmtorname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or xmmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmtorname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (secondtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmtorname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettyperega) &&        (firsttargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a regular 32 or 64 bit register");        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmtorname);        return;    }        if ((firsttarget.size != 4) &&        (firsttarget.size != 8))    {        dg_pusherror(pBHarrayhead, (const char*)"only 32 bit and 64 bit destination register targets are supported for this instruction");        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmtorname);        return;    }        if (secondtargettype == dg_targettypexmmreg)    {        secondtarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction    }        // rex ignored for these instructions...    //   in 64 bit mode the default size is 64 bits    firsttarget.size = 4;    secondtarget.size = 4;    dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmtorname);        return;    }}const char* dg_doxmmtorinstructionname = "dg_doxmmtorinstruction";void dg_doxmmtorinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmtorinstructionname);        return;    }        myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmtorinstructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmtorinstructionname);        return;    }        dg_pullandcompilexmmtor (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmtorinstructionname);        return;    }}const char* dg_forthmovmskpdcommaname = "MOVMSKPD,";void dg_forthmovmskpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmtorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x50", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovmskpdcommaname);        return;    }}const char* dg_forthmovmskpscommaname = "MOVMSKPS,";void dg_forthmovmskpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmtorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x50", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovmskpscommaname);        return;    }}const char* dg_pullandcompilemorxmmtorname = "dg_pullandcompilemorxmmtor";void dg_pullandcompilemorxmmtor (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or xmmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettypexmmreg) &&        (firsttargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be xmm or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettyperega) &&        (firsttargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a regular 32 or 64 bit register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        if ((firsttarget.size != 4) &&        (firsttarget.size != 8))    {        dg_pusherror(pBHarrayhead, (const char*)"only 32 bit and 64 bit destination register targets are supported for this instruction");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        if (secondtargettype == dg_targettypexmmreg)    {        secondtarget.memmode = dg_memmodereg; // going to use a regular morrtor instruction    }        secondtarget.size = firsttarget.size; // if second target was a reg, it's size is set        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }}const char* dg_domorxmmtorinstructionname = "dg_domorxmmtorinstruction";void dg_domorxmmtorinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtorinstructionname);        return;    }        myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtorinstructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_domorxmmtorinstructionname);        return;    }        dg_pullandcompilemorxmmtor (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_domorxmmtorinstructionname);        return;    }}const char* dg_forthcvtsd2sicommaname = "CVTSD2SI,";void dg_forthcvtsd2sicomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2D", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtsd2sicommaname);        return;    }}const char* dg_forthcvtss2sicommaname = "CVTSS2SI,";void dg_forthcvtss2sicomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2D", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtss2sicommaname);        return;    }}const char* dg_forthcvttsd2sicommaname = "CVTTSD2SI,";void dg_forthcvttsd2sicomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2C", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvttsd2sicommaname);        return;    }}const char* dg_forthcvttss2sicommaname = "CVTTSS2SI,";void dg_forthcvttss2sicomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2C", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvttss2sicommaname);        return;    }}const char* dg_pullandcompilexmmorfptorname = "dg_pullandcompilexmmorfptor";void dg_pullandcompilexmmorfptor (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        const char* perror;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or xmmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettypexmmreg) &&        (secondtargettype != dg_targettypefpsreg))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be an xmm or floating point register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettyperega) &&        (firsttargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a regular 32 or 64 bit register");        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }        if (firsttarget.memmode == dg_memmodereg)    {        // user specified R. This is to allow rex.w if the user specified R.        if (firsttarget.size != 8)        {            firsttarget.size = 4;        }    }    else    {        firsttarget.size = 4;    }        if (secondtargettype == dg_targettypexmmreg)    {        popcodes->m32tor32.prefixstringlength = popcodes->m64toxmm.prefixstringlength;                perror = dg_movebytes(            (unsigned char*)(&(popcodes->m64toxmm.pprefixstring[0])),            (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),            popcodes->m64toxmm.prefixstringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);            return;        }                popcodes->m32tor32.opcodestringlength = popcodes->m64toxmm.opcodestringlength;            perror = dg_movebytes(            (unsigned char*)(&(popcodes->m64toxmm.popcodestring[0])),            (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),            popcodes->m64toxmm.opcodestringlength);            if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);            return;        }    }    else    {        popcodes->m32tor32.prefixstringlength = popcodes->m64tofpr.prefixstringlength;                perror = dg_movebytes(            (unsigned char*)(&(popcodes->m64tofpr.pprefixstring[0])),            (unsigned char*)(&(popcodes->m32tor32.pprefixstring[0])),            popcodes->m64tofpr.prefixstringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);            return;        }                popcodes->m32tor32.opcodestringlength = popcodes->m64tofpr.opcodestringlength;                perror = dg_movebytes(            (unsigned char*)(&(popcodes->m64tofpr.popcodestring[0])),            (unsigned char*)(&(popcodes->m32tor32.popcodestring[0])),            popcodes->m64tofpr.opcodestringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);            return;        }    }        secondtarget.memmode = firsttarget.memmode; // going to use a regular m/r instruction        // using the size of the regular register    secondtarget.size = firsttarget.size; // if second target was a reg, it's size is set        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilemorxmmtorname);        return;    }}const char* dg_doxmmrorfptorinstructionname = "dg_doxmmrorfptorinstruction";void dg_doxmmrorfptorinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pfpopcodestring,    UINT64 fpopcodestringlength,    unsigned char* pxmmopcodestring,    UINT64 xmmopcodestringlength,    unsigned char* pxmmprefixstring,    UINT64 xmmprefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmrorfptorinstructionname);        return;    }        myopcodes.m64tofpr.opcodestringlength = fpopcodestringlength;        perror = dg_movebytes(        pfpopcodestring,        (unsigned char*)(&(myopcodes.m64tofpr.popcodestring[0])),        fpopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmrorfptorinstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = xmmprefixstringlength;        perror = dg_movebytes(        pxmmprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        xmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmrorfptorinstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = xmmopcodestringlength;        perror = dg_movebytes(        pxmmopcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        xmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmrorfptorinstructionname);        return;    }        dg_pullandcompilexmmorfptor (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmrorfptorinstructionname);        return;    }}const char* dg_forthpmovmskbcommaname = "PMOVMSKB,";void dg_forthpmovmskbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrorfptorinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD7",   // pfpopcodestring,        2,                            // fpopcodestringlength,        (unsigned char*)"\x0F\xD7",   // pxmmopcodestring,        2,                            // xmmopcodestringlength,        (unsigned char*)"\x66",       // pxmmprefixstring,        1);                           // xmmprefixstringlength)            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovmskbcommaname);        return;    }}const char* dg_pullandcompiler16tom16orr16name = "dg_pullandcompiler16tom16orr16";void dg_pullandcompiler16tom16orr16 (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or xmmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettyperega) &&        (secondtargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a 16 bit register");        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }        if (secondtarget.size != 2)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a 16 bit register");        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettyperega) &&        (firsttargettype != dg_targettypereg) &&        (firsttargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a regular 16 bit register or 16 bit memory");        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }        if ((firsttarget.size != 0) &&        (firsttarget.size != 2))    {        dg_pusherror(pBHarrayhead, (const char*)"only 16 bit memory and register targets are supported for this instruction");        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }        // so we won't get the 0x66 prefix    firsttarget.size = 4;    secondtarget.size = 4; // if first target was a reg, it's size is set    dg_compiletwotargets (        pBHarrayhead,        popcodes,        &secondtarget, // r target        &firsttarget); // r/m target        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiler16tom16orr16name);        return;    }}const char* dg_dor16tom16orr16instructionname = "dg_dor16tom16orr16instruction";void dg_dor16tom16orr16instruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dor16tom16orr16instructionname);        return;    }        myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dor16tom16orr16instructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dor16tom16orr16instructionname);        return;    }        dg_pullandcompiler16tom16orr16 (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dor16tom16orr16instructionname);        return;    }}const char* dg_fortharplcommaname = "ARPL,";void dg_fortharplcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // technically it's a 32 bit mode only instruction...        dg_dor16tom16orr16instruction(        pBHarrayhead,        (unsigned char*)"\x63", // popcodestring,        1, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_fortharplcommaname);        return;    }}const char* dg_pullandcompiler16orm16tor16name = "dg_pullandcompiler16orm16tor16";void dg_pullandcompiler16orm16tor16 (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack r            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiler16orm16tor16name);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack m or xmmm            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiler16orm16tor16name);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettyperega) &&        (firsttargettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a register, only the lower 16 bits are used");        dg_pusherror(pBHarrayhead, dg_pullandcompiler16orm16tor16name);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettyperega) &&        (secondtargettype != dg_targettypereg) &&        (secondtargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a register or memory, only the lower 16 bits are used");        dg_pusherror(pBHarrayhead, dg_pullandcompiler16orm16tor16name);        return;    }        // so we won't get the 0x66 prefix... gonna ignore data size    firsttarget.size = 4;    secondtarget.size = 4; // if first target was a reg, it's size is set    dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // r target        &secondtarget); // r/m target        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiler16orm16tor16name);        return;    }}const char* dg_dor16orm16tor16instructionname = "dg_dor16orm16tor16instruction";void dg_dor16orm16tor16instruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dor16orm16tor16instructionname);        return;    }        myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dor16orm16tor16instructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dor16orm16tor16instructionname);        return;    }        dg_pullandcompiler16orm16tor16 (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dor16orm16tor16instructionname);        return;    }}const char* dg_forthlslcommaname = "LSL,";void dg_forthlslcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // technically it's a 32 bit mode only instruction...        dg_dor16orm16tor16instruction(        pBHarrayhead,        (unsigned char*)"\x0F\x03", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0); // prefixstringlength,            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlslcommaname);        return;    }}const char* dg_pullandcompilen8xmmtorormname = "dg_pullandcompilen8xmmtororm";void dg_pullandcompilen8xmmtororm (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes,  // kinda overkill when there is only one choice...    UINT64 rormsize){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        UINT64 thirdtargettype; // first pushed    UINT64 secondtargettype; // second pushed    UINT64 firsttargettype; // third pushed            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        thirdtargettype = dg_gettargettype(        pBHarrayhead,        &thirdtarget);        if (thirdtargettype != dg_targettypeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be immediate");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        if ((thirdtarget.immediatesize != 1) &&        (thirdtarget.immediatesize != 0))    {        dg_pusherror(pBHarrayhead, (const char*)"The size of the immediate value for this instruction is 1 byte. If you specify the minimum immediate size, it must be zero or one. E.g. mybytevalue 1 IMMEDIATE.");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (secondtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be an xmm register");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if ((firsttargettype != dg_targettyperega) &&        (firsttargettype != dg_targettypereg) &&        (firsttargettype != dg_targettypemem))    {        dg_pusherror(pBHarrayhead, (const char*)"third target pushed for this instruction must be a regular register or memory");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        // ignoring direction because of the explicet target type checks above    firsttarget.direction = 0;    secondtarget.direction = 0;        // really just need to do the r/mem target    firsttarget.immediatesize = 1;    firsttarget.immediatevalue = thirdtarget.immediatevalue;    secondtarget.immediatesize = 1;    secondtarget.immediatevalue = thirdtarget.immediatevalue;        secondtarget.memmode = dg_memmodereg; // changing mode to regular reg so rex size will work                                          //  if destination is specified using R and is 64 bits                                          // even though REX.W is ignored in 64 bit mode                                          // (I want to allow the user a way to force the rex encoding)        // if we have an expected size....    if (rormsize != (UINT64)-1)    {        // if the user declares the size of the memory target, and expected size is known,        //  it must match, otherwise the memory size is ignored.        if (firsttargettype == dg_targettypemem)        {            if (firsttarget.size != 0)  // user explicitly declared the memory size            {                if (firsttarget.size != rormsize)                {                    dg_pusherror(pBHarrayhead, (const char*)"size of memory target does not match the size for this instruction");                    dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);                    return;                }            }        }                // if it's default reg, ignore the register size and use the expected data size        //  to determine if you are using rex.w        //  so expected size    size passed to compiling subroutine        //   1                   4        //   2                   4        //   4                   4        //   8                   8        if (firsttarget.memmode == dg_memmodedefaultreg)        {            if (rormsize == 8)            {                firsttarget.size = 8;            }            else            {                firsttarget.size = 4;            }        }                // if it's reg, the user picked R... to allow rex.w with PEXTRB I'm doing this:        //  gonna assume the user knows what they are doing...        //  since there is already a 0x66 prefix... you can't use that so still gonna        //  rule out 16 bit regs...        if (firsttarget.memmode == dg_memmodereg)        {            if (firsttarget.size == 2)            {                dg_pusherror(pBHarrayhead, (const char*)"16 bit regs not supported. I'm guessing you want to try this instruction with the 0x66 16 bit prefix, but this instruction already has a 0x66 prefix so you can't.");                dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);                return;            }                        if (firsttarget.size == 1)            {                firsttarget.size = 4; // still have to change 1 to 4 for PEXTRB            }                        // making sure PEXTRQ size is 8 so that it will get rex.w            if ((rormsize == 8) && (firsttarget.size != 8))            {                dg_pusherror(pBHarrayhead, (const char*)"must use a 64 bit register for the destination");                dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);                return;            }                        // if rormsize == 4 then it is EXTRACTPS or PEXTRD...            // EXTRACTPS is allowed to have the rex.w prefix but it will be ignored...            // to allow the user to specify they want the prefix for EXTRACTPS... I'm going to            // not do anything here... but this means the user can turn PEXTRD into PEXTRQ using R            // 3/30/2020        }    }    else    {        dg_pusherror(pBHarrayhead, (const char*)"This is a programming error. Expected rormsize must be specified.");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }        if (firsttarget.memmode != dg_memmodereg) // if the user specifically requested a reg using R                                           //  then this will allow the use of REX for PEXTRB    {        // if it's a default reg target, I want to ingore the reg size so the user can put in anything        //  this is because PEXTRB intel doc shows both 32 and 64 bit destination register targets        //  when the data size moved is a byte.        if ((firsttargettype == dg_targettyperega) ||            (firsttargettype == dg_targettypereg))        {            // still have to let PEXTRQ have size 8 for rex..., this should do it...            firsttarget.size = rormsize;        }                if (firsttarget.size == 0)        {            firsttarget.size = rormsize;        }                    }    else    {        // R declared case, gonna assume the user knows what they are doing...        if (rormsize == (UINT64)-1)        {                            firsttarget.size = 4; // in 64 bit mode, default size is 8 but only lower 4 is used, upper 4 gets cleared        }        else        {            firsttarget.size = 4;        }    }            if (firsttarget.size == 1)    {        firsttarget.size = 4; // so that PEXTRB will use rtom32    }        secondtarget.size = firsttarget.size;        if (firsttargettype != dg_targettypemem)    {        // r to r case        dg_compiletwotargets (            pBHarrayhead,            popcodes,            &secondtarget, // second on stack            &firsttarget); // top on stack    }    else    {        // r to m case        dg_compiletwotargets (            pBHarrayhead,            popcodes,            &firsttarget, // top on stack            &secondtarget); // second on stack    }        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8xmmtorormname);        return;    }}const char* dg_don8xmmrtororminstructionname = "dg_don8xmmrtororminstruction";void dg_don8xmmrtororminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 rormsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8xmmrtororminstructionname);        return;    }        // for the r to r case... m to r is an error and checked in dg_pullandcompilen8xmmtororm    myopcodes.m32tor32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m32tor32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrtororminstructionname);        return;    }        myopcodes.m32tor32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m32tor32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrtororminstructionname);        return;    }        // for the regular r to m case    myopcodes.r32tom32.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.r32tom32.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrtororminstructionname);        return;    }        myopcodes.r32tom32.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.r32tom32.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrtororminstructionname);        return;    }        dg_pullandcompilen8xmmtororm (        pBHarrayhead,        &myopcodes,        rormsize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8xmmrtororminstructionname);        return;    }}const char* dg_forthextractpscommaname = "EXTRACTPS,";void dg_forthextractpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrtororminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x17", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength);        4); // both 4 and 8 are allowed for reg, except rex is not used for 8 and size is 4            // user will only get rex.w if they use R with a 64 bit register.            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthextractpscommaname);        return;    }}const char* dg_forthpextrbcommaname = "PEXTRB,";void dg_forthpextrbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrtororminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x14", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        1); // rormsize            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrbcommaname);        return;    }}const char* dg_forthpextrdcommaname = "PEXTRD,";void dg_forthpextrdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrtororminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x16", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength);        4); // rormsize            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrdcommaname);        return;    }}const char* dg_forthpextrqcommaname = "PEXTRQ,";void dg_forthpextrqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrtororminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x16", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrqcommaname);        return;    }}// reverse ignored - targets must be in forward orderconst char* dg_forthpextrwcommaname = "PEXTRW,";void dg_forthpextrwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;    const char* perror;     dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        UINT64 thirdtargettype; // first pushed    UINT64 secondtargettype; // second pushed    UINT64 firsttargettype; // third pushed     unsigned char* pfpopcodestring = (unsigned char*)"\x0F\xC5"; // fp to r16    UINT64 fpopcodestringlength = 2;    unsigned char* pxmmprefixstring = (unsigned char*)"\x66"; // xmm prefix for both    UINT64 xmmprefixstringlength = 1;    unsigned char* pxmmopcodestring = (unsigned char*)"\x0F\xC5"; // default xmm to r16    UINT64 xmmopcodestringlength = 2;    unsigned char* pnewxmmopcodestring = (unsigned char*)"\x0F\x3A\x15"; // if xmm to m16 or it's xmm to r16 with user specifying r    UINT64 newxmmopcodestringlength = 3;    UINT64 rormsize = 2;      UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);      if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (           pBHarrayhead,           &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        thirdtargettype = dg_gettargettype(        pBHarrayhead,        &thirdtarget);        if (thirdtargettype != dg_targettypeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be immediate");        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        if ((thirdtarget.immediatesize != 1) &&        (thirdtarget.immediatesize != 0))    {        dg_pusherror(pBHarrayhead, (const char*)"The size of the immediate value for this instruction is 1 byte. If you specify the minimum immediate size, it must be zero or one. E.g. mybytevalue 1 IMMEDIATE.");        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if ((secondtargettype != dg_targettypexmmreg) &&        (secondtargettype != dg_targettypefpsreg))    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a fp or xmm register");        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (secondtargettype == dg_targettypexmmreg)    {        if ((firsttargettype != dg_targettyperega) &&            (firsttargettype != dg_targettypereg) &&            (firsttargettype != dg_targettypemem))        {            dg_pusherror(pBHarrayhead, (const char*)"third target pushed for this instruction must be a regular register or memory");            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }    }    else    {        if ((firsttargettype != dg_targettyperega) &&            (firsttargettype != dg_targettypereg))        {            dg_pusherror(pBHarrayhead, (const char*)"third target pushed for this instruction must be a regular register");            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }    }        // really just need to do the r/mem target    firsttarget.immediatesize = 1;    firsttarget.immediatevalue = thirdtarget.immediatevalue;    secondtarget.immediatesize = 1;    secondtarget.immediatevalue = thirdtarget.immediatevalue;        secondtarget.memmode = dg_memmodereg; // just using the reg opcode        if (firsttarget.size == 0)    {        firsttarget.size = rormsize;    }        if (firsttarget.size != rormsize)    {        dg_pusherror(pBHarrayhead, (const char*)"size of third target (register or memory) does not match the size for this instruction");        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        secondtarget.size = 4; // making size 4 so an extra 0x66 prefix won't be added    firsttarget.size = 4;  // making size 4 so an extra 0x66 prefix won't be added        // need to copy correct opcode to r to m    // if fp to m then give error    // if fp to r then copy to fp to r to m    // if xmm to m then copy to new xmm to r to m    // if xmm to R then copy new xmm to r to m    // if xmm to default r then copy old xmm to r to m        if (secondtargettype == dg_targettypefpsreg)    {        myopcodes.r32tom32.opcodestringlength = fpopcodestringlength;                    perror = dg_movebytes(                pfpopcodestring,                (unsigned char*)(&(myopcodes.r32tom32.popcodestring[0])),                fpopcodestringlength);                    if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }                secondtarget.direction = 0;        firsttarget.direction = 0;                    dg_compilertom (            pBHarrayhead,            &myopcodes,            &firsttarget, // r target            &secondtarget); // fp or xmm target                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }                return;    }        // both xmm opcodes use the same prefix    myopcodes.r32tom32.prefixstringlength = xmmprefixstringlength;        perror = dg_movebytes(        pxmmprefixstring,        (unsigned char*)(&(myopcodes.r32tom32.pprefixstring[0])),        xmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);        return;    }        if ((firsttargettype == dg_targettypemem) || // mem target or        (firsttarget.memmode == dg_memmodereg))  // user specified R    {        myopcodes.r32tom32.opcodestringlength = newxmmopcodestringlength;                perror = dg_movebytes(            pnewxmmopcodestring,            (unsigned char*)(&(myopcodes.r32tom32.popcodestring[0])),            newxmmopcodestringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }                if (firsttargettype != dg_targettypemem)        {            // r to r user specified R case            secondtarget.direction = 0;            firsttarget.direction = 0;                        dg_compilertom (                pBHarrayhead,                &myopcodes,                &secondtarget, // r target                &firsttarget); // fp or xmm target        }        else        {            // r to m case            secondtarget.direction = 0;            firsttarget.direction = 0;                        dg_compilertom (                pBHarrayhead,                &myopcodes,                &secondtarget, // fp or xmm target                &firsttarget); // m target        }                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }    }    else    {        myopcodes.r32tom32.opcodestringlength = xmmopcodestringlength;                perror = dg_movebytes(            pxmmopcodestring,            (unsigned char*)(&(myopcodes.r32tom32.popcodestring[0])),            xmmopcodestringlength);                if (perror != dg_success)        {            dg_pusherror(pBHarrayhead, dg_movebytesname);            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }                // r to r case        secondtarget.direction = 0;        firsttarget.direction = 0;                    dg_compilertom (            pBHarrayhead,            &myopcodes,            &firsttarget, // r target            &secondtarget); // fp or xmm target                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthpextrwcommaname);            return;        }    }} const char* dg_don8orxmmorfpinstructionname = "dg_don8orxmmorfpinstruction";void dg_don8orxmmorfpinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pforwardmmopcodestring,    UINT64 forwardmmopcodestringlength,    unsigned char* pforwardimmediatemmopcodestring,    UINT64 forwardimmediatemmopcodestringlength,    UINT64 forwardimmediatemmopcodeextension,    unsigned char* pforwardxmmprefixstring,    UINT64 forwardxmmprefixstringlength,    unsigned char* pforwardxmmopcodestring,    UINT64 forwardxmmopcodestringlength,    unsigned char* pforwardimmediatexmmprefixstring,    UINT64 forwardimmediatexmmprefixstringlength,    unsigned char* pforwardimmediatexmmopcodestring,    UINT64 forwardimmediatexmmopcodestringlength,    UINT64 forwardimmediatexmmopcodeextension){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);        return;    }        // forward m64 to fp opcode    myopcodes.m64tofpr.opcodestringlength = forwardmmopcodestringlength;        perror = dg_movebytes(        pforwardmmopcodestring,        (unsigned char*)(&(myopcodes.m64tofpr.popcodestring[0])),        forwardmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);        return;    }        // forward n8 to fp opcode    myopcodes.n8tofpr.opcodestringlength = forwardimmediatemmopcodestringlength;        perror = dg_movebytes(        pforwardimmediatemmopcodestring,        (unsigned char*)(&(myopcodes.n8tofpr.popcodestring[0])),        forwardimmediatemmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);        return;    }        myopcodes.n8tofpr.opcodeextension = forwardimmediatemmopcodeextension;         // forward m64 to xmm prefix    myopcodes.m64toxmm.prefixstringlength = forwardxmmprefixstringlength;     perror = dg_movebytes(        pforwardxmmprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        forwardxmmprefixstringlength);     if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);        return;    }        // forward m64 to xmm opcode    myopcodes.m64toxmm.opcodestringlength = forwardxmmopcodestringlength;        perror = dg_movebytes(        pforwardxmmopcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        forwardxmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);        return;    }        // forward n8 to xmm prefix    myopcodes.n8toxmm.prefixstringlength = forwardimmediatexmmprefixstringlength;           perror = dg_movebytes(           pforwardimmediatexmmprefixstring,           (unsigned char*)(&(myopcodes.n8toxmm.pprefixstring[0])),           forwardimmediatexmmprefixstringlength);           if (perror != dg_success)       {           dg_pusherror(pBHarrayhead, dg_movebytesname);           dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);           return;       }              // forward n8 to xmm opcode       myopcodes.n8toxmm.opcodestringlength = forwardimmediatexmmopcodestringlength;              perror = dg_movebytes(           pforwardimmediatexmmopcodestring,           (unsigned char*)(&(myopcodes.n8toxmm.popcodestring[0])),           forwardimmediatexmmopcodestringlength);              if (perror != dg_success)       {           dg_pusherror(pBHarrayhead, dg_movebytesname);           dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);           return;       }        myopcodes.n8toxmm.opcodeextension = forwardimmediatexmmopcodeextension;        dg_pullandcompiletwotargets(        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8orxmmorfpinstructionname);        return;    }}const char* dg_forthpsllwcommaname = "PSLLW,";    void dg_forthpsllwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF1",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x71",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        6,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xF1",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x71",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        6);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsllwcommaname);        return;    }}const char* dg_forthpslldcommaname = "PSLLD,";    void dg_forthpslldcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF2",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x72",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        6,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xF2",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x72",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        6);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpslldcommaname);        return;    }}const char* dg_forthpsllqcommaname = "PSLLQ,";    void dg_forthpsllqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF3",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x73",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        6,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xF3",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x73",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        6);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsllqcommaname);        return;    }}const char* dg_forthpslldqcommaname = "PSLLDQ,";    void dg_forthpslldqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"",           // pforwardmmopcodestring,        0,                            // forwardmmopcodestringlength,        (unsigned char*)"",           // pforwardimmediatemmopcodestring,        0,                            // forwardimmediatemmopcodestringlength,        0,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"",           // pforwardxmmprefixstring,        0,                            // forwardxmmprefixstringlength,        (unsigned char*)"",           // pforwardxmmopcodestring,        0,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x73",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        7);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpslldqcommaname);        return;    }}const char* dg_forthpsrawcommaname = "PSRAW,";    void dg_forthpsrawcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xE1",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x71",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        4,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xE1",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x71",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        4);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsrawcommaname);        return;    }}const char* dg_forthpsradcommaname = "PSRAD,";    void dg_forthpsradcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xE2",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x72",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        4,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xE2",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x72",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        4);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsradcommaname);        return;    }}const char* dg_forthpsrlwcommaname = "PSRLW,";    void dg_forthpsrlwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD1",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x71",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        2,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xD1",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x71",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        2);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsrlwcommaname);        return;    }}const char* dg_forthpsrldcommaname = "PSRLD,";    void dg_forthpsrldcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD2",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x72",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        2,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xD2",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x72",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        2);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsrldcommaname);        return;    }}const char* dg_forthpsrlqcommaname = "PSRLQ,";    void dg_forthpsrlqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_don8orxmmorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD3",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x73",   // pforwardimmediatemmopcodestring,        2,                            // forwardimmediatemmopcodestringlength,        2,                            // forwardimmediatemmopcodeextension,        (unsigned char*)"\x66",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xD3",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // pforwardimmediatexmmprefixstring,        1,                            // forwardimmediatexmmprefixstringlength,        (unsigned char*)"\x0F\x73",   // pforwardimmediatexmmopcodestring,        2,                            // forwardimmediatexmmopcodestringlength,        2);                           // forwardimmediatexmmopcodeextension)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsrlqcommaname);        return;    }}const char* dg_pullandcompilen8andtwotargetsname = "dg_pullandcompilen8andtwotargets";void dg_pullandcompilen8andtwotargets (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;    dg_Sibformatter thirdtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    dg_initSibformatter(&thirdtarget);        UINT64 thirdtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8andtwotargetsname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8andtwotargetsname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &thirdtarget); // third on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8andtwotargetsname);        return;    }        thirdtargettype = dg_gettargettype(        pBHarrayhead,        &thirdtarget);        if (thirdtargettype != dg_targettypeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be immediate");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8andtwotargetsname);        return;    }        if ((thirdtarget.immediatesize != 1) &&        (thirdtarget.immediatesize != 0))    {        dg_pusherror(pBHarrayhead, (const char*)"The size of the immediate value for this instruction is 1 byte. If you specify the minimum immediate size, it must be zero or one. E.g. mybytevalue 1 IMMEDIATE.");        dg_pusherror(pBHarrayhead, dg_pullandcompilen8andtwotargetsname);        return;    }        secondtarget.immediatesize = 1;    secondtarget.immediatevalue = thirdtarget.immediatevalue;        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilen8andtwotargetsname);        return;    }}const char* dg_don8xmmrinstructionname = "dg_don8xmmrinstruction";void dg_don8xmmrinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8xmmrinstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = prefixstringlength;        perror = dg_movebytes(        pprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        prefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrinstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = opcodestringlength;        perror = dg_movebytes(        popcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        opcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrinstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = xmmmemtargetsize;        dg_pullandcompilen8andtwotargets (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8xmmrinstructionname);        return;    }}const char* dg_forthaeskeygenassistcommaname = "AESKEYGENASSIST,";void dg_forthaeskeygenassistcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\xDF", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaeskeygenassistcommaname);        return;    }}const char* dg_forthblendpdcommaname = "BLENDPD,";void dg_forthblendpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x0D", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblendpdcommaname);        return;    }}const char* dg_forthblendpscommaname = "BLENDPS,";void dg_forthblendpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x0C", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblendpscommaname);        return;    }}const char* dg_forthcmppdcommaname = "CMPPD,";void dg_forthcmppdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xC2", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmppdcommaname);        return;    }}const char* dg_forthcmppscommaname = "CMPPS,";void dg_forthcmppscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xC2", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmppscommaname);        return;    }}const char* dg_forthcmpsd2commaname = "CMPSD2,";void dg_forthcmpsd2comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xC2", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1, // prefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpsd2commaname);        return;    }}const char* dg_forthcmpsscommaname = "CMPSS,";void dg_forthcmpsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xC2", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1, // prefixstringlength,        4); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpsscommaname);        return;    }}const char* dg_forthdppdcommaname = "DPPD,";void dg_forthdppdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x41", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdppdcommaname);        return;    }}const char* dg_forthdppscommaname = "DPPS,";void dg_forthdppscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x40", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdppscommaname);        return;    }}const char* dg_forthinsertpscommaname = "INSERTPS,";void dg_forthinsertpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x21", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        4); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinsertpscommaname);        return;    }}const char* dg_forthmpsadbwcommaname = "MPSADBW,";void dg_forthmpsadbwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x42", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmpsadbwcommaname);        return;    }}const char* dg_forthpblendwcommaname = "PBLENDW,";void dg_forthpblendwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x0E", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpblendwcommaname);        return;    }}const char* dg_forthpclmulqdqcommaname = "PCLMULQDQ,";void dg_forthpclmulqdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x44", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpclmulqdqcommaname);        return;    }}const char* dg_forthpcmpestricommaname = "PCMPESTRI,";void dg_forthpcmpestricomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x61", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpestricommaname);        return;    }} const char* dg_forthpcmpestrmcommaname = "PCMPESTRM,";void dg_forthpcmpestrmcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x60", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpestrmcommaname);        return;    }}const char* dg_forthpcmpistricommaname = "PCMPISTRI,";void dg_forthpcmpistricomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x63", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpistricommaname);        return;    }}const char* dg_forthpcmpistrmcommaname = "PCMPISTRM,";void dg_forthpcmpistrmcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x62", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpistrmcommaname);        return;    }}const char* dg_forthpshufdcommaname = "PSHUFD,";void dg_forthpshufdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x70", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpshufdcommaname);        return;    }}const char* dg_forthpshufhwcommaname = "PSHUFHW,";void dg_forthpshufhwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x70", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF3", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpshufhwcommaname);        return;    }}const char* dg_forthpshuflwcommaname = "PSHUFLW,";void dg_forthpshuflwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x70", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\xF2", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpshuflwcommaname);        return;    }}const char* dg_forthroundpdcommaname = "ROUNDPD,";void dg_forthroundpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x09", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthroundpdcommaname);        return;    }}const char* dg_forthroundpscommaname = "ROUNDPS,";void dg_forthroundpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x08", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthroundpscommaname);        return;    }}const char* dg_forthroundsdcommaname = "ROUNDSD,";void dg_forthroundsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x0B", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthroundsdcommaname);        return;    }}const char* dg_forthroundsscommaname = "ROUNDSS,";void dg_forthroundsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x0A", // popcodestring,        3, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthroundsscommaname);        return;    }}const char* dg_forthshufpdcommaname = "SHUFPD,";void dg_forthshufpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xC6", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"\x66", // pprefixstring,        1, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthshufpdcommaname);        return;    }}const char* dg_forthshufpscommaname = "SHUFPS,";void dg_forthshufpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xC6", // popcodestring,        2, // opcodestringlength,        (unsigned char*)"", // pprefixstring,        0, // prefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthshufpdcommaname);        return;    }}const char* dg_don8xmmrorfpinstructionname = "dg_don8xmmrorfpinstruction";void dg_don8xmmrorfpinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pfpopcodestring,    UINT64 fpopcodestringlength,    unsigned char* pxmmopcodestring,    UINT64 xmmopcodestringlength,    unsigned char* pxmmprefixstring,    UINT64 xmmprefixstringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8xmmrorfpinstructionname);        return;    }        myopcodes.m64tofpr.opcodestringlength = fpopcodestringlength;        perror = dg_movebytes(        pfpopcodestring,        (unsigned char*)(&(myopcodes.m64tofpr.popcodestring[0])),        fpopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrorfpinstructionname);        return;    }        myopcodes.m64toxmm.prefixstringlength = xmmprefixstringlength;        perror = dg_movebytes(        pxmmprefixstring,        (unsigned char*)(&(myopcodes.m64toxmm.pprefixstring[0])),        xmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrorfpinstructionname);        return;    }        myopcodes.m64toxmm.opcodestringlength = xmmopcodestringlength;        perror = dg_movebytes(        pxmmopcodestring,        (unsigned char*)(&(myopcodes.m64toxmm.popcodestring[0])),        xmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_don8xmmrorfpinstructionname);        return;    }        myopcodes.usesxmmandmemtargetsize = xmmmemtargetsize;        dg_pullandcompilen8andtwotargets (        pBHarrayhead,        &myopcodes); // kinda overkill when there is only one choice....        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_don8xmmrorfpinstructionname);        return;    }}const char* dg_forthpalignrcommaname = "PALIGNR,";void dg_forthpalignrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x3A\x0F", // pfpopcodestring,        3, // fpopcodestringlength,        (unsigned char*)"\x0F\x3A\x0F", // pxmmopcodestring,        3, // xmmopcodestringlength,        (unsigned char*)"\x66", // pxmmprefixstring,        1, // xmmprefixstringlength,        16); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpalignrcommaname);        return;    }}const char* dg_forthpshufwcommaname = "PSHUFW,";void dg_forthpshufwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_don8xmmrorfpinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x70", // pfpopcodestring,        2, // fpopcodestringlength,        (unsigned char*)"", // pxmmopcodestring,        0, // xmmopcodestringlength,        (unsigned char*)"", // pxmmprefixstring,        0, // xmmprefixstringlength,        8); // xmmmemtargetsize);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpshufwcommaname);        return;    }}const char* dg_forthadccommaname = "ADC,";void dg_forthadccomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myadcopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &myadcopcodes,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthadccommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myadcopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthadccommaname);        return;    }}const char* dg_forthaddcommaname = "ADD,";void dg_forthaddcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myaddopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &myaddopcodes,        0);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myaddopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddcommaname);        return;    }}const char* dg_forthadcxcommaname = "ADCX,";void dg_forthadcxcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings popcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetadcxoptbl (        pBHarrayhead,        &popcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthadcxcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &popcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthadcxcommaname);        return;    }}const char* dg_forthadoxcommaname = "ADOX,";void dg_forthadoxcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings popcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetadoxoptbl (        pBHarrayhead,        &popcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthadoxcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &popcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthadoxcommaname);        return;    }}const char* dg_forthandcommaname = "AND,";void dg_forthandcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myandopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &myandopcodes,        4);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myandopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandcommaname);        return;    }}const char* dg_forthcmpcommaname = "CMP,";void dg_forthcmpcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings mycmpopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &mycmpopcodes,        7);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &mycmpopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpcommaname);        return;    }}const char* dg_forthorcommaname = "OR,";void dg_forthorcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myoropcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &myoropcodes,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthorcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myoropcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthorcommaname);        return;    }}const char* dg_forthsbbcommaname = "SBB,";void dg_forthsbbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings mysbbopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &mysbbopcodes,        3);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsbbcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &mysbbopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsbbcommaname);        return;    }}const char* dg_forthsubcommaname = "SUB,";void dg_forthsubcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings mysubopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &mysubopcodes,        5);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsubcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &mysubopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsubcommaname);        return;    }}const char* dg_forthxorcommaname = "XOR,";void dg_forthxorcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myxoropcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmathoptbl (        pBHarrayhead,        &myxoropcodes,        6);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxorcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myxoropcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxorcommaname);        return;    }}const char* dg_forthmovcommaname = "MOV,";void dg_forthmovcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings mymovopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)"doing MOV,\n");        dg_fill2targetmovoptbl (        pBHarrayhead,        &mymovopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &mymovopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovcommaname);        return;    }}const char* dg_forthtestcommaname = "TEST,";void dg_forthtestcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings mytestopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targettestoptbl (        pBHarrayhead,        &mytestopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtestcommaname);        return;    }    dg_pullandcompiletwotargets (        pBHarrayhead,        &mytestopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtestcommaname);        return;    }}const char* dg_forthcmovcommaname = "CMOV,";void dg_forthcmovcomma (Bufferhandle* pBHarrayhead){    UINT64 conditioncode;        struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        conditioncode = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmovcommaname);        return;    }        if (conditioncode > DG_BRANCHTYPE_ALWAYS)    {        // never ... soo don't need to do anything        return;    }        if (DG_BRANCHTYPE_ALWAYS == conditioncode)    {        // just a regular move        dg_forthmovcomma(pBHarrayhead);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcmovcommaname);            return;        }            return;    }        // m->r32 only    dg_fill2targetm32bonlyoptbl (        pBHarrayhead,        &myopcodes,        0x40 | conditioncode);            myopcodes.r32tom32.opcodestringlength = 0;            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmovcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmovcommaname);        return;    }}const char* dg_forthnotcommaname = "NOT,";void dg_forthnotcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_fillonetargetmemonlyoptable (        pBHarrayhead,        &myopcodes,        0xF6,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnotcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnotcommaname);        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)" doing NOT. After pull one target the size = ");    // dg_writestdoutuint64tohex(pBHarrayhead, mytargetsf.size);    // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnotcommaname);        return;    }        // dg_printzerostring(pBHarrayhead, (unsigned char*)" After compile one target the size = ");    // dg_writestdoutuint64tohex(pBHarrayhead, mytargetsf.size);    // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");}const char* dg_forthnegcommaname = "NEG,";void dg_forthnegcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_fillonetargetmemonlyoptable (        pBHarrayhead,        &myopcodes,        0xF6,        3);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnegcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnegcommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnegcommaname);        return;    }}const char* dg_forthmulcommaname = "MUL,";void dg_forthmulcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_fillonetargetmemonlyoptable (        pBHarrayhead,        &myopcodes,        0xF6,        4);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulcommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulcommaname);        return;    }}const char* dg_forthdivcommaname = "DIV,";void dg_forthdivcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_fillonetargetmemonlyoptable (        pBHarrayhead,        &myopcodes,        0xF6,        6);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivcommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivcommaname);        return;    }}const char* dg_forthidivcommaname = "IDIV,";void dg_forthidivcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_fillonetargetmemonlyoptable (        pBHarrayhead,        &myopcodes,        0xF6,        7);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthidivcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthidivcommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthidivcommaname);        return;    }}const char* dg_forthbswapcommaname = "BSWAP,";void dg_forthbswapcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbswapcommaname);        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        //popcodes->m8.popcodestring[0] = 0;    myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.popcodestring[0] = (char)0x0F;    myopcodes.r32.popcodestring[1] = (char)0xC8;    myopcodes.r32.opcodestringlength = 2;    myopcodes.r32.opcodeextension = (UINT64)-1;        //popcodes->m32.popcodestring[0] = baseopcode | 1;    myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbswapcommaname);        return;    }        if (4 == addresssize)    {        if (mytargetsf.size != 4)        {            dg_pusherror(pBHarrayhead, (const char*)"only 32 bit registers are supported for BSWAP,");            dg_pusherror(pBHarrayhead, dg_forthbswapcommaname);            return;        }    }    else    {        if ( !((4 == mytargetsf.size) ||               (8 == mytargetsf.size)) )        {            dg_pusherror(pBHarrayhead, (const char*)"32 or 64 bit registers are supported for BSWAP,");            dg_pusherror(pBHarrayhead, dg_forthbswapcommaname);            return;        }    }        // should check for compile type reg or default reg...        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbswapcommaname);        return;    }}const char* dg_forthpushcommaname = "PUSH,";void dg_forthpushcomma(Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpushcommaname);        return;    }        //myopcodes.n8.popcodestring[0] = 0x6A;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;    //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        //popcodes->m8.popcodestring[0] = 0;    myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.popcodestring[0] = (char)0x6A;    myopcodes.n32signextended.opcodestringlength = 1;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;            myopcodes.n32.popcodestring[0] = (char)0x68; // there is an unsigned extension shortcut... 0x6A    myopcodes.n32.opcodestringlength = 1;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.popcodestring[0] = (char)0x50;    myopcodes.r32.opcodestringlength = 1;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0xFF;    myopcodes.m32.opcodestringlength = 1;    myopcodes.m32.opcodeextension = 6;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpushcommaname);        return;    }        // promote size if default (for immediate and memory operands)    if (0 == mytargetsf.size)    {        mytargetsf.size = addresssize;    }        if (2 != mytargetsf.size)    {        if (addresssize != mytargetsf.size)        {            dg_pusherror(pBHarrayhead, (const char*)"register and memory targets must be same as address size or 16 bits for PUSH, (so 16 bits, 32 bits in 32 bit mode or 64 bits in 64 bit mode)");            dg_pusherror(pBHarrayhead, dg_forthpushcommaname);            return;        }    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpushcommaname);        return;    }}const char* dg_forthpopcommaname = "POP,";void dg_forthpopcomma(Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpopcommaname);        return;    }        //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;    //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        //popcodes->m8.popcodestring[0] = 0;    myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;    //popcodes->n32.popcodestring[0] = 0;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring[0] = 0;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.popcodestring[0] = (char)0x58;    myopcodes.r32.opcodestringlength = 1;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0x8F;    myopcodes.m32.opcodestringlength = 1;    myopcodes.m32.opcodeextension = 0;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpopcommaname);        return;    }        // promote size if default (for immediate and memory operands)    if (0 == mytargetsf.size)    {        mytargetsf.size = addresssize;    }        if (2 != mytargetsf.size)    {        if (addresssize != mytargetsf.size)        {            dg_pusherror(pBHarrayhead, (const char*)"register and memory targets must be same as address size or 16 bits for POP, (so 16 bits, 32 bits in 32 bit mode or 64 bits in 64 bit mode)");            dg_pusherror(pBHarrayhead, dg_forthpopcommaname);            return;        }    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpopcommaname);        return;    }}const char* dg_forthrdrandcommaname = "RDRAND,";void dg_forthrdrandcomma(Bufferhandle* pBHarrayhead){    UINT64 addresssize;    UINT64 targettype;        struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdrandcommaname);        return;    }        myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;            myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0x0F;    myopcodes.m32.popcodestring[1] = (char)0xC7;    myopcodes.m32.opcodestringlength = 2;    myopcodes.m32.opcodeextension = 6;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdrandcommaname);        return;    }        // make sure target is reg    targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdrandcommaname);        return;    }        if ((targettype != dg_targettyperega) &&        (targettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"only register targets are supported");        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdrandcommaname);        return;    }}const char* dg_forthrdseedcommaname = "RDSEED,";void dg_forthrdseedcomma(Bufferhandle* pBHarrayhead){    UINT64 addresssize;    UINT64 targettype;        struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdseedcommaname);        return;    }        myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;            myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0x0F;    myopcodes.m32.popcodestring[1] = (char)0xC7;    myopcodes.m32.opcodestringlength = 2;    myopcodes.m32.opcodeextension = 7;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdseedcommaname);        return;    }        // make sure target is reg    targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdseedcommaname);        return;    }        if ((targettype != dg_targettyperega) &&        (targettype != dg_targettypereg))    {        dg_pusherror(pBHarrayhead, (const char*)"only register targets are supported");        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrdseedcommaname);        return;    }}const char* dg_forthinccommaname = "INC,";void dg_forthinccomma(Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinccommaname);        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.popcodestring[0] = (char)0xFE;    myopcodes.m8.opcodestringlength = 1;    myopcodes.m8.opcodeextension = 0;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring[0] = 0;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        // in 64 bit addressing mode, r32 is not available    if (addresssize != 8)    {        myopcodes.r32.popcodestring[0] = (char)0x40;        myopcodes.r32.opcodestringlength = 1;        myopcodes.r32.opcodeextension = (UINT64)-1;    }    else    {        myopcodes.r32.opcodestringlength = 0;        myopcodes.r32.opcodeextension = (UINT64)-1;    }        myopcodes.m32.popcodestring[0] = (char)0xFF;    myopcodes.m32.opcodestringlength = 1;    myopcodes.m32.opcodeextension = 0;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinccommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinccommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinccommaname);        return;    }}const char* dg_forthdeccommaname = "DEC,";void dg_forthdeccomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdeccommaname);        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.popcodestring[0] = (char)0xFE;    myopcodes.m8.opcodestringlength = 1;    myopcodes.m8.opcodeextension = 1;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring[0] = 0;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring[0] = 0;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        // in 64 bit addressing mode, r32 is not available    if (addresssize != 8)    {        myopcodes.r32.popcodestring[0] = (char)0x48;        myopcodes.r32.opcodestringlength = 1;        myopcodes.r32.opcodeextension = (UINT64)-1;    }    else    {        myopcodes.r32.opcodestringlength = 0;        myopcodes.r32.opcodeextension = (UINT64)-1;    }        myopcodes.m32.popcodestring[0] = (char)0xFF;    myopcodes.m32.opcodestringlength = 1;    myopcodes.m32.opcodeextension = 1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdeccommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdeccommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdeccommaname);        return;    }}const char* dg_forthcmpxchg8bcommaname = "CMPXCHG8B,";void dg_forthcmpxchg8bcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 addresssize;    UINT64 targettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg8bcommaname);        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        //popcodes->m8.popcodestring[0] = 0;    myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        //myopcodes.r32.popcodestring[0] = (char)0x0F;    myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0x0F;    myopcodes.m32.popcodestring[1] = (char)0xC7;;    myopcodes.m32.opcodestringlength = 2;    myopcodes.m32.opcodeextension = 1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg8bcommaname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg8bcommaname);        return;    }        if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported");        return;    }        mytargetsf.size = 4;        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg8bcommaname);        return;    }}const char* dg_forthcmpxchg16bcommaname = "CMPXCHG16B,";void dg_forthcmpxchg16bcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 addresssize;    UINT64 targettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg16bcommaname);        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        //popcodes->m8.popcodestring[0] = 0;    myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        //myopcodes.r32.popcodestring[0] = (char)0x0F;    myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0x48;    myopcodes.m32.popcodestring[1] = (char)0x0F;    myopcodes.m32.popcodestring[2] = (char)0xC7;;    myopcodes.m32.opcodestringlength = 3;    myopcodes.m32.opcodeextension = 1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg16bcommaname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg16bcommaname);        return;    }        if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported");        return;    }        mytargetsf.size = 4;        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg16bcommaname);        return;    }}const char* dg_forthcflushcommaname = "CFLUSH,";void dg_forthcflushcomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 targettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        //popcodes->m8.popcodestring[0] = 0;    myopcodes.m8.popcodestring[0] = (char)0x0F;    myopcodes.m8.popcodestring[1] = (char)0xAE;    myopcodes.m32.opcodestringlength = 2;    myopcodes.m32.opcodeextension = 7;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        //myopcodes.r32.popcodestring[0] = (char)0x0F;    myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcflushcommaname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &mytargetsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcflushcommaname);        return;    }        if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported");        return;    }        mytargetsf.size = 1;        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchg16bcommaname);        return;    }}const char* dg_forthfstcommaname = "FST,";void dg_forthfstcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 2;        myopcodes.m64fp.popcodestring[0] = (char)0xDD;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 2;        myopcodes.m80fp.opcodestringlength = 0;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 8;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcommaname);        return;    }}const char* dg_forthfstpcommaname = "FSTP,";void dg_forthfstpcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstpcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 3;        myopcodes.m64fp.popcodestring[0] = (char)0xDD;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 3;        myopcodes.m80fp.popcodestring[0] = (char)0xDB;    myopcodes.m80fp.opcodestringlength = 1;    myopcodes.m80fp.opcodeextension = 7;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstpcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstpcommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 8;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstpcommaname);        return;    }}const char* dg_forthfldcommaname = "FLD,";void dg_forthfldcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.popcodestring[0] = (char)0xDD;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 0;        myopcodes.m80fp.popcodestring[0] = (char)0xDB;    myopcodes.m80fp.opcodestringlength = 1;    myopcodes.m80fp.opcodeextension = 5;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcommaname);        return;    }        if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcommaname);        return;    }}const char* dg_forthfaddtost0commaname = "FADD->ST0,";void dg_forthfaddtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 0;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddtost0commaname);        return;    }}const char* dg_forthfcomcommaname = "FCOM,";const char* dg_forthfcomtost0commaname = "FCOM->ST0,";void dg_forthfcomtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 2;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 2;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomtost0commaname);        return;    }}const char* dg_forthfcompcommaname = "FCOMP,";const char* dg_forthfcomptost0commaname = "FCOMP->ST0,";void dg_forthfcomptost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomptost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 3;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 3;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomptost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomptost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomptost0commaname);        return;    }}const char* dg_forthfcomppcommaname = "FCOMPP,";void dg_forthfcomppcomma (Bufferhandle* pBHarrayhead){    const char pbuf[3] = "\xDE\xD9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfcomppcommaname);    }}const char* dg_forthfsubtost0commaname = "FSUB->ST0,";void dg_forthfsubtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 4;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubtost0commaname);        return;    }}const char* dg_forthfdivtost0commaname = "FDIV->ST0,";void dg_forthfdivtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 6;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivtost0commaname);        return;    }}const char* dg_forthfdivrtost0commaname = "FDIVR->ST0,";void dg_forthfdivrtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 7;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 7;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrtost0commaname);        return;    }}const char* dg_forthfmultost0commaname = "FMUL->ST0,";void dg_forthfmultost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmultost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmultost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmultost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmultost0commaname);        return;    }}const char* dg_forthfsubrtost0commaname = "FSUBR->ST0,";void dg_forthfsubrtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD8;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.popcodestring[0] = (char)0xDC;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 5;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrtost0commaname);        return;    }}const char* dg_forthfaddst0tocommaname = "FADDST0->,";void dg_forthfaddst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDC;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfaddst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddst0tocommaname);        return;    }}const char* dg_forthfsubst0tocommaname = "FSUBST0->,";void dg_forthfsubst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDC;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfsubst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubst0tocommaname);        return;    }}const char* dg_forthfdivst0tocommaname = "FDIVST0->,";void dg_forthfdivst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDC;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 7;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfdivst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivst0tocommaname);        return;    }}const char* dg_forthfdivrst0tocommaname = "FDIVRST0->,";void dg_forthfdivrst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDC;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfdivrst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrst0tocommaname);        return;    }}const char* dg_forthfmulst0tocommaname = "FMULST0->,";void dg_forthfmulst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDC;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;    myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfmulst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulst0tocommaname);        return;    }}const char* dg_forthfsubrst0tocommaname = "FSUBRST0->,";void dg_forthfsubrst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDC;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfsubrst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrst0tocommaname);        return;    }}const char* dg_forthfaddpst0tocommaname = "FADDPST0->,";void dg_forthfaddpst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddpst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDE;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddpst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddpst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfaddpst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfaddpst0tocommaname);        return;    }}const char* dg_forthfsubpst0tocommaname = "FSUBPST0->,";void dg_forthfsubpst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubpst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDE;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubpst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubpst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfsubpst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubpst0tocommaname);        return;    }}const char* dg_forthfdivpst0tocommaname = "FDIVPST0->,";void dg_forthfdivpst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivpst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDE;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 7;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivpst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivpst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfdivpst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivpst0tocommaname);        return;    }}const char* dg_forthfdivrpst0tocommaname = "FDIVRPST0->,";void dg_forthfdivrpst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrpst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDE;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrpst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrpst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfdivrpst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfdivrpst0tocommaname);        return;    }}const char* dg_forthfmulpst0tocommaname = "FMULPST0->,";void dg_forthfmulpst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulpst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDE;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulpst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulpst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfmulpst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfmulpst0tocommaname);        return;    }}const char* dg_forthfsubrpst0tocommaname = "FSUBRPST0->,";void dg_forthfsubrpst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrpst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDE;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrpst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrpst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfsubrpst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsubrpst0tocommaname);        return;    }}const char* dg_forthfucomcommaname = "FUCOM,";const char* dg_forthfucomtost0commaname = "FUCOM->ST0,";void dg_forthfucomtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfucomtost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomtost0commaname);        return;    }}const char* dg_forthfucompcommaname = "FUCOMP,";const char* dg_forthfucomptost0commaname = "FUCOMP->ST0,";void dg_forthfucomptost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomptost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomptost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomptost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfucomptost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomptost0commaname);        return;    }}const char* dg_forthfxchcommaname = "FXCH,";const char* dg_forthfxchtost0commaname = "FXCH->ST0,";const char* dg_forthfxchst0tocommaname = "FXCHST0->,";void dg_forthfxchst0tocomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfxchst0tocommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfxchst0tocommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfxchst0tocommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" target must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfxchst0tocommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfxchst0tocommaname);        return;    }}const char* dg_forthfcmovbcommaname = "FCMOVB,";const char* dg_forthfcmovbtost0commaname = "FCMOVB->ST0,";void dg_forthfcmovbtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovbtost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbtost0commaname);        return;    }}const char* dg_forthfcmovecommaname = "FCMOVE,";const char* dg_forthfcmovetost0commaname = "FCMOVE->ST0,";void dg_forthfcmovetost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovetost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovetost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovetost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovetost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovetost0commaname);        return;    }}const char* dg_forthfcmovbecommaname = "FCMOVBE,";const char* dg_forthfcmovbetost0commaname = "FCMOVBE->ST0,";void dg_forthfcmovbetost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbetost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 2;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbetost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbetost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovbetost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovbetost0commaname);        return;    }}const char* dg_forthfcmovucommaname = "FCMOVU,";const char* dg_forthfcmovutost0commaname = "FCMOVU->ST0,";void dg_forthfcmovutost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovutost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 3;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovutost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovutost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovutost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovutost0commaname);        return;    }}const char* dg_forthfcmovnbcommaname = "FCMOVNB,";const char* dg_forthfcmovnbtost0commaname = "FCMOVNB->ST0,";void dg_forthfcmovnbtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbtost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovnbtost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbtost0commaname);        return;    }}const char* dg_forthfcmovnecommaname = "FCMOVNE,";const char* dg_forthfcmovnetost0commaname = "FCMOVNE->ST0,";void dg_forthfcmovnetost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnetost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnetost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnetost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovnetost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnetost0commaname);        return;    }}const char* dg_forthfcmovnbecommaname = "FCMOVNBE,";const char* dg_forthfcmovnbetost0commaname = "FCMOVNBE->ST0,";void dg_forthfcmovnbetost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbetost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 2;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbetost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbetost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovnbetost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnbetost0commaname);        return;    }}const char* dg_forthfcmovnucommaname = "FCMOVNU,";const char* dg_forthfcmovnutost0commaname = "FCMOVNU->ST0,";void dg_forthfcmovnutost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnutost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 3;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnutost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnutost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcmovnutost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcmovnutost0commaname);        return;    }}const char* dg_forthfcomicommaname = "FCOMI,";const char* dg_forthfcomitost0commaname = "FCOMI->ST0,";void dg_forthfcomitost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomitost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomitost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomitost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcomitost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomitost0commaname);        return;    }}const char* dg_forthfcomipcommaname = "FCOMIP,";const char* dg_forthfcomiptost0commaname = "FCOMIP->ST0,";void dg_forthfcomiptost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomiptost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDF;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomiptost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomiptost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfcomiptost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfcomiptost0commaname);        return;    }}const char* dg_forthfucomicommaname = "FUCOMI,";const char* dg_forthfucomitost0commaname = "FUCOMI->ST0,";void dg_forthfucomitost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomitost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomitost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomitost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfucomitost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomitost0commaname);        return;    }}const char* dg_forthfucomipcommaname = "FUCOMIP,";const char* dg_forthfucomiptost0commaname = "FUCOMIP->ST0,";void dg_forthfucomiptost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomiptost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDF;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomiptost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomiptost0commaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    //  but using size m32fp so that the floating point opcode gets recognized    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthfucomiptost0commaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfucomiptost0commaname);        return;    }}const char* dg_forthffreecommaname = "FFREE,";void dg_forthffreecomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthffreecommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthffreecommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthffreecommaname);        return;    }        // if fpsreg ... set the size to the one the docs say is correct    if (mytargetsf.memmode == dg_memmodefpsreg)    {        mytargetsf.size = 4;    }    else    {        dg_pusherror(pBHarrayhead, (const char*)" target must be a floating point register");        dg_pusherror(pBHarrayhead, dg_forthffreecommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthffreecommaname);        return;    }}const char* dg_forthfiaddtost0commaname = "FIADD->ST0,";void dg_forthfiaddtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfiaddtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 0;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfiaddtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfiaddtost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfiaddtost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfiaddtost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfiaddtost0commaname);        return;    }}const char* dg_forthficomtost0commaname = "FICOM->ST0,";void dg_forthficomtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 2;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 2;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }}const char* dg_forthficomptost0commaname = "FICOMP->ST0,";void dg_forthficomptost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 3;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 3;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomptost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomptost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthficomptost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthficomptost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomptost0commaname);        return;    }}const char* dg_forthfisubtost0commaname = "FISUB->ST0,";void dg_forthfisubtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 4;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubtost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfisubtost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfisubtost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubtost0commaname);        return;    }}const char* dg_forthfidivtost0commaname = "FIDIV->ST0,";void dg_forthfidivtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 6;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivtost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfidivtost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfidivtost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivtost0commaname);        return;    }}const char* dg_forthfidivrtost0commaname = "FIDIVR->ST0,";void dg_forthfidivrtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivrtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 7;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 7;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivrtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivrtost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfidivrtost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfidivrtost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfidivrtost0commaname);        return;    }}const char* dg_forthfimultost0commaname = "FIMUL->ST0,";void dg_forthfimultost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfimultost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfimultost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfimultost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfimultost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfimultost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfimultost0commaname);        return;    }}const char* dg_forthfisubrtost0commaname = "FISUBR->ST0,";void dg_forthfisubrtost0comma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubrtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDA;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        myopcodes.m64fp.popcodestring[0] = (char)0xDE;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 5;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubrtost0commaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubrtost0commaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfisubrtost0commaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 8;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfisubrtost0commaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisubrtost0commaname);        return;    }}const char* dg_forthfildcommaname = "FILD,";void dg_forthfildcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthficomtost0commaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 0;        myopcodes.m64fp.popcodestring[0] = (char)0xDF;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 5;        myopcodes.m80fp.popcodestring[0] = (char)0xDF;    myopcodes.m80fp.opcodestringlength = 1;    myopcodes.m80fp.opcodeextension = 0;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfildcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfildcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16, 32 or 64 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfildcommaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 10;                break;            case 4: // 4 is already ok            case 8: // 8 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" source must be a 16, 32 or 64 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfildcommaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfildcommaname);        return;    }}const char* dg_forthfistpcommaname = "FISTP,";void dg_forthfistpcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistpcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 3;        myopcodes.m64fp.popcodestring[0] = (char)0xDF;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 7;        myopcodes.m80fp.popcodestring[0] = (char)0xDF;    myopcodes.m80fp.opcodestringlength = 1;    myopcodes.m80fp.opcodeextension = 3;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistpcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistpcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16, 32, or 64 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfistpcommaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 10;                break;            case 4: // 4 is already ok            case 8: // 8 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16, 32 or 64 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfistpcommaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistpcommaname);        return;    }}const char* dg_forthfisttpcommaname = "FISTTP,";void dg_forthfisttpcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisttpcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 1;        myopcodes.m64fp.popcodestring[0] = (char)0xDD;    myopcodes.m64fp.opcodestringlength = 1;    myopcodes.m64fp.opcodeextension = 1;        myopcodes.m80fp.popcodestring[0] = (char)0xDF;    myopcodes.m80fp.opcodestringlength = 1;    myopcodes.m80fp.opcodeextension = 1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisttpcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisttpcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16, 32, or 64 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfisttpcommaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 10;                break;            case 4: // 4 is already ok            case 8: // 8 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16, 32 or 64 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfisttpcommaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfisttpcommaname);        return;    }}const char* dg_forthfistcommaname = "FIST,";void dg_forthfistcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDB;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 2;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.popcodestring[0] = (char)0xDF;    myopcodes.m80fp.opcodestringlength = 1;    myopcodes.m80fp.opcodeextension = 2;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16 bit or 32 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfistcommaname);        return;    }    else    {        switch (mytargetsf.size)        {            case 2:                mytargetsf.size = 10;                break;            case 4: // 4 is already ok                break;            default:                dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16, or 32 bit memory location");                dg_pusherror(pBHarrayhead, dg_forthfistcommaname);                return;                break;        }    }            dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfistcommaname);        return;    }}const char* dg_forthfbldcommaname = "FBLD,";void dg_forthfbldcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbldcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        // really m80, but using this opcode holder so compiling code will recognize    //  this as a floating point instruction    myopcodes.m32fp.popcodestring[0] = (char)0xDF;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbldcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbldcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be an 80 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfbldcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbldcommaname);        return;    }}const char* dg_forthfbstpcommaname = "FBSTP,";void dg_forthfbstpcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbstpcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        // really m80, but using this opcode holder so compiling code will recognize    //  this as a floating point instruction    myopcodes.m32fp.popcodestring[0] = (char)0xDF;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbstpcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbstpcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be an 80 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfbstpcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfbstpcommaname);        return;    }}const char* dg_forthfldcwcommaname = "FLDCW,";void dg_forthfldcwcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcwcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 5;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcwcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcwcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 16 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfldcwcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldcwcommaname);        return;    }}const char* dg_forthfstcwcommaname = "FSTCW,";void dg_forthfstcwcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcwcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0x9B;    myopcodes.m32fp.popcodestring[1] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 2;    myopcodes.m32fp.opcodeextension = 7;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcwcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcwcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfstcwcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstcwcommaname);        return;    }}const char* dg_forthfnstcwcommaname = "FNSTCW,";void dg_forthfnstcwcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstcwcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 7;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstcwcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstcwcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfnstcwcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstcwcommaname);        return;    }}const char* dg_forthfstswcommaname = "FSTSW,";void dg_forthfstswcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstswcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0x9B;    myopcodes.m32fp.popcodestring[1] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 2;    myopcodes.m32fp.opcodeextension = 7;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstswcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstswcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfstswcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstswcommaname);        return;    }}const char* dg_forthfnstswcommaname = "FNSTSW,";void dg_forthfnstswcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstswcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 7;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstswcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstswcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" destination must be a 16 bit memory location");        dg_pusherror(pBHarrayhead, dg_forthfnstswcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstswcommaname);        return;    }}const char* dg_forthfldenvcommaname = "FLDENV,";void dg_forthfldenvcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldenvcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldenvcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldenvcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 14/28 byte memory location (not sure how 14 versus 28 byte mode is selected)");        dg_pusherror(pBHarrayhead, dg_forthfldenvcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfldenvcommaname);        return;    }}const char* dg_forthfrstorcommaname = "FRSTOR,";void dg_forthfrstorcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfrstorcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 4;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfrstorcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfrstorcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 94/108 byte memory location (not sure how 94 versus 108 byte mode is selected)");        dg_pusherror(pBHarrayhead, dg_forthfrstorcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfrstorcommaname);        return;    }}const char* dg_forthfsavecommaname = "FSAVE,";void dg_forthfsavecomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsavecommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0x9B;    myopcodes.m32fp.popcodestring[1] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 2;    myopcodes.m32fp.opcodeextension = 6;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsavecommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsavecommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 94/108 byte memory location (not sure how 94 versus 108 byte mode is selected)");        dg_pusherror(pBHarrayhead, dg_forthfsavecommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfsavecommaname);        return;    }}const char* dg_forthfnsavecommaname = "FNSAVE,";void dg_forthfnsavecomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnsavecommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xDD;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnsavecommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnsavecommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 94/108 byte memory location (not sure how 94 versus 108 byte mode is selected)");        dg_pusherror(pBHarrayhead, dg_forthfnsavecommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnsavecommaname);        return;    }}const char* dg_forthfstenvcommaname = "FSTENV,";void dg_forthfstenvcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstenvcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0x9B;    myopcodes.m32fp.popcodestring[1] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 2;    myopcodes.m32fp.opcodeextension = 6;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstenvcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstenvcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 14/28 byte memory location (not sure how 14 versus 28 byte mode is selected)");        dg_pusherror(pBHarrayhead, dg_forthfstenvcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfstenvcommaname);        return;    }}const char* dg_forthfnstenvcommaname = "FNSTENV,";void dg_forthfnstenvcomma(    Bufferhandle* pBHarrayhead){    UINT64 addresssize;    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstenvcommaname);        return;    }    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.opcodestringlength = 0;    myopcodes.m8.opcodeextension = (UINT64)-1;        myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = (UINT64)-1;        myopcodes.m80fp.opcodestringlength = 0;    myopcodes.m80fp.opcodeextension = (UINT64)-1;        myopcodes.m64fp.opcodestringlength = 0;    myopcodes.m64fp.opcodeextension = (UINT64)-1;        myopcodes.m32fp.popcodestring[0] = (char)0xD9;    myopcodes.m32fp.opcodestringlength = 1;    myopcodes.m32fp.opcodeextension = 6;        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstenvcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstenvcommaname);        return;    }        // could make this make sure it's memory instead    if (mytargetsf.memmode == dg_memmodefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)" source must be a 14/28 byte memory location (not sure how 14 versus 28 byte mode is selected)");        dg_pusherror(pBHarrayhead, dg_forthfnstenvcommaname);        return;    }    else    {        mytargetsf.size = 4;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfnstenvcommaname);        return;    }}UINT64 dg_getshiftopcodetype (dg_Sibformatter* pmymodesf){    if (pmymodesf->memmode == dg_memmodeimmediate)    {        if (1 == pmymodesf->immediatevalue)        {            return 0; // shift 1        }        else        {            return 1; // shift N        }    }        if ( (pmymodesf->memmode == dg_memmodedefaultreg) ||             (pmymodesf->memmode == dg_memmodereg) )    {        if (pmymodesf->basereg == dg_cl) // shift CL        {            return 2;        }    }        return ((UINT64)-1);}const char* dg_pullandcompileshiftopname = "dg_pullandcompileshiftop";void dg_pullandcompileshiftop (    Bufferhandle* pBHarrayhead,    UINT64 opcodeextension){    unsigned char c;        // pull mem operand    // pull mode operand    // cases 1, CL, NN    //  all other cases are errors    UINT64 opcodetype;        struct Onetargetopcodestrings myopcodes;        dg_Sibformatter mytargetsf;    dg_Sibformatter mymodesf;        dg_initSibformatter(&mytargetsf);    dg_initSibformatter(&mymodesf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompileshiftopname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mymodesf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompileshiftopname);        return;    }        opcodetype = dg_getshiftopcodetype(&mymodesf);        //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring[0] = 0;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        switch (opcodetype)    {        case 0: // shift 1            //popcodes->a8.popcodestring[0] = 0;            myopcodes.a8.opcodestringlength = 0;            myopcodes.a8.opcodeextension = (UINT64)-1;                //popcodes->r8.popcodestring[0] = 0;            myopcodes.r8.opcodestringlength = 0;            myopcodes.r8.opcodeextension = (UINT64)-1;                myopcodes.m8.popcodestring[0] = (char)0xD0;            myopcodes.m8.opcodestringlength = 1;            myopcodes.m8.opcodeextension = opcodeextension;                //popcodes->a32.popcodestring[0] = 0;            myopcodes.a32.opcodestringlength = 0;            myopcodes.a32.opcodeextension = (UINT64)-1;                //popcodes->r32.popcodestring[0] = 0;            myopcodes.r32.opcodestringlength = 0;            myopcodes.r32.opcodeextension = (UINT64)-1;                myopcodes.m32.popcodestring[0] = (char)0xD1;            myopcodes.m32.opcodestringlength = 1;            myopcodes.m32.opcodeextension = opcodeextension;            break;                    case 1: // shift n            //popcodes->a8.popcodestring[0] = 0;            myopcodes.a8.opcodestringlength = 0;            myopcodes.a8.opcodeextension = (UINT64)-1;                //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;            myopcodes.r8.opcodestringlength = 0;            myopcodes.r8.opcodeextension = (UINT64)-1;                myopcodes.m8.popcodestring[0] = (char)0xC0;            myopcodes.m8.opcodestringlength = 1;            myopcodes.m8.opcodeextension = opcodeextension;                //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;            myopcodes.a32.opcodestringlength = 0;            myopcodes.a32.opcodeextension = (UINT64)-1;                //popcodes->r32.popcodestring = (unsigned char*)dg_badbufferid;            myopcodes.r32.opcodestringlength = 0;            myopcodes.r32.opcodeextension = (UINT64)-1;                myopcodes.m32.popcodestring[0] = (char)0xC1;            myopcodes.m32.opcodestringlength = 1;            myopcodes.m32.opcodeextension = opcodeextension;            break;                    case 2: // shift CL            //popcodes->a8.popcodestring[0] = 0;            myopcodes.a8.opcodestringlength = 0;            myopcodes.a8.opcodeextension = (UINT64)-1;                //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;            myopcodes.r8.opcodestringlength = 0;            myopcodes.r8.opcodeextension = (UINT64)-1;                myopcodes.m8.popcodestring[0] = (char)0xD2;            myopcodes.m8.opcodestringlength = 1;            myopcodes.m8.opcodeextension = opcodeextension;                //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;            myopcodes.a32.opcodestringlength = 0;            myopcodes.a32.opcodeextension = (UINT64)-1;                //popcodes->r32.popcodestring = (unsigned char*)dg_badbufferid;            myopcodes.r32.opcodestringlength = 0;            myopcodes.r32.opcodeextension = (UINT64)-1;                myopcodes.m32.popcodestring[0] = (char)0xD3;            myopcodes.m32.opcodestringlength = 1;            myopcodes.m32.opcodeextension = opcodeextension;            break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"shift/rotate amount can only be a constant value or the CL register");            dg_pusherror(pBHarrayhead, dg_pullandcompileshiftopname);            return;            break;            }    dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompileshiftopname);        return;    }        if (1 == opcodetype)    {        c = (unsigned char)(mymodesf.immediatevalue);                dg_compilesegment(            pBHarrayhead,            (const char*)&c,            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompileshiftopname);            return;        }    }}const char* dg_fortcctor8orm8name = "C->R8ORM8,";const char* dg_forthsetcommaname = "SET,";void dg_forthsetcomma(Bufferhandle* pBHarrayhead){    UINT64 conditioncode;        struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        conditioncode = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsetcommaname);        return;    }        // treat unknowns as dg_branchtype_never    if (conditioncode >  DG_BRANCHTYPE_ALWAYS)    {        // compile as mov 0 to r/m        dg_pushdatastack(pBHarrayhead, 1);        dg_pushdatastack(pBHarrayhead, dg_isdatasize);        dg_pushdatastack(pBHarrayhead, 0);        dg_pushdatastack(pBHarrayhead, dg_isimmediate);        dg_forthmovcomma(pBHarrayhead);        return;    }        if (conditioncode ==  DG_BRANCHTYPE_ALWAYS)    {        // compile as mov 1 to r/m        dg_pushdatastack(pBHarrayhead, 1);        dg_pushdatastack(pBHarrayhead, dg_isdatasize);        dg_pushdatastack(pBHarrayhead, 1);        dg_pushdatastack(pBHarrayhead, dg_isimmediate);        dg_forthmovcomma(pBHarrayhead);        return;    }        // condition code is < 0x10    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.popcodestring[0] = 0x0f;    myopcodes.m8.popcodestring[1] = 0x90 | conditioncode;    myopcodes.m8.opcodestringlength = 2;    myopcodes.m8.opcodeextension = 0;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        // 32bit mode not supported    //popcodes->n32.popcodestring[0] = 0;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        //myopcodes.r32.popcodestring[0] = 0x00;    myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        //myopcodes.m32.popcodestring[0] = 0x00;    myopcodes.m32.opcodestringlength = 0;    myopcodes.m32.opcodeextension = 0;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsetcommaname);        return;    }        // targetreg is not used        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsetcommaname);        return;    }}const char* dg_forthrclcommaname = "RCL,";void dg_forthrclcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrclcommaname);    }}const char* dg_forthrcrcommaname = "RCR,";void dg_forthrcrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrcrcommaname);    }}const char* dg_forthrolcommaname = "ROL,";void dg_forthrolcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        0);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrolcommaname);    }}const char* dg_forthrorcommaname = "ROR,";void dg_forthrorcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrorcommaname);    }}const char* dg_forthsalcommaname = "SAL,";const char* dg_forthshlcommaname = "SHL,";void dg_forthshlcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        4);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthshlcommaname);    }}const char* dg_forthshrcommaname = "SHR,";void dg_forthshrcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        5);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthshrcommaname);    }}const char* dg_forthsarcommaname = "SAR,";void dg_forthsarcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompileshiftop (        pBHarrayhead,        7);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsarcommaname);    }}const char* dg_forthhltcommaname = "HLT,";void dg_forthhltcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xF4;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthhltcommaname);    }}const char* dg_forthnopcommaname = "NOP,";void dg_forthnopcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0x90;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthnopcommaname);    }}const char* dg_forthaltooutdxcommaname = "AL->OUT[DX],";void dg_forthaltooutdxcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xEE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthaltooutdxcommaname);    }}const char* dg_forthaxtooutdxcommaname = "AX->OUT[DX],";void dg_forthaxtooutdxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)"\x66\xEF",        2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthaxtooutdxcommaname);    }}const char* dg_fortheaxtooutdxcommaname = "EAX->OUT[DX],";void dg_fortheaxtooutdxcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xEF;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_fortheaxtooutdxcommaname);    }}const char* dg_forthindxtoalcommaname = "IN[DX]->AL,";void dg_forthindxtoalcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xEC;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthindxtoalcommaname);    }}const char* dg_forthindxtoaxcommaname = "IN[DX]->AX,";void dg_forthindxtoaxcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (        pBHarrayhead,        (const char*)"\x66\xED",        2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthindxtoaxcommaname);    }}const char* dg_forthindxtoeaxcommaname = "IN[DX]->EAX,";void dg_forthindxtoeaxcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xED;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthindxtoeaxcommaname);    }}const char* dg_forthretcommaname = "RET,";void dg_forthretcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xC3;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretcommaname);    }}const char* dg_forthretdropn16commaname = "RETDROPN16,";void dg_forthretdropn16comma (Bufferhandle* pBHarrayhead){    UINT64 x;    const char c = (char)0xC2;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        x = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretdropn16commaname);    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretdropn16commaname);    }        dg_compilesegment (pBHarrayhead, (const char*)(&x), 2);  // assumes little endian        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretdropn16commaname);    }}const char* dg_forthretfarcommaname = "RETFAR,";void dg_forthretfarcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xCB;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretfarcommaname);    }}const char* dg_forthretfardropn16commaname = "RETFARDROPN16,";void dg_forthretfardropn16comma (Bufferhandle* pBHarrayhead){    UINT64 x;    const char c = (char)0xCA;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        x = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretfardropn16commaname);    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretfardropn16commaname);    }        dg_compilesegment (pBHarrayhead, (const char*)(&x), 2);  // assumes little endian        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthretfardropn16commaname);    }}const char* dg_forthstaccommaname = "STAC,";void dg_forthstaccomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xCB";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstaccommaname);    }}const char* dg_forthstccommaname = "STC,";void dg_forthstccomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xF9;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstccommaname);    }}const char* dg_forthsticommaname = "STI,";void dg_forthsticomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xFB;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsticommaname);    }}const char* dg_forthstdcommaname = "STD,";void dg_forthstdcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xFD;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstdcommaname);    }}const char* dg_forthclaccommaname = "CLAC,";void dg_forthclaccomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xCA";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthclaccommaname);    }}const char* dg_forthclccommaname = "CLC,";void dg_forthclccomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xF8;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthclccommaname);    }}const char* dg_forthcldcommaname = "CLD,";void dg_forthcldcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xFC;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcldcommaname);    }}const char* dg_forthclicommaname = "CLI,";void dg_forthclicomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xFA;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthclicommaname);    }}const char* dg_forthlahfcommaname = "LAHF,";const char* dg_fortheflagstoahcommaname = "EFLAGS->AH,";void dg_forthlahfcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0x9F;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlahfcommaname);    }}const char* dg_forthsahfcommaname = "SAHF,";const char* dg_forthahtoeflagscommaname = "AH->EFLAGS,";void dg_forthsahfcomma (Bufferhandle* pBHarrayhead){    const char c = (char)0x9E;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsahfcommaname);    }}const char* dg_forthdaacommaname = "DAA,";void dg_forthdaacomma (Bufferhandle* pBHarrayhead){    const char c = 0x27;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthdaacommaname);    }}const char* dg_forthdascommaname = "DAS,";void dg_forthdascomma (Bufferhandle* pBHarrayhead){    const char c = 0x2F;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthdascommaname);    }}const char* dg_forthcmccommaname = "CMC,";void dg_forthcmccomma (Bufferhandle* pBHarrayhead){    const char c = (char)0xF5;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcmccommaname);    }}const char* dg_forthaaacommaname = "AAA,";void dg_forthaaacomma (Bufferhandle* pBHarrayhead){    const char c = 0x37;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthaaacommaname);    }}const char* dg_forthaascommaname = "AAS,";void dg_forthaascomma (Bufferhandle* pBHarrayhead){    const char c = 0x3F;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, &c, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthaascommaname);    }}const char* dg_forthaadcommaname = "AAD,";void dg_forthaadcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD5\x0A";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthaadcommaname);    }}const char* dg_forthaamcommaname = "AAM,";void dg_forthaamcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD4\x0A";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthaamcommaname);    }}const char* dg_forthcpuidcommaname = "CPUID,";void dg_forthcpuidcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\xA2";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcpuidcommaname);    }}const char* dg_forthswapgscommaname = "SWAPGS,";void dg_forthswapgscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xF8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthswapgscommaname);    }}const char* dg_forthsyscallcommaname = "SYSCALL,";void dg_forthsyscallcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x05";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsyscallcommaname);    }}const char* dg_forthsysretto32commaname = "SYSRETTO32,";void dg_forthsysretto32comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x07";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsysretto32commaname);    }}const char* dg_forthsysretto64commaname = "SYSRETTO64,";void dg_forthsysretto64comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x48\x0F\x07";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsysretto64commaname);    }}const char* dg_forthrepcommaname = "REP,";void dg_forthrepcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xF3";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrepcommaname);    }}const char* dg_forthrepecommaname = "REPE,";const char* dg_forthnzuntilrepcommaname = "NZUNTILREP,";void dg_forthrepecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xF3";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrepecommaname);    }}const char* dg_forthrepnecommaname = "REPNE,";const char* dg_forthzsuntilrepcommaname = "ZSUNTILREP,";void dg_forthrepnecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xF2";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrepnecommaname);    }}const char* dg_forthlockcommaname = "LOCK,";void dg_forthlockcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xF0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlockcommaname);    }}const char* dg_forthmovsbcommaname = "MOVSB,";void dg_forthmovsbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xA4";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmovsbcommaname);    }}const char* dg_forthmovsdcommaname = "MOVSD,";void dg_forthmovsdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xA5";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmovsdcommaname);    }}const char* dg_forthmovsqcommaname = "MOVSQ,";void dg_forthmovsqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\xA5";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmovsqcommaname);    }}const char* dg_forthmovswcommaname = "MOVSW,";void dg_forthmovswcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\xA5";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmovswcommaname);    }}const char* dg_forthcmpsbcommaname = "CMPSB,";void dg_forthcmpsbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xA6";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcmpsbcommaname);    }}const char* dg_forthcmpsdcommaname = "CMPSD,";void dg_forthcmpsdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xA7";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcmpsdcommaname);    }}const char* dg_forthcmpsqcommaname = "CMPSQ,";void dg_forthcmpsqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\xA7";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcmpsqcommaname);    }}const char* dg_forthcmpswcommaname = "CMPSW,";void dg_forthcmpswcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\xA7";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcmpswcommaname);    }}const char* dg_forthinsbcommaname = "INSB,";void dg_forthinsbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x6C";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthinsbcommaname);    }}const char* dg_forthinswcommaname = "INSW,";void dg_forthinswcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;    unsigned char pbuf[3] = "\x66\x6D";  // This is probably right        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinswcommaname);        return;    }        if (4 != addresssize)    {        dg_pusherror(pBHarrayhead, (const char*)" instruction only supported in 32 bit addressing mode");        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthinswcommaname);    }}const char* dg_forthinsdcommaname = "INSD,";void dg_forthinsdcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;    unsigned char pbuf[3] = "\x67\x6D";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinsdcommaname);        return;    }        if (4 == addresssize)    {        dg_compilesegment (pBHarrayhead, (const char*)(pbuf + 1), 1);    }    else    {        // address size is 8        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);    }        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthinsdcommaname);    }}const char* dg_forthinsqcommaname = "INSQ,";void dg_forthinsqcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;    unsigned char pbuf[2] = "\x6D";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinsqcommaname);        return;    }        if (8 != addresssize)    {        dg_pusherror(pBHarrayhead, (const char*)" instruction only supported in 64 bit addressing mode");        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthinsqcommaname);    }}const char* dg_forthoutsbcommaname = "OUTSB,";void dg_forthoutsbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x6E";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthoutsbcommaname);    }}const char* dg_forthoutswcommaname = "OUTSW,";void dg_forthoutswcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;    unsigned char pbuf[3] = "\x66\x6F";  // This is probably right        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthinswcommaname);        return;    }        if (4 != addresssize)    {        dg_pusherror(pBHarrayhead, (const char*)" instruction only supported in 32 bit addressing mode");        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthoutswcommaname);    }}const char* dg_forthoutsdcommaname = "OUTSD,";void dg_forthoutsdcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;    unsigned char pbuf[3] = "\x67\x6F";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthoutsdcommaname);        return;    }        if (4 == addresssize)    {        dg_compilesegment (pBHarrayhead, (const char*)(pbuf + 1), 1);    }    else    {        // address size is 8        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);    }        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthoutsdcommaname);    }}const char* dg_forthoutsqcommaname = "OUTSQ,";void dg_forthoutsqcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;    unsigned char pbuf[2] = "\x6F";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthoutsqcommaname);        return;    }        if (8 != addresssize)    {        dg_pusherror(pBHarrayhead, (const char*)" instruction only supported in 64 bit addressing mode");        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthoutsqcommaname);    }}const char* dg_forthstosbcommaname = "STOSB,";void dg_forthstosbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xAA";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstosbcommaname);    }}const char* dg_forthstosdcommaname = "STOSD,";void dg_forthstosdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xAB";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstosdcommaname);    }}const char* dg_forthstosqcommaname = "STOSQ,";void dg_forthstosqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\xAB";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstosqcommaname);    }}const char* dg_forthstoswcommaname = "STOSW,";void dg_forthstoswcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\xAB";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthstoswcommaname);    }}const char* dg_forthlodsbcommaname = "LODSB,";void dg_forthlodsbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xAC";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlodsbcommaname);    }}const char* dg_forthlodsdcommaname = "LODSD,";void dg_forthlodsdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xAD";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlodsdcommaname);    }}const char* dg_forthlodsqcommaname = "LODSQ,";void dg_forthlodsqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\xAD";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlodsqcommaname);    }}const char* dg_forthlodswcommaname = "LODSW,";void dg_forthlodswcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\xAD";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlodswcommaname);    }}const char* dg_forthscasbcommaname = "SCASB,";void dg_forthscasbcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xAE";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthscasbcommaname);    }}const char* dg_forthscasdcommaname = "SCASD,";void dg_forthscasdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xAF";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthscasdcommaname);    }}const char* dg_forthscasqcommaname = "SCASQ,";void dg_forthscasqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\xAF";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthscasqcommaname);    }}const char* dg_forthscaswcommaname = "SCASW,";void dg_forthscaswcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\xAF";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthscaswcommaname);    }}const char* dg_forthleavecommaname = "LEAVE,";void dg_forthleavecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xC9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthleavecommaname);    }}const char* dg_forthmfencecommaname = "MFENCE,";void dg_forthmfencecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\xAE\xF0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmfencecommaname);    }}const char* dg_forthmonitorcommaname = "MONITOR,";void dg_forthmonitorcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xC8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmonitorcommaname);    }}const char* dg_forthmwaitcommaname = "MWAIT,";void dg_forthmwaitcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xC9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthmwaitcommaname);    }}const char* dg_forthpausecommaname = "PAUSE,";void dg_forthpausecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xF3\x90";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthpausecommaname);    }}const char* dg_forthpopadcommaname = "POPAD,";void dg_forthpopadcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x61";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthpopadcommaname);    }}const char* dg_forthpopfcommaname = "POPF,";const char* dg_forthpopfdcommaname = "POPFD,";const char* dg_forthpopfqcommaname = "POPFQ,";// the documentation for POPF/POPFD/POPFQ is confusing, but the stuff on REX says REX is ingored for this//  instruction in 64 bit mode and the data size is 64 bits by default.void dg_forthpopfdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x9D";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthpopfdcommaname);    }}const char* dg_forthpushadcommaname = "PUSHAD,";void dg_forthpushadcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x60";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthpushadcommaname);    }}const char* dg_forthpushfcommaname = "PUSHF,";const char* dg_forthpushfdcommaname = "PUSHFD,";const char* dg_forthpushfqcommaname = "PUSHFQ,";// in 64 bit mode the data size for PUSHF, PUSHFD, PUSHFQ, is 64 bits no matter what and rex.w is ignored.void dg_forthpushfdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x9C";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthpushfdcommaname);    }}const char* dg_forthrsmcommaname = "RSM,";void dg_forthrsmcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\xAA";        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrsmcommaname);        return;    }        if (4 != addresssize)    {        dg_pusherror(pBHarrayhead, (const char*)" instruction only supported in 32 bit addressing mode");        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrsmcommaname);    }}const char* dg_forthsysentercommaname = "SYSENTER,";void dg_forthsysentercomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x34";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsysentercommaname);    }}const char* dg_forthsysexitcommaname = "SYSEXIT,";void dg_forthsysexitcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x35";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsysexitcommaname);    }}const char* dg_forthwaitcommaname = "WAIT,";void dg_forthwaitcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x9B";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthwaitcommaname);    }}const char* dg_forthiretdcommaname = "IRETD,";void dg_forthiretdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xCF";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthiretdcommaname);    }}const char* dg_forthiretqcommaname = "IRETQ,";void dg_forthiretqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\xCF";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthiretqcommaname);    }}const char* dg_forthaltoaxcommaname = "AL->AX,";const char* dg_forthcbwcommaname = "CBW,";void dg_forthcbwcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\x98";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcbwcommaname);    }}const char* dg_fortheaxtoedxeaxcommaname = "EAX->EDX:EAX,";const char* dg_forthcdqcommaname = "CDQ,";void dg_forthcdqcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x99";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcdqcommaname);    }}const char* dg_forthaxtodxaxcommaname = "AX->DX:AX,";const char* dg_forthcwdcommaname = "CWD,";void dg_forthcwdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x66\x99";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcwdcommaname);    }}const char* dg_forthraxtordxraxcommaname = "RAX->RDX:RAX,";const char* dg_forthcqocommaname = "CQO,";void dg_forthcqocomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\x99";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcqocommaname);    }}const char* dg_forthaxtoeaxcommaname = "AX->EAX,";const char* dg_forthcwdecommaname = "CWDE,";void dg_forthcwdecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\x98";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcwdecommaname);    }}const char* dg_fortheaxtoraxcommaname = "EAX->RAX,";const char* dg_forthcdqecommaname = "CDQE,";void dg_forthcdqecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x48\x98";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcdqecommaname);    }}const char* dg_forthsfencecommaname = "SFENCE,";void dg_forthsfencecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\xAE\xF8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthsfencecommaname);    }}const char* dg_forthemmscommaname = "EMMS,";void dg_forthemmscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x77";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthemmscommaname);    }}const char* dg_forthrdmsrcommaname = "RDMSR,";void dg_forthrdmsrcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x32";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrdmsrcommaname);    }}const char* dg_forthrdpmccommaname = "RDPMC,";void dg_forthrdpmccomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x33";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrdpmccommaname);    }}const char* dg_forthrdtsccommaname = "RDTSC,";void dg_forthrdtsccomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x31";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrdtsccommaname);    }}const char* dg_forthrdtscpcommaname = "RDTSCP,";void dg_forthrdtscpcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xF9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthrdtscpcommaname);    }}const char* dg_forthxlatbcommaname = "XLATB,";const char* dg_forthbracketrbxplusaltoalname = "[RBX+AL]->AL";void dg_forthxlatbcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        unsigned char pbuf[3] = "\x48\xD7";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    /*    addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxlatbcommaname);        return;    }    */    // looks like rex.w is not required...  not sure why it is in the opcode list in the documentation    //  the HDL description in the documentation shows it is not required 3/6/2020    // if (addresssize == 8)    // {    //     dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);    // }    // else    // {        dg_compilesegment (pBHarrayhead, (const char*)(pbuf + 1), 1);    // }        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxlatbcommaname);    }}const char* dg_forthf2xm1commaname = "F2XM1,";void dg_forthf2xm1comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthf2xm1commaname);    }}const char* dg_forthfabscommaname = "FABS,";void dg_forthfabscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xE1";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfabscommaname);    }}const char* dg_forthfchscommaname = "FCHS,";void dg_forthfchscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xE0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfchscommaname);    }}const char* dg_forthfclexcommaname = "FCLEX,";void dg_forthfclexcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x9B\xDB\xE2";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfclexcommaname);    }}const char* dg_forthfnclexcommaname = "FNCLEX,";void dg_forthfnclexcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xDB\xE2";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfnclexcommaname);    }}const char* dg_forthfcoscommaname = "FCOS,";void dg_forthfcoscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xFF";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfcoscommaname);    }}const char* dg_forthfdecstpcommaname = "FDECSTP,";void dg_forthfdecstpcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF6";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfdecstpcommaname);    }}const char* dg_forthfincstpcommaname = "FINCSTP,";void dg_forthfincstpcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF7";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfincstpcommaname);    }}const char* dg_forthfinitcommaname = "FINIT,";void dg_forthfinitcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xDB\xE3";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfinitcommaname);    }}const char* dg_forthfninitcommaname = "FNINIT,";void dg_forthfninitcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x9B\xDB\xE3";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfninitcommaname);    }}const char* dg_forthfld1commaname = "FLD1,";void dg_forthfld1comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xE8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfld1commaname);    }}const char* dg_forthfldl2tcommaname = "FLDL2T,";void dg_forthfldl2tcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xE9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfldl2tcommaname);    }}const char* dg_forthfldl2ecommaname = "FLDL2E,";void dg_forthfldl2ecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xEA";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfldl2ecommaname);    }}const char* dg_forthfldpicommaname = "FLDPI,";void dg_forthfldpicomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xEB";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfldpicommaname);    }}const char* dg_forthfldlg2commaname = "FLDLG2,";void dg_forthfldlg2comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xEC";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfldlg2commaname);    }}const char* dg_forthfldln2commaname = "FLDLN2,";void dg_forthfldln2comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xED";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfldln2commaname);    }}const char* dg_forthfldzcommaname = "FLDZ,";void dg_forthfldzcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xEE";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfldzcommaname);    }}const char* dg_forthfnopcommaname = "FNOP,";void dg_forthfnopcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xD0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfnopcommaname);    }}const char* dg_forthfpatancommaname = "FPATAN,";void dg_forthfpatancomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF3";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfpatancommaname);    }}const char* dg_forthfpremcommaname = "FPREM,";void dg_forthfpremcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfpremcommaname);    }}const char* dg_forthfprem1commaname = "FPREM1,";void dg_forthfprem1comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF5";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfprem1commaname);    }}const char* dg_forthfptancommaname = "FPTAN,";void dg_forthfptancomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF2";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfptancommaname);    }}const char* dg_forthfrndintcommaname = "FRNDINT,";void dg_forthfrndintcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xFC";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfrndintcommaname);    }}const char* dg_forthfscalecommaname = "FSCALE,";void dg_forthfscalecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xFD";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfscalecommaname);    }}const char* dg_forthfsincommaname = "FSIN,";void dg_forthfsincomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xFE";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfsincommaname);    }}const char* dg_forthfsincoscommaname = "FSINCOS,";void dg_forthfsincoscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xFB";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfsincoscommaname);    }}const char* dg_forthfsqrtcommaname = "FSQRT,";void dg_forthfsqrtcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xFA";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfsqrtcommaname);    }}const char* dg_forthftstcommaname = "FTST,";void dg_forthftstcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xE4";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthftstcommaname);    }}const char* dg_forthfxamcommaname = "FXAM,";void dg_forthfxamcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xE5";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfxamcommaname);    }}const char* dg_forthfxtractcommaname = "FXTRACT,";void dg_forthfxtractcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF4";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfxtractcommaname);    }}const char* dg_forthfyl2xcommaname = "FYL2X,";void dg_forthfyl2xcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF1";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfyl2xcommaname);    }}const char* dg_forthfyl2xp1commaname = "FYL2XP1,";void dg_forthfyl2xp1comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xF9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfyl2xp1commaname);    }}const char* dg_forthfucomppcommaname = "FUCOMPP,";void dg_forthfucomppcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xDA\xE9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfucomppcommaname);    }}const char* dg_forthfstswtoaxcommaname = "FSTSW->AX,";void dg_forthfstswtoaxcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x9B\xDF\xE0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfstswtoaxcommaname);    }}const char* dg_forthfnstswtoaxcommaname = "FNSTSW->AX,";void dg_forthfnstswtoaxcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xDF\xE0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfnstswtoaxcommaname);    }}const char* dg_forthfdupcommaname = "FDUP,";void dg_forthfdupcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xC0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfdupcommaname);    }}const char* dg_forthfswapcommaname = "FSWAP,";void dg_forthfswapcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xD9\xC9";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthfswapcommaname);    }}const char* dg_forthud2commaname = "UD2,";void dg_forthud2comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x0B";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthud2commaname);    }}const char* dg_forthcltscommaname = "CLTS,";void dg_forthcltscomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x06";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthcltscommaname);    }}const char* dg_forthlfencecommaname = "LFENCE,";void dg_forthlfencecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\xAE\xE8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthlfencecommaname);    }}const char* dg_forthwbinvdcommaname = "WBINVD,";void dg_forthwbinvdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x09";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthwbinvdcommaname);    }}const char* dg_forthwrmsrcommaname = "WRMSR,";void dg_forthwrmsrcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x30";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthwrmsrcommaname);    }}const char* dg_forthxacquirecommaname = "XACQUIRE,";void dg_forthxacquirecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xF2";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxacquirecommaname);    }}/*const char* dg_forthxbegincommaname = "XBEGIN,";void dg_forthxbegincomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\xC7\xF8";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxbegincommaname);    }}*/const char* dg_forthxendcommaname = "XEND,";void dg_forthxendcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xD5";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxendcommaname);    }}const char* dg_forthxgetbvcommaname = "XGETBV,";void dg_forthxgetbvcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xD0";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxgetbvcommaname);    }}const char* dg_forthxreleasecommaname = "XRELEASE,";void dg_forthxreleasecomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xF3";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxreleasecommaname);    }}const char* dg_forthxsetbvcommaname = "XSETBV,";void dg_forthxsetbvcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xD1";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxsetbvcommaname);    }}const char* dg_forthxtestcommaname = "XTEST,";void dg_forthxtestcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4] = "\x0F\x01\xD6";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 3);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthxtestcommaname);    }}const char* dg_forthintcommaname = "INT,";void dg_forthintcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[4];    struct dg_Sibformatter myfirsttarget;        pbuf[0] = 0xCD;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_initSibformatter(&myfirsttarget);        dg_pulloneaddressingmode(        pBHarrayhead,        &myfirsttarget);            if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthintcommaname);        return;    }            if (myfirsttarget.memmode != dg_memmodeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"This instruction uses 1 immediate target.");        dg_pusherror(pBHarrayhead, dg_forthintcommaname);        return;    }        pbuf[1] = (unsigned char)(myfirsttarget.immediatevalue & 0xFF);        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthintcommaname);    }}const char* dg_forthint3commaname = "INT3,";void dg_forthint3comma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xCC";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthint3commaname);    }}const char* dg_forthintocommaname = "INTO,";void dg_forthintocomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[2] = "\xCE";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 1);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthintocommaname);    }}const char* dg_forthinvdcommaname = "INVD,";void dg_forthinvdcomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[3] = "\x0F\x08";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 2);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthinvdcommaname);    }}const char* dg_forthentercommaname = "ENTER,";void dg_forthentercomma (Bufferhandle* pBHarrayhead){    unsigned char pbuf[7];    struct dg_Sibformatter myfirsttarget;    struct dg_Sibformatter mysecondtarget;        pbuf[0] = 0xC8;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_initSibformatter(&myfirsttarget);    dg_initSibformatter(&mysecondtarget);        dg_pulloneaddressingmode(        pBHarrayhead,        &myfirsttarget);            if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthentercommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondtarget);            if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthentercommaname);        return;    }            if ( (myfirsttarget.memmode != dg_memmodeimmediate) ||         (mysecondtarget.memmode != dg_memmodeimmediate) )    {        dg_pusherror(pBHarrayhead, (const char*)"This instruction uses 2 immediate targets.");        dg_pusherror(pBHarrayhead, dg_forthentercommaname);        return;    }        *((UINT16*)(&pbuf[1])) = (UINT16)(myfirsttarget.immediatevalue & 0xFFFF);    pbuf[3] = (unsigned char)(mysecondtarget.immediatevalue & 0xFF);        dg_compilesegment (pBHarrayhead, (const char*)pbuf, 4);        if (dg_geterrorcount(pBHarrayhead) != 0)    {        dg_pusherror(pBHarrayhead, dg_forthentercommaname);    }}const char* dg_forthboundcommaname = "BOUND,";void dg_forthboundcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmem32onlyoptbl (        pBHarrayhead,        &myopcodes,        0x62);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthboundcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthboundcommaname);        return;    }}const char* dg_forthleacommaname = "LEA,";void dg_forthleacomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmem32onlyoptbl (        pBHarrayhead,        &myopcodes,        0x8D);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthleacommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthleacommaname);        return;    }}const char* dg_forthbsfcommaname = "BSF,";void dg_forthbsfcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetm32bonlyoptbl (        pBHarrayhead,        &myopcodes,        0xBC);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbsfcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbsfcommaname);        return;    }}const char* dg_forthbsrcommaname = "BSR,";void dg_forthbsrcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetm32bonlyoptbl (        pBHarrayhead,        &myopcodes,        0xBD);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbsrcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbsrcommaname);        return;    }}const char* dg_forthcmpxchgcommaname = "CMPXCHG,";void dg_forthcmpxchgcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetmembonlyoptbl (        pBHarrayhead,        &myopcodes,        0xB0);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchgcommaname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchgcommaname);        return;    }}const char* dg_forthxchgcommaname = "XCHG,";void dg_forthxchgcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchgcommaname);        return;    }        // there is a shortcut opcode for EAX<->R which is 0x90+R    //  this case is currently not handled        myopcodes.m8tor8.popcodestring[0] = (char)0x86;    myopcodes.m8tor8.opcodestringlength = 1;    myopcodes.m8tor8.opcodeextension = (UINT64)-1;        myopcodes.m32tor32.popcodestring[0] = (char)0x87;    myopcodes.m32tor32.opcodestringlength = 1;    myopcodes.m32tor32.opcodeextension = (UINT64)-1;        myopcodes.r8tom8.popcodestring[0] = (char)0x86;    myopcodes.r8tom8.opcodestringlength = 1;    myopcodes.r8tom8.opcodeextension = (UINT64)-1;        myopcodes.r32tom32.popcodestring[0] = (char)0x87;    myopcodes.r32tom32.opcodestringlength = 1;    myopcodes.r32tom32.opcodeextension = (UINT64)-1;        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchgcommaname);        return;    }}const char* dg_forthlzcntcommaname = "LZCNT,";void dg_forthlzcntcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchgcommaname);        return;    }        myopcodes.m32tor32.pprefixstring[0] = (char)0xF3;    myopcodes.m32tor32.prefixstringlength = 1;    myopcodes.m32tor32.popcodestring[0] = (char)0x0F;    myopcodes.m32tor32.popcodestring[1] = (char)0xBD;    myopcodes.m32tor32.opcodestringlength = 2;    myopcodes.m32tor32.opcodeextension = (UINT64)-1;        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlzcntcommaname);        return;    }}const char* dg_forthtzcntcommaname = "TZCNT,";void dg_forthtzcntcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcmpxchgcommaname);        return;    }        myopcodes.m32tor32.pprefixstring[0] = (char)0xF3;    myopcodes.m32tor32.prefixstringlength = 1;    myopcodes.m32tor32.popcodestring[0] = (char)0x0F;    myopcodes.m32tor32.popcodestring[1] = (char)0xBC;    myopcodes.m32tor32.opcodestringlength = 2;    myopcodes.m32tor32.opcodeextension = (UINT64)-1;        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtzcntcommaname);        return;    }}const char* dg_pullandcompilefponlyname = "dg_pullandcompilefponly";void dg_pullandcompilefponly (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefponlyname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefponlyname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be a floating point register (mmx)");        dg_pusherror(pBHarrayhead, dg_pullandcompilefponlyname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (secondtargettype != dg_targettypefpsreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be a floating point register (mmx)");        dg_pusherror(pBHarrayhead, dg_pullandcompilefponlyname);        return;    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilefponlyname);        return;    }}const char* dg_dofponlyinstructionname = "dg_dofponlyinstruction";void dg_dofponlyinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pforwardmmopcodestring,    UINT64 forwardmmopcodestringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dofponlyinstructionname);        return;    }        myopcodes.m64tofpr.opcodestringlength = forwardmmopcodestringlength;        perror = dg_movebytes(        pforwardmmopcodestring,        (unsigned char*)myopcodes.m64tofpr.popcodestring,        forwardmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dofponlyinstructionname);        return;    }        dg_pullandcompilefponly (        pBHarrayhead,        &myopcodes);             if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dofponlyinstructionname);        return;    }}const char* dg_forthmaskmovqcommaname = "MASKMOVQ,";    void dg_forthmaskmovqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dofponlyinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF7",   // pforwardfpopcodestring        2);                           // forwardfpopcodestringlength        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmaskmovqcommaname);        return;    }}const char* dg_pullandcompilexmmonlyname = "dg_pullandcompilexmmonly";void dg_pullandcompilexmmonly (    Bufferhandle* pBHarrayhead,    struct Twotargetopcodestrings* popcodes) // kinda overkill when there is only one choice...{    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);        UINT64 firsttargettype;    UINT64 secondtargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmonlyname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmonlyname);        return;    }        firsttargettype = dg_gettargettype(        pBHarrayhead,        &firsttarget);        if (firsttargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"first target pushed for this instruction must be xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmonlyname);        return;    }        secondtargettype = dg_gettargettype(        pBHarrayhead,        &secondtarget);        if (secondtargettype != dg_targettypexmmreg)    {        dg_pusherror(pBHarrayhead, (const char*)"second target pushed for this instruction must be xmm");        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmonlyname);        return;    }        dg_compiletwotargets (        pBHarrayhead,        popcodes,        &firsttarget, // top on stack        &secondtarget); // second on stack        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompilexmmonlyname);        return;    }}const char* dg_doxmmonlyinstructionname = "dg_doxmmonlyinstruction";void dg_doxmmonlyinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pforwardxmmprefixstring,    UINT64 forwardxmmprefixstringlength,    unsigned char* pforwardxmmopcodestring,    UINT64 forwardxmmopcodestringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmonlyinstructionname);        return;    }            myopcodes.m64toxmm.prefixstringlength = forwardxmmprefixstringlength;        perror = dg_movebytes(        pforwardxmmprefixstring,        (unsigned char*)myopcodes.m64toxmm.pprefixstring,        forwardxmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmonlyinstructionname);        return;    }            myopcodes.m64toxmm.opcodestringlength = forwardxmmopcodestringlength;        perror = dg_movebytes(        pforwardxmmopcodestring,        (unsigned char*)myopcodes.m64toxmm.popcodestring,        forwardxmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_doxmmonlyinstructionname);        return;    }        dg_pullandcompilexmmonly (        pBHarrayhead,        &myopcodes);             if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmonlyinstructionname);        return;    }}const char* dg_forthmaskmovdqucommaname = "MASKMOVDQU,";    void dg_forthmaskmovdqucomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmonlyinstruction(        pBHarrayhead,        (unsigned char*)"\x66",       // pforwardxmmprefixstring        1,                            // forwardxmmprefixstringlength        (unsigned char*)"\x0F\xF7",   // pforwardxmmopcodestring        2);                           // forwardxmmopcodestringlength        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmaskmovdqucommaname);        return;    }}const char* dg_dommorxmminstructionname = "dg_dommorxmminstruction";void dg_dommorxmminstruction(    Bufferhandle* pBHarrayhead,    unsigned char* pforwardmmopcodestring,    UINT64 forwardmmopcodestringlength,    unsigned char* preversemmopcodestring,    UINT64 reversemmopcodestringlength,    unsigned char* pforwardxmmprefixstring,    UINT64 forwardxmmprefixstringlength,    unsigned char* pforwardxmmopcodestring,    UINT64 forwardxmmopcodestringlength,    unsigned char* preversexmmprefixstring,    UINT64 reversexmmprefixstringlength,    unsigned char* preversexmmopcodestring,    UINT64 reversexmmopcodestringlength){    struct Twotargetopcodestrings myopcodes;    const char* perror;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl (        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }            myopcodes.m64tofpr.opcodestringlength = forwardmmopcodestringlength;        perror = dg_movebytes(        pforwardmmopcodestring,        (unsigned char*)myopcodes.m64tofpr.popcodestring,        forwardmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }            myopcodes.fprtom64.opcodestringlength = reversemmopcodestringlength;        perror = dg_movebytes(        preversemmopcodestring,        (unsigned char*)myopcodes.fprtom64.popcodestring,        reversemmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }            myopcodes.m64toxmm.prefixstringlength = forwardxmmprefixstringlength;        perror = dg_movebytes(        pforwardxmmprefixstring,        (unsigned char*)myopcodes.m64toxmm.pprefixstring,        forwardxmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }            myopcodes.m64toxmm.opcodestringlength = forwardxmmopcodestringlength;        perror = dg_movebytes(        pforwardxmmopcodestring,        (unsigned char*)myopcodes.m64toxmm.popcodestring,        forwardxmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }            myopcodes.xmmtom64.prefixstringlength = reversexmmprefixstringlength;        perror = dg_movebytes(        preversexmmprefixstring,        (unsigned char*)myopcodes.xmmtom64.pprefixstring,        reversexmmprefixstringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }            myopcodes.xmmtom64.opcodestringlength = reversexmmopcodestringlength;        perror = dg_movebytes(        preversexmmopcodestring,        (unsigned char*)myopcodes.xmmtom64.popcodestring,        reversexmmopcodestringlength);        if (perror != dg_success)    {        dg_pusherror(pBHarrayhead, dg_movebytesname);        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);             if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_dommorxmminstructionname);        return;    }}const char* dg_forthmovqcommaname = "MOVQ,";    void dg_forthmovqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x6F",   // pforwardmmopcodestring,        2,                            // forwardmmopcodestringlength,        (unsigned char*)"\x0F\x7F",   // preversemmopcodestring,        2,                            // reversemmopcodestringlength,        (unsigned char*)"\xF3",       // pforwardxmmprefixstring,        1,                            // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x7E",   // pforwardxmmopcodestring,        2,                            // forwardxmmopcodestringlength,        (unsigned char*)"\x66",       // preversexmmprefixstring,        1,                            // reversexmmprefixstringlength,        (unsigned char*)"\x0F\xD6",   // preverseopcodestring,        2);                           // reverseopcodestringlength)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovqcommaname);        return;    }}const char* dg_forthpmaddubswcommaname = "PMADDUBSW,";    void dg_forthpmaddubswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x04",   // pforwardmmopcodestring,        3,                                // forwardmmopcodestringlength,        (unsigned char*)"",               // preversemmopcodestring,        0,                                // reversemmopcodestringlength,        (unsigned char*)"\x66",           // pforwardxmmprefixstring,        1,                                // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x38\x04",   // pforwardxmmopcodestring,        3,                                // forwardxmmopcodestringlength,        (unsigned char*)"",               // preversexmmprefixstring,        0,                                // reversexmmprefixstringlength,        (unsigned char*)"",               // preverseopcodestring,        0);                               // reverseopcodestringlength)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaddubswcommaname);        return;    }}const char* dg_forthpmaddubwdcommaname = "PMADDUBWD,";    void dg_forthpmaddubwdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF5",   // pforwardmmopcodestring,        2,                                // forwardmmopcodestringlength,        (unsigned char*)"",               // preversemmopcodestring,        0,                                // reversemmopcodestringlength,        (unsigned char*)"\x66",           // pforwardxmmprefixstring,        1,                                // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xF5",   // pforwardxmmopcodestring,        2,                                // forwardxmmopcodestringlength,        (unsigned char*)"",               // preversexmmprefixstring,        0,                                // reversexmmprefixstringlength,        (unsigned char*)"",               // preverseopcodestring,        0);                               // reverseopcodestringlength)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaddubwdcommaname);        return;    }}const char* dg_forthpsadbwcommaname = "PSADBW,";    void dg_forthpsadbwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xF6",   // pforwardmmopcodestring,        2,                                // forwardmmopcodestringlength,        (unsigned char*)"",               // preversemmopcodestring,        0,                                // reversemmopcodestringlength,        (unsigned char*)"\x66",           // pforwardxmmprefixstring,        1,                                // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\xF6",   // pforwardxmmopcodestring,        2,                                // forwardxmmopcodestringlength,        (unsigned char*)"",               // preversexmmprefixstring,        0,                                // reversexmmprefixstringlength,        (unsigned char*)"",               // preverseopcodestring,        0);                               // reverseopcodestringlength)        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsadbwcommaname);        return;    }}const char* dg_doxmmrsseinstructionname = "dg_doxmmrsseinstruction";void dg_doxmmrsseinstruction(    Bufferhandle* pBHarrayhead,    unsigned char* popcodestring,    UINT64 opcodestringlength,    unsigned char* pprefixstring,    UINT64 prefixstringlength,    UINT64 xmmmemtargetsize){    struct Twotargetopcodestrings myopcodes;        UINT64 i;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"",       // pforwardmmopcodestring,        0,                        // forwardmmopcodestringlength,        (unsigned char*)"",       // preversemmopcodestring,        0,                        // reversemmopcodestringlength,        pprefixstring,            // pforwardxmmprefixstring,        prefixstringlength,       // forwardxmmprefixstringlength,        popcodestring,            // pforwardxmmopcodestring,        opcodestringlength,       // forwardxmmopcodestringlength,        (unsigned char*)"",       // preversexmmprefixstring,        0,                        // reversexmmprefixstringlength,        (unsigned char*)"",       // preverseopcodestring,        0);             if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_doxmmrsseinstructionname);        return;    }}const char* dg_forthaddpdcommaname = "ADDPD,";    void dg_forthaddpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x58",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddpdcommaname);        return;    }}const char* dg_forthaddpscommaname = "ADDPS,";    void dg_forthaddpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x58",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddpscommaname);        return;    }}const char* dg_forthaddsdcommaname = "ADDSD,";    void dg_forthaddsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x58",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddsdcommaname);        return;    }}const char* dg_forthaddsscommaname = "ADDSS,";    void dg_forthaddsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x58",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddsscommaname);        return;    }}const char* dg_forthaddsubpdcommaname = "ADDSUBPD,";    void dg_forthaddsubpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD0",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddsubpdcommaname);        return;    }}const char* dg_forthaddsubpscommaname = "ADDSUBPS,";    void dg_forthaddsubpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xD0",        2,        (unsigned char*)"\xF2",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaddsubpscommaname);        return;    }}const char* dg_forthaesdeccommaname = "AESDEC,";    void dg_forthaesdeccomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\xDE",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaesdeccommaname);        return;    }}const char* dg_forthaesdeclastcommaname = "AESDECLAST,";    void dg_forthaesdeclastcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\xDF",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaesdeclastcommaname);        return;    }}const char* dg_forthaesenccommaname = "AESENC,";    void dg_forthaesenccomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\xDC",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaesenccommaname);        return;    }}const char* dg_forthaesenclastcommaname = "AESENCLAST,";    void dg_forthaesenclastcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\xDD",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaesenclastcommaname);        return;    }}const char* dg_forthaesimccommaname = "AESIMC,";    void dg_forthaesimccomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\xDB",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthaesimccommaname);        return;    }}const char* dg_forthandpdcommaname = "ANDPD,";    void dg_forthandpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x54",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandpdcommaname);        return;    }}const char* dg_forthandpscommaname = "ANDPS,";    void dg_forthandpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x54",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandpscommaname);        return;    }}const char* dg_forthandnpdcommaname = "ANDNPD,";    void dg_forthandnpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x55",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandnpdcommaname);        return;    }}const char* dg_forthandnpscommaname = "ANDNPS,";    void dg_forthandnpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x55",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthandnpscommaname);        return;    }}const char* dg_forthblendvpdcommaname = "BLENDVPD,";    void dg_forthblendvpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x15",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblendvpdcommaname);        return;    }}const char* dg_forthblendvpscommaname = "BLENDVPS,";    void dg_forthblendvpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x14",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthblendvpscommaname);        return;    }}const char* dg_forthcomisdcommaname = "COMISD,";    void dg_forthcomisdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2F",        2,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcomisdcommaname);        return;    }}const char* dg_forthcomisscommaname = "COMISS,";    void dg_forthcomisscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2F",        2,        (unsigned char*)"",        0,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcomisscommaname);        return;    }}const char* dg_forthcvtdq2pdcommaname = "CVTDQ2PD,";    void dg_forthcvtdq2pdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xE6",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtdq2pdcommaname);        return;    }}const char* dg_forthcvtdq2pscommaname = "CVTDQ2PS,";    void dg_forthcvtdq2pscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5B",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtdq2pscommaname);        return;    }}const char* dg_forthcvtpd2dqcommaname = "CVTPD2DQ,";    void dg_forthcvtpd2dqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xE6",        2,        (unsigned char*)"\xF2",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtpd2dqcommaname);        return;    }}const char* dg_forthcvtpd2picommaname = "CVTPD2PI,";    void dg_forthcvtpd2picomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_domorxmmtofpinstruction(       pBHarrayhead,       (unsigned char*)"\x0F\x2D",       2,       (unsigned char*)"\x66",       1,       16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtpd2picommaname);        return;    }}const char* dg_forthcvtpd2pscommaname = "CVTPD2PS,";    void dg_forthcvtpd2pscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5A",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtpd2pscommaname);        return;    }}const char* dg_forthcvtps2dqcommaname = "CVTPS2DQ,";    void dg_forthcvtps2dqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5B",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtps2dqcommaname);        return;    }}const char* dg_forthcvtps2pdcommaname = "CVTPS2PD,";    void dg_forthcvtps2pdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5A",        2,        (unsigned char*)"",        0,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtps2pdcommaname);        return;    }}const char* dg_forthcvtsd2sscommaname = "CVTSD2SS,";    void dg_forthcvtsd2sscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5A",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtsd2sscommaname);        return;    }}const char* dg_forthcvtss2sdcommaname = "CVTSS2SD,";    void dg_forthcvtss2sdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5A",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvtss2sdcommaname);        return;    }}const char* dg_forthcvttpd2dqcommaname = "CVTTPD2DQ,";    void dg_forthcvttpd2dqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\xE6",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvttpd2dqcommaname);        return;    }}const char* dg_forthcvttps2dqcommaname = "CVTTPS2DQ,";    void dg_forthcvttps2dqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5B",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcvttps2dqcommaname);        return;    }}const char* dg_forthdivpdcommaname = "DIVPD,";    void dg_forthdivpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5E",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivpdcommaname);        return;    }}const char* dg_forthdivpscommaname = "DIVPS,";    void dg_forthdivpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5E",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivpscommaname);        return;    }}const char* dg_forthdivsdcommaname = "DIVSD,";    void dg_forthdivsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5E",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivsdcommaname);        return;    }}const char* dg_forthdivsscommaname = "DIVSS,";    void dg_forthdivsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5E",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdivsscommaname);        return;    }}const char* dg_forthhaddpdcommaname = "HADDPD,";    void dg_forthhaddpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x7C",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthhaddpdcommaname);        return;    }}const char* dg_forthhaddpscommaname = "HADDPS,";    void dg_forthhaddpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x7C",        2,        (unsigned char*)"\xF2",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthhaddpscommaname);        return;    }}const char* dg_forthhsubpdcommaname = "HSUBPD,";    void dg_forthhsubpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x7D",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthhsubpdcommaname);        return;    }}const char* dg_forthhsubpscommaname = "HSUBPS,";    void dg_forthhsubpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x7D",        2,        (unsigned char*)"\xF2",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthhsubpscommaname);        return;    }}const char* dg_forthmaxpdcommaname = "MAXPD,";    void dg_forthmaxpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5F",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmaxpdcommaname);        return;    }}const char* dg_forthmaxpscommaname = "MAXPS,";    void dg_forthmaxpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5F",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmaxpscommaname);        return;    }}const char* dg_forthmaxsdcommaname = "MAXSD,";    void dg_forthmaxsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5F",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmaxsdcommaname);        return;    }}const char* dg_forthmaxsscommaname = "MAXSS,";    void dg_forthmaxsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5F",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmaxsscommaname);        return;    }}const char* dg_forthminpdcommaname = "MINPD,";    void dg_forthminpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5D",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthminpdcommaname);        return;    }}const char* dg_forthminpscommaname = "MINPS,";    void dg_forthminpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5D",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthminpscommaname);        return;    }}const char* dg_forthminsdcommaname = "MINSD,";    void dg_forthminsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5D",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthminsdcommaname);        return;    }}const char* dg_forthminsscommaname = "MINSS,";    void dg_forthminsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5D",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthminsscommaname);        return;    }}const char* dg_forthmovapdcommaname = "MOVAPD,";    void dg_forthmovapdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"",         // pforwardmmopcodestring,        0,                          // forwardmmopcodestringlength,        (unsigned char*)"",         // preversemmopcodestring,        0,                          // reversemmopcodestringlength,        (unsigned char*)"\x66",     // pforwardxmmprefixstring,        1,                          // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x28", // pforwardxmmopcodestring,        2,                          // forwardxmmopcodestringlength,        (unsigned char*)"\x66",     // preversexmmprefixstring,        1,                          // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x29", // preverseopcodestring,        2);                         // reverseopcodestringlength        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovapdcommaname);        return;    }}const char* dg_forthmovapscommaname = "MOVAPS,";    void dg_forthmovapscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"",         // pforwardmmopcodestring,        0,                          // forwardmmopcodestringlength,        (unsigned char*)"",         // preversemmopcodestring,        0,                          // reversemmopcodestringlength,        (unsigned char*)"",         // pforwardxmmprefixstring,        0,                          // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x28", // pforwardxmmopcodestring,        2,                          // forwardxmmopcodestringlength,        (unsigned char*)"",         // preversexmmprefixstring,        0,                          // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x29", // preverseopcodestring,        2);                         // reverseopcodestringlength        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovapscommaname);        return;    }}const char* dg_forthmovddupcommaname = "MOVDDUP,";    void dg_forthmovddupcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x12",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovddupcommaname);        return;    }}const char* dg_forthmovdqacommaname = "MOVDQA,";    void dg_forthmovdqacomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"",         // pforwardmmopcodestring,        0,                          // forwardmmopcodestringlength,        (unsigned char*)"",         // preversemmopcodestring,        0,                          // reversemmopcodestringlength,        (unsigned char*)"\x66",     // pforwardxmmprefixstring,        1,                          // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x6F", // pforwardxmmopcodestring,        2,                          // forwardxmmopcodestringlength,        (unsigned char*)"\x66",     // preversexmmprefixstring,        1,                          // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x7F", // preverseopcodestring,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdqacommaname);        return;    }}const char* dg_forthmovdqucommaname = "MOVDQU,";    void dg_forthmovdqucomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"",         // pforwardmmopcodestring,    0,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\xF3",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x6F", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"\xF3",     // preversexmmprefixstring,    1,                          // reversexmmprefixstringlength,    (unsigned char*)"\x0F\x7F", // preverseopcodestring,    2);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovdqucommaname);        return;    }}const char* dg_forthmovsd2commaname = "MOVSD2,";    void dg_forthmovsd2comma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }     dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"",         // pforwardmmopcodestring,        0,                          // forwardmmopcodestringlength,        (unsigned char*)"",         // preversemmopcodestring,        0,                          // reversemmopcodestringlength,        (unsigned char*)"\xF2",     // pforwardxmmprefixstring,        1,                          // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x10", // pforwardxmmopcodestring,        2,                          // forwardxmmopcodestringlength,        (unsigned char*)"\xF2",     // preversexmmprefixstring,        1,                          // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x11", // preverseopcodestring,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsd2commaname);        return;    }}const char* dg_forthmovshdupcommaname = "MOVSHDUP,";    void dg_forthmovshdupcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x16",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovshdupcommaname);        return;    }}const char* dg_forthmovsldupcommaname = "MOVSLDUP,";    void dg_forthmovsldupcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x12",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsldupcommaname);        return;    }}const char* dg_forthmovsscommaname = "MOVSS,";    void dg_forthmovsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(        pBHarrayhead,        (unsigned char*)"",         // pforwardmmopcodestring,        0,                          // forwardmmopcodestringlength,        (unsigned char*)"",         // preversemmopcodestring,        0,                          // reversemmopcodestringlength,        (unsigned char*)"\xF3",     // pforwardxmmprefixstring,        1,                          // forwardxmmprefixstringlength,        (unsigned char*)"\x0F\x10", // pforwardxmmopcodestring,        2,                          // forwardxmmopcodestringlength,        (unsigned char*)"\xF3",     // preversexmmprefixstring,        1,                          // reversexmmprefixstringlength,        (unsigned char*)"\x0F\x11", // preverseopcodestring,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsscommaname);        return;    }}const char* dg_forthmovupdcommaname = "MOVUPD,";    void dg_forthmovupdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"",         // pforwardmmopcodestring,    0,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x10", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"\x66",     // preversexmmprefixstring,    1,                          // reversexmmprefixstringlength,    (unsigned char*)"\x0F\x11", // preverseopcodestring,    2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovupdcommaname);        return;    }}const char* dg_forthmovupscommaname = "MOVUPS,";    void dg_forthmovupscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"",         // pforwardmmopcodestring,    0,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"",         // pforwardxmmprefixstring,    0,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x10", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"\x0F\x11", // preverseopcodestring,    2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovupscommaname);        return;    }}const char* dg_forthmulpdcommaname = "MULPD,";    void dg_forthmulpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x59",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulpdcommaname);        return;    }}const char* dg_forthmulpscommaname = "MULPS,";    void dg_forthmulpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x59",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulpscommaname);        return;    }}const char* dg_forthmulsdcommaname = "MULSD,";    void dg_forthmulsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x59",        2,        (unsigned char*)"\xF2",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulsdcommaname);        return;    }}const char* dg_forthmulsscommaname = "MULSS,";    void dg_forthmulsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x59",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmulsscommaname);        return;    }}const char* dg_forthorpdcommaname = "ORPD,";    void dg_forthorpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x56",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthorpdcommaname);        return;    }}const char* dg_forthorpscommaname = "ORPS,";    void dg_forthorpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x56",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthorpscommaname);        return;    }}const char* dg_forthpabsbcommaname = "PABSB,";    void dg_forthpabsbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x1C",     // pforwardmmopcodestring,    3,                                  // forwardmmopcodestringlength,    (unsigned char*)"",                 // preversemmopcodestring,    0,                                  // reversemmopcodestringlength,    (unsigned char*)"\x66",             // pforwardxmmprefixstring,    1,                                  // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x1C",     // pforwardxmmopcodestring,    3,                                  // forwardxmmopcodestringlength,    (unsigned char*)"",                 // preversexmmprefixstring,    0,                                  // reversexmmprefixstringlength,    (unsigned char*)"",                 // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpabsbcommaname);        return;    }}const char* dg_forthpabswcommaname = "PABSW,";    void dg_forthpabswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x1D",     // pforwardmmopcodestring,    3,                                  // forwardmmopcodestringlength,    (unsigned char*)"",                 // preversemmopcodestring,    0,                                  // reversemmopcodestringlength,    (unsigned char*)"\x66",             // pforwardxmmprefixstring,    1,                                  // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x1D",     // pforwardxmmopcodestring,    3,                                  // forwardxmmopcodestringlength,    (unsigned char*)"",                 // preversexmmprefixstring,    0,                                  // reversexmmprefixstringlength,    (unsigned char*)"",                 // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpabswcommaname);        return;    }}const char* dg_forthpabsdcommaname = "PABSD,";    void dg_forthpabsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x1E",     // pforwardmmopcodestring,    3,                                  // forwardmmopcodestringlength,    (unsigned char*)"",                 // preversemmopcodestring,    0,                                  // reversemmopcodestringlength,    (unsigned char*)"\x66",             // pforwardxmmprefixstring,    1,                                  // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x1E",     // pforwardxmmopcodestring,    3,                                  // forwardxmmopcodestringlength,    (unsigned char*)"",                 // preversexmmprefixstring,    0,                                  // reversexmmprefixstringlength,    (unsigned char*)"",                 // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpabsdcommaname);        return;    }}const char* dg_forthpacksswbcommaname = "PACKSSWB,";    void dg_forthpacksswbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x63",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x63",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpacksswbcommaname);        return;    }}const char* dg_forthpackssdwcommaname = "PACKSSDW,";    void dg_forthpackssdwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x6B",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x6B",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpackssdwcommaname);        return;    }}const char* dg_forthpackusdwcommaname = "PACKUSDW,";    void dg_forthpackusdwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x2B",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpackusdwcommaname);        return;    }}const char* dg_forthpackuswbcommaname = "PACKUSWB,";    void dg_forthpackuswbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x67",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x67",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpackuswbcommaname);        return;    }}const char* dg_forthpaddbcommaname = "PADDB,";    void dg_forthpaddbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xFC",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xFC",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpaddbcommaname);        return;    }}const char* dg_forthpaddwcommaname = "PADDW,";    void dg_forthpaddwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xFD",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xFD",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpaddwcommaname);        return;    }}const char* dg_forthpadddcommaname = "PADDD,";    void dg_forthpadddcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xFE",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xFE",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpadddcommaname);        return;    }}const char* dg_forthpaddqcommaname = "PADDQ,";    void dg_forthpaddqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xD4",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xD4",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpaddqcommaname);        return;    }}const char* dg_forthpaddsbcommaname = "PADDSB,";    void dg_forthpaddsbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xEC",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xEC",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpaddsbcommaname);        return;    }}const char* dg_forthpaddswcommaname = "PADDSW,";    void dg_forthpaddswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xED",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xED",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpaddswcommaname);        return;    }}const char* dg_forthpaddusbcommaname = "PADDUSB,";    void dg_forthpaddusbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xDC",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xDC",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpaddusbcommaname);        return;    }}const char* dg_forthpadduswcommaname = "PADDUSW,";    void dg_forthpadduswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xDD",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xDD",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpadduswcommaname);        return;    }}const char* dg_forthpandcommaname = "PAND,";    void dg_forthpandcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xDB", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xDB", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpandcommaname);        return;    }}const char* dg_forthpandncommaname = "PANDN,";    void dg_forthpandncomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xDF", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xDF", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpandncommaname);        return;    }}const char* dg_forthpavgbcommaname = "PAVGB,";    void dg_forthpavgbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xE0",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xE0",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpavgbcommaname);        return;    }}const char* dg_forthpavgwcommaname = "PAVGW,";    void dg_forthpavgwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xE3",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xE3",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpavgwcommaname);        return;    }}const char* dg_forthpblendvbcommaname = "PBLENDVB,";    void dg_forthpblendvbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x10",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpblendvbcommaname);        return;    }}const char* dg_forthpcmpeqbcommaname = "PCMPEQB,";    void dg_forthpcmpeqbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x74",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x74",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpeqbcommaname);        return;    }}const char* dg_forthpcmpeqdcommaname = "PCMPEQD,";    void dg_forthpcmpeqdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x76",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x76",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpeqdcommaname);        return;    }}const char* dg_forthpcmpeqwcommaname = "PCMPEQW,";    void dg_forthpcmpeqwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x75",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x75",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpeqwcommaname);        return;    }}const char* dg_forthpcmpeqqcommaname = "PCMPEQQ,";    void dg_forthpcmpeqqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x29",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpeqqcommaname);        return;    }}const char* dg_forthpcmpgtbcommaname = "PCMPGTB,";    void dg_forthpcmpgtbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x64",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x64",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpgtbcommaname);        return;    }}const char* dg_forthpcmpgtdcommaname = "PCMPGTD,";    void dg_forthpcmpgtdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x66",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x66",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpgtdcommaname);        return;    }}const char* dg_forthpcmpgtqcommaname = "PCMPGTQ,";    void dg_forthpcmpgtqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x37",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpgtqcommaname);        return;    }}const char* dg_forthpcmpgtwcommaname = "PCMPGTW,";    void dg_forthpcmpgtwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x65",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x65",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcmpgtwcommaname);        return;    }}const char* dg_forthphadddcommaname = "PHADDD,";    void dg_forthphadddcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x02",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x02",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphadddcommaname);        return;    }}const char* dg_forthphaddwcommaname = "PHADDW,";    void dg_forthphaddwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x01",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x01",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphaddwcommaname);        return;    }}const char* dg_forthphaddswcommaname = "PHADDSW,";    void dg_forthphaddswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x03",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x03",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphaddswcommaname);        return;    }}const char* dg_forthphsubdcommaname = "PHSUBD,";    void dg_forthphsubdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x06",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x06",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphsubdcommaname);        return;    }}const char* dg_forthphsubwcommaname = "PHSUBW,";    void dg_forthphsubwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x05",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x05",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphsubwcommaname);        return;    }}const char* dg_forthphsubswcommaname = "PHSUBSW,";    void dg_forthphsubswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x07",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x07",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphsubswcommaname);        return;    }}const char* dg_forthphminposuwcommaname = "PHMINPOSUW,";    void dg_forthphminposuwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x41",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthphminposuwcommaname);        return;    }}const char* dg_forthpmaddwdcommaname = "PMADDWD,";    void dg_forthpmaddwdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xF5",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xF5",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaddwdcommaname);        return;    }}const char* dg_forthpmaxsbcommaname = "PMAXSB,";    void dg_forthpmaxsbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x3C",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaxsbcommaname);        return;    }}const char* dg_forthpmaxsdcommaname = "PMAXSD,";    void dg_forthpmaxsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x3D",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaxsdcommaname);        return;    }}const char* dg_forthpmaxswcommaname = "PMAXSW,";    void dg_forthpmaxswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xEE", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xEE", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaxswcommaname);        return;    }}const char* dg_forthpmaxubcommaname = "PMAXUB,";    void dg_forthpmaxubcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xDE", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xDE", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaxubcommaname);        return;    }}const char* dg_forthpmaxudcommaname = "PMAXUD,";    void dg_forthpmaxudcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x3F",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaxudcommaname);        return;    }}const char* dg_forthpmaxuwcommaname = "PMAXUW,";    void dg_forthpmaxuwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x3E",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmaxuwcommaname);        return;    }}const char* dg_forthpminsbcommaname = "PMINSB,";    void dg_forthpminsbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x38",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpminsbcommaname);        return;    }}const char* dg_forthpminsdcommaname = "PMINSD,";    void dg_forthpminsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x39",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpminsdcommaname);        return;    }}const char* dg_forthpminswcommaname = "PMINSW,";    void dg_forthpminswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xEA", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xEA", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpminswcommaname);        return;    }}const char* dg_forthpminubcommaname = "PMINUB,";    void dg_forthpminubcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xDA", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xDA", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpminubcommaname);        return;    }}const char* dg_forthpminudcommaname = "PMINUD,";    void dg_forthpminudcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x3B",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpminudcommaname);        return;    }}const char* dg_forthpminuwcommaname = "PMINUW,";    void dg_forthpminuwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x3A",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpminuwcommaname);        return;    }}const char* dg_forthpmovsxbwcommaname = "PMOVSXBW,";    void dg_forthpmovsxbwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x20",        3,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovsxbwcommaname);        return;    }}const char* dg_forthpmovsxbdcommaname = "PMOVSXBD,";    void dg_forthpmovsxbdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x21",        3,        (unsigned char*)"\x66",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovsxbdcommaname);        return;    }}const char* dg_forthpmovsxbqcommaname = "PMOVSXBQ,";    void dg_forthpmovsxbqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x22",        3,        (unsigned char*)"\x66",        1,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovsxbqcommaname);        return;    }}const char* dg_forthpmovsxwdcommaname = "PMOVSXWD,";    void dg_forthpmovsxwdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x23",        3,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovsxwdcommaname);        return;    }}const char* dg_forthpmovsxwqcommaname = "PMOVSXWQ,";    void dg_forthpmovsxwqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x24",        3,        (unsigned char*)"\x66",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovsxwqcommaname);        return;    }}const char* dg_forthpmovsxdqcommaname = "PMOVSXDQ,";    void dg_forthpmovsxdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x25",        3,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovsxdqcommaname);        return;    }}const char* dg_forthpmovzxbwcommaname = "PMOVZXBW,";    void dg_forthpmovzxbwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x30",        3,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovzxbwcommaname);        return;    }}const char* dg_forthpmovzxbdcommaname = "PMOVZXBD,";    void dg_forthpmovzxbdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x31",        3,        (unsigned char*)"\x66",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovzxbdcommaname);        return;    }}const char* dg_forthpmovzxbqcommaname = "PMOVZXBQ,";    void dg_forthpmovzxbqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x32",        3,        (unsigned char*)"\x66",        1,        2);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovzxbqcommaname);        return;    }}const char* dg_forthpmovzxwdcommaname = "PMOVZXWD,";    void dg_forthpmovzxwdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x33",        3,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovzxwdcommaname);        return;    }}const char* dg_forthpmovzxwqcommaname = "PMOVZXWQ,";    void dg_forthpmovzxwqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x34",        3,        (unsigned char*)"\x66",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovzxwqcommaname);        return;    }}const char* dg_forthpmovzxdqcommaname = "PMOVZXDQ,";    void dg_forthpmovzxdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x35",        3,        (unsigned char*)"\x66",        1,        8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmovzxdqcommaname);        return;    }}const char* dg_forthpmuldqcommaname = "PMULDQ,";    void dg_forthpmuldqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x28",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmuldqcommaname);        return;    }}const char* dg_forthpmulhrswcommaname = "PMULHRSW,";    void dg_forthpmulhrswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x0B", // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x0B", // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmulhrswcommaname);        return;    }}const char* dg_forthpmulhuwcommaname = "PMULHUW,";    void dg_forthpmulhuwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xE4",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xE4",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmulhuwcommaname);        return;    }}const char* dg_forthpmulhwcommaname = "PMULHW,";    void dg_forthpmulhwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xE5",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xE5",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmulhwcommaname);        return;    }}const char* dg_forthpmulldcommaname = "PMULLD,";    void dg_forthpmulldcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x40",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmulldcommaname);        return;    }}const char* dg_forthpmullwcommaname = "PMULLW,";    void dg_forthpmullwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xD5", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xD5", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmullwcommaname);        return;    }}const char* dg_forthpmuludqcommaname = "PMULUDQ,";    void dg_forthpmuludqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xF4",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xF4",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpmuludqcommaname);        return;    }}const char* dg_forthporcommaname = "POR,";    void dg_forthporcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xEB", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xEB", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthporcommaname);        return;    }}const char* dg_forthpshufbcommaname = "PSHUFB,";    void dg_forthpshufbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x00",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x00",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpshufbcommaname);        return;    }}const char* dg_forthpsignbcommaname = "PSIGNB,";    void dg_forthpsignbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x08",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x08",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsignbcommaname);        return;    }}const char* dg_forthpsigndcommaname = "PSIGND,";    void dg_forthpsigndcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x0A",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x0A",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsigndcommaname);        return;    }}const char* dg_forthpsignwcommaname = "PSIGNW,";    void dg_forthpsignwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x38\x09",     // pforwardmmopcodestring,    3,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x38\x09",     // pforwardxmmopcodestring,    3,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsignwcommaname);        return;    }}const char* dg_forthpsubbcommaname = "PSUBB,";    void dg_forthpsubbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xF8",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xF8",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubbcommaname);        return;    }}const char* dg_forthpsubdcommaname = "PSUBD,";    void dg_forthpsubdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xFA",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xFA",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubdcommaname);        return;    }}const char* dg_forthpsubqcommaname = "PSUBQ,";    void dg_forthpsubqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xFB",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xFB",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubqcommaname);        return;    }}const char* dg_forthpsubwcommaname = "PSUBW,";    void dg_forthpsubwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xF9",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xF9",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubwcommaname);        return;    }}const char* dg_forthpsubsbcommaname = "PSUBSB,";    void dg_forthpsubsbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xE8",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xE8",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubsbcommaname);        return;    }}const char* dg_forthpsubswcommaname = "PSUBSW,";    void dg_forthpsubswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xE9",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xE9",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubswcommaname);        return;    }}const char* dg_forthpsubusbcommaname = "PSUBUSB,";    void dg_forthpsubusbcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xD8",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xD8",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubusbcommaname);        return;    }}const char* dg_forthpsubuswcommaname = "PSUBUSW,";    void dg_forthpsubuswcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xD9",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xD9",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpsubuswcommaname);        return;    }}const char* dg_forthptestcommaname = "PTEST,";    void dg_forthptestcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x38\x17",        3,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthptestcommaname);        return;    }}const char* dg_forthpunpckhbwcommaname = "PUNPCKHBW,";    void dg_forthpunpckhbwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x68",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x68",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpckhbwcommaname);        return;    }}const char* dg_forthpunpckhwdcommaname = "PUNPCKHWD,";    void dg_forthpunpckhwdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x69",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x69",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpckhwdcommaname);        return;    }}const char* dg_forthpunpckhdqcommaname = "PUNPCKHDQ,";    void dg_forthpunpckhdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x6A",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x6A",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpckhdqcommaname);        return;    }}const char* dg_forthpunpckhqdqcommaname = "PUNPCKHQDQ,";    void dg_forthpunpckhqdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"",     // pforwardmmopcodestring,    0,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x6D",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpckhqdqcommaname);        return;    }}const char* dg_forthpunpcklbwcommaname = "PUNPCKLBW,";    void dg_forthpunpcklbwcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x60",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x60",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpcklbwcommaname);        return;    }}const char* dg_forthpunpcklwdcommaname = "PUNPCKLWD,";    void dg_forthpunpcklwdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x61",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x61",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpcklwdcommaname);        return;    }}const char* dg_forthpunpckldqcommaname = "PUNPCKLDQ,";    void dg_forthpunpckldqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\x62",     // pforwardmmopcodestring,    2,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x62",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpckldqcommaname);        return;    }}const char* dg_forthpunpcklqdqcommaname = "PUNPCKLQDQ,";    void dg_forthpunpcklqdqcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"",     // pforwardmmopcodestring,    0,                              // forwardmmopcodestringlength,    (unsigned char*)"",             // preversemmopcodestring,    0,                              // reversemmopcodestringlength,    (unsigned char*)"\x66",         // pforwardxmmprefixstring,    1,                              // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\x6C",     // pforwardxmmopcodestring,    2,                              // forwardxmmopcodestringlength,    (unsigned char*)"",             // preversexmmprefixstring,    0,                              // reversexmmprefixstringlength,    (unsigned char*)"",             // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpunpcklqdqcommaname);        return;    }}const char* dg_forthpxorcommaname = "PXOR,";    void dg_forthpxorcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_dommorxmminstruction(    pBHarrayhead,    (unsigned char*)"\x0F\xEF", // pforwardmmopcodestring,    2,                          // forwardmmopcodestringlength,    (unsigned char*)"",         // preversemmopcodestring,    0,                          // reversemmopcodestringlength,    (unsigned char*)"\x66",     // pforwardxmmprefixstring,    1,                          // forwardxmmprefixstringlength,    (unsigned char*)"\x0F\xEF", // pforwardxmmopcodestring,    2,                          // forwardxmmopcodestringlength,    (unsigned char*)"",         // preversexmmprefixstring,    0,                          // reversexmmprefixstringlength,    (unsigned char*)"",         // preverseopcodestring,    0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpxorcommaname);        return;    }}const char* dg_forthrcppscommaname = "RCPPS,";    void dg_forthrcppscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x53",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrcppscommaname);        return;    }}const char* dg_forthrcpsscommaname = "RCPSS,";    void dg_forthrcpsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x53",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrcpsscommaname);        return;    }}const char* dg_forthrsqrtpscommaname = "RSQRTPS,";    void dg_forthrsqrtpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x52",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrsqrtpscommaname);        return;    }}const char* dg_forthrsqrtsscommaname = "RSQRTSS,";    void dg_forthrsqrtsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x52",        2,        (unsigned char*)"\xF3",        1,        4);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthrsqrtsscommaname);        return;    }}const char* dg_forthsqrtpdcommaname = "SQRTPD,";    void dg_forthsqrtpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x51",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsqrtpdcommaname);        return;    }}const char* dg_forthsqrtpscommaname = "SQRTPS,";    void dg_forthsqrtpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x51",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsqrtpscommaname);        return;    }}const char* dg_forthsqrtsdcommaname = "SQRTSD,";    void dg_forthsqrtsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x51",        2,        (unsigned char*)"\xF2",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsqrtsdcommaname);        return;    }}const char* dg_forthsqrtsscommaname = "SQRTSS,";    void dg_forthsqrtsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x51",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsqrtsscommaname);        return;    }}const char* dg_forthsubpdcommaname = "SUBPD,";    void dg_forthsubpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5C",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsubpdcommaname);        return;    }}const char* dg_forthsubpscommaname = "SUBPS,";    void dg_forthsubpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5C",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsubpscommaname);        return;    }}const char* dg_forthsubsdcommaname = "SUBSD,";    void dg_forthsubsdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5C",        2,        (unsigned char*)"\xF2",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsubsdcommaname);        return;    }}const char* dg_forthsubsscommaname = "SUBSS,";    void dg_forthsubsscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x5C",        2,        (unsigned char*)"\xF3",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthsubsscommaname);        return;    }}const char* dg_forthucomisdcommaname = "UCOMISD,";    void dg_forthucomisdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2E",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthucomisdcommaname);        return;    }}const char* dg_forthucomisscommaname = "UCOMISS,";    void dg_forthucomisscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x2E",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthucomisscommaname);        return;    }}const char* dg_forthunpckhpdcommaname = "UNPCKHPD,";    void dg_forthunpckhpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x15",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthunpckhpdcommaname);        return;    }}const char* dg_forthunpckhpscommaname = "UNPCKHPS,";    void dg_forthunpckhpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x15",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthunpckhpscommaname);        return;    }}const char* dg_forthunpcklpdcommaname = "UNPCKLPD,";    void dg_forthunpcklpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x14",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthunpcklpdcommaname);        return;    }}const char* dg_forthunpcklpscommaname = "UNPCKLPS,";    void dg_forthunpcklpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x14",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthunpcklpscommaname);        return;    }}const char* dg_forthxorpdcommaname = "XORPD,";    void dg_forthxorpdcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x57",        2,        (unsigned char*)"\x66",        1,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxorpdcommaname);        return;    }}const char* dg_forthxorpscommaname = "XORPS,";    void dg_forthxorpscomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;         UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);         if (baderrorcount == olderrorcount)    {        return;    }        dg_doxmmrsseinstruction(        pBHarrayhead,        (unsigned char*)"\x0F\x57",        2,        (unsigned char*)"",        0,        16);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxorpscommaname);        return;    }}const char* dg_forthcodename = "CODE";void dg_forthcode (Bufferhandle* pBHarrayhead){    UINT64 assemblerwordlist;        UINT64 olderrorcount = 0;    unsigned char c = 0;    UINT64 definition = 0;    UINT64 namelength = 0;    unsigned char* pname = NULL;        UINT64 ccbufid;    unsigned char* pccbuf;    UINT64* pccbuflength;    olderrorcount = dg_geterrorcount(pBHarrayhead);        ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }        pccbuf = dg_getpbuffer(        pBHarrayhead,        ccbufid,        &pccbuflength);    if (pccbuf == (unsigned char*)badbufferhandle)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }    pname = dg_parseword(       pBHarrayhead,       &namelength);     if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }    if (namelength == 0)    {        dg_pusherror(pBHarrayhead, dg_wordlength0error);        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }        // changed this to compile type cdecl 5/3/2017    definition = dg_newwordcopyname(        pBHarrayhead,         (UINT64)DG_CORE_BUFFERID,         // compile type routine buffer        (UINT64)&dg_forthdocompiletypecall, // (UINT64)&dg_forthdocompiletypecdecl,  // compile type routine offset        ccbufid,                  // data buffer id which is current compile buffer        *pccbuflength,            // data offset which is current compile offset        (UINT64)DG_CORE_BUFFERID,        (UINT64)pname,         namelength);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }    dg_forthleftbracket(pBHarrayhead);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        definition);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_codesysmarker);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthcodename);        return;    }    dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        coloncallssafeflag,        FORTH_FALSE);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcodename);    }        assemblerwordlist = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_cpux86vocabid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcodename);    }        dg_pushbufferuint64(        pBHarrayhead,        DG_SEARCHORDERSTACK_BUFFERID,        assemblerwordlist);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcodename);    }}const char* dg_forthocodename = "OCODE";void dg_forthocode (Bufferhandle* pBHarrayhead){    UINT64 assemblerwordlist;        UINT64 olderrorcount = 0;    unsigned char c = 0;    UINT64 definition = 0;    UINT64 namelength = 0;    unsigned char* pname = NULL;    Bufferhandle* pBH = NULL;        UINT64 ccbufid;    unsigned char* pccbuf;    UINT64* pccbuflength;    olderrorcount = dg_geterrorcount(pBHarrayhead);        ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }        pccbuf = dg_getpbuffer(        pBHarrayhead,        ccbufid,        &pccbuflength);    if (pccbuf == (unsigned char*)badbufferhandle)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }     pname = dg_parseword(       pBHarrayhead,       &namelength);               if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }    if (namelength == 0)    {        dg_pusherror(pBHarrayhead, dg_wordlength0error);        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }        definition = dg_newwordcopyname(        pBHarrayhead,         (UINT64)DG_CORE_BUFFERID,         // compile type routine buffer        (UINT64)&dg_forthdocompiletypedpushn, // (UINT64)&dg_forthdocompiletypecdecl,  // compile type routine offset        ccbufid,                  // data buffer id which is current compile buffer        *pccbuflength,            // data offset which is current compile offset        (UINT64)DG_CORE_BUFFERID,        (UINT64)pname,         namelength);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }    dg_forthleftbracket(pBHarrayhead);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        definition);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_codesysmarker);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthocodename);        return;    }    dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        coloncallssafeflag,        FORTH_FALSE);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthocodename);    }        assemblerwordlist = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_cpux86vocabid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthocodename);    }        dg_pushbufferuint64(        pBHarrayhead,        DG_SEARCHORDERSTACK_BUFFERID,        assemblerwordlist);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthocodename);    }}const char* dg_forthendcodename = "END-CODE";void dg_forthendcode (Bufferhandle* pBHarrayhead){    UINT64* pbuflength;    unsigned char* pdatastack;    UINT64 isdefaultsafe;    INT64* pints;    UINT64 ccwordlist;    UINT64 assemblerwordlist;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    dg_forthqueryclearlocals(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    dg_forthleftbracket(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    pdatastack = dg_getpbuffer(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        &pbuflength);    if (pdatastack == (unsigned char*)badbufferhandle)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    if (*pbuflength < (2 * sizeof(UINT64)) )    {        dg_pusherror(pBHarrayhead, dg_datastackunderflowerror);        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    // could check for misaligned data stack here    pints = (INT64*)(pdatastack + *pbuflength - (2 * sizeof(UINT64)));    if (pints[1] != (INT64)dg_codesysmarker)    {        dg_pusherror(pBHarrayhead, dg_colonsysmissingerror);        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    // not checking the definition?    ccwordlist = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilewordlist);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcreatewordlistname);        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    dg_linkdefinition(        pBHarrayhead,        ccwordlist,        pints[0]);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    *pbuflength -= 2* sizeof(UINT64);    isdefaultsafe = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        coloncallssafeflag);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcoloncallssafeflagname);        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }    if (FORTH_FALSE != isdefaultsafe)    {        dg_forthsafe(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthendcodename);            return;        }    }        assemblerwordlist = dg_popbufferuint64(        pBHarrayhead,        DG_SEARCHORDERSTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcoloncallssafeflagname);        dg_pusherror(pBHarrayhead, dg_forthendcodename);        return;    }}const char* dg_forthbegincommaname = "BEGIN,";void dg_forthbegincomma(Bufferhandle* pBHarrayhead){    dg_forthbegin(pBHarrayhead);}const char* dg_forthuntilcommaname = "UNTIL,";void dg_forthuntilcomma (Bufferhandle* pBHarrayhead)// ( cc -- ){    UINT64 conditioncode;    UINT64 beginoffset;    UINT64 afterbranchoffset;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        conditioncode = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthuntilcommaname);        return;    }        beginoffset = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthuntilcommaname);        return;    }        afterbranchoffset = dg_compilebranch(pBHarrayhead, conditioncode ^ 1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthuntilcommaname);        return;    }        dg_resolvecompiledbranch(pBHarrayhead, afterbranchoffset, beginoffset);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthuntilcommaname);        return;    }}const char* dg_compileloopwhilecommaname = "dg_compileloopwhilecomma";void dg_compileloopwhilecomma (    Bufferhandle* pBHarrayhead,    UINT64 baseopcode){    // ( beginoffset -- loopwhileoffset beginoffset )    UINT64 cbufferid;    UINT64 afterloopoffset;    UINT64 afterwhileoffset;    unsigned char mybuf[4];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        cbufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compileloopwhilecommaname);    }        mybuf[0] = (unsigned char)(baseopcode & 0xff);    mybuf[1] = 5;        dg_compilesegment(        pBHarrayhead,        (const char*)mybuf,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopwhilecommaname);        return;    }        afterloopoffset = dg_getbufferlength(        pBHarrayhead,        cbufferid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopwhilecommaname);        return;    }        afterwhileoffset = dg_compilebranch(        pBHarrayhead,        DG_BRANCHTYPE_ALWAYS);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopwhilecommaname);        return;    }            dg_pushdatastack(        pBHarrayhead,        afterwhileoffset);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopwhilecommaname);        return;    }        dg_forthswap(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopwhilecommaname);        return;    }}const char* dg_forthloopwhilecommaname = "LOOPNOTDONEWHILE,";void dg_forthloopwhilecomma(Bufferhandle* pBHarrayhead){    dg_compileloopwhilecomma (        pBHarrayhead,        0xE2);}const char* dg_forthnzorloopwhilecommaname = "NZORLOOPNOTDONEWHILE,";const char* dg_forthneorloopwhilecommaname = "NEORLOOPNOTDONEWHILE,";void dg_forthnzorloopwhilecomma(Bufferhandle* pBHarrayhead){    dg_compileloopwhilecomma (        pBHarrayhead,        0xE0);}const char* dg_forthzsorloopwhilecommaname = "ZSORLOOPNOTDONEWHILE,";const char* dg_fortheqorloopwhilecommaname = "EQORLOOPNOTDONEWHILE,";void dg_forthzsorloopwhilecomma(Bufferhandle* pBHarrayhead){    dg_compileloopwhilecomma (        pBHarrayhead,        0xE1);}const char* dg_compileloopuntilcommaname = "dg_compileloopuntilcomma";void dg_compileloopuntilcomma(    Bufferhandle* pBHarrayhead,    UINT64 baseopcode){    UINT64 beginoffset;    UINT64 afterbranchoffset;    UINT64 cbufferid;    INT64 branchdistance;    unsigned char mybuf[4];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        beginoffset = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);        return;    }        cbufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthpcurrentcompilebuffername);        dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);    }        // gonna assume no overflow... should be ok since bufferlengths are limited to 2gig    afterbranchoffset = 2 + dg_getbufferlength(        pBHarrayhead,        cbufferid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);        return;    }        branchdistance = beginoffset - afterbranchoffset;        // if branch offset is 8 bit or less. just compile regular branch    if ( (branchdistance < -0x80) ||         (branchdistance > 0x7f) )    {        mybuf[0] = baseopcode;        mybuf[1] = (unsigned char)(branchdistance & 0xff);            dg_compilesegment(            pBHarrayhead,            (const char*)mybuf,            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);            return;        }                return;    }        dg_pushdatastack(pBHarrayhead, beginoffset);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);        return;    }        dg_compileloopwhilecomma (        pBHarrayhead,        baseopcode);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);        return;    }        dg_forthrepeat(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileloopuntilcommaname);        return;    }}// I could make these support long branches easily...//  just make loop offset = +5,//    compile branch always +5,//    compile branch always to begin offsetconst char* dg_forthloopcommaname = "LOOPDONEUNTIL,";// could call this LOOPECX,  would be easier to remembervoid dg_forthloopcomma (Bufferhandle* pBHarrayhead)// ( cc -- ){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_compileloopuntilcomma(        pBHarrayhead,        0xE2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthloopcommaname);        return;    }}const char* dg_forthloopnecommaname = "ZSORLOOPDONEUNTIL,";const char* dg_forthloopnzcommaname = "EQORLOOPDONEUNTIL,";void dg_forthloopnzcomma (Bufferhandle* pBHarrayhead)// ( cc -- ){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_compileloopuntilcomma(        pBHarrayhead,        0xE0);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthloopnzcommaname);        return;    }}const char* dg_forthloopeqcommaname = "NEORLOOPDONEUNTIL,";const char* dg_forthloopzscommaname = "NZORLOOPDONEUNTIL,";// could call this LOOPECXEQ or LOOPECXZSvoid dg_forthloopzscomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    dg_compileloopuntilcomma(        pBHarrayhead,        0xE1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthloopzscommaname);        return;    }}const char* dg_forthifcommaname = "IF,";void dg_forthifcomma (Bufferhandle* pBHarrayhead)// ( cc -- ifoffset ){    UINT64 conditioncode;    UINT64 afterbranchoffset;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        conditioncode = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthifcommaname);        return;    }        conditioncode = conditioncode ^ 1;        afterbranchoffset = dg_compilebranch(        pBHarrayhead,        conditioncode);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthifcommaname);        return;    }        dg_pushdatastack(        pBHarrayhead,        afterbranchoffset);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthifcommaname);        return;    }}const char* dg_forthwhilecommaname = "WHILE,";void dg_forthwhilecomma (Bufferhandle* pBHarrayhead)// ( beginoffset cc -- whileoffset beginoffset ){        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_forthifcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthwhilecommaname);        return;    }        dg_forthswap(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthwhilecommaname);        return;    }}const char* dg_forthelsecommaname = "ELSE,";// calls dg_forthelseconst char* dg_forththencommaname = "THEN,";// calls dg_forththenconst char* dg_forthrepeatcommaname = "REPEAT,";// calls dg_forthrepeat// this means use the smallest immediate value possible with the instructionconst char* dg_forthzeroimmediatename = "N";void dg_forthzeroimmediate (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 0);    dg_pushdatastack(pBHarrayhead, dg_isimmediate);}// this means use the smallest displacement value possible with the instructionconst char* dg_forthbracketrname = "[R]";void dg_forthbracketr (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 0);  // displacement value    dg_pushdatastack(pBHarrayhead, 0);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isbasedisplacement);}// this means use the smallest displacement value possible with the instructionconst char* dg_forthbracketrplusdname = "[R+N]";void dg_forthbracketrplusd (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 0);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isbasedisplacement);}// this means use the smallest displacement value possible with the instructionconst char* dg_forthbracketdname = "[N]";  void dg_forthbracketd (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, dg_noreg);    dg_forthswap(pBHarrayhead);    dg_pushdatastack(pBHarrayhead, 0);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isbasedisplacement);}// this means use the smallest displacement value possible with the instructionconst char* dg_forthbracketrpsxrpdname = "[R+S*R+N]";void dg_forthbracketrpsxrpd (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 0);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isbasescaleindexdisplacement);}// this means use the smallest displacement value possible with the instructionconst char* dg_forthbracketrpsxymmrpnname = "[R+S*YMMR+N]";void dg_forthbracketrpsxymmrpn (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 0);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isbasescalevindexdisplacement);}const char* dg_forthdatasizebytename = "8BIT";void dg_forthdatasizebyte (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 1);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthdatasizewordname = "16BIT";void dg_forthdatasizeword (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 2);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthdatasizedwordname = "32BIT";void dg_forthdatasizedword (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 4);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthdatasizeqwordname = "64BIT";void dg_forthdatasizeqword (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 8);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthdatasize80bitname = "80BIT";void dg_forthdatasize80bit (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 10);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthdatasize128bitname = "128BIT";void dg_forthdatasize128bit (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 16);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthdatasize256bitname = "256BIT";void dg_forthdatasize256bit (Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, 32);  // displacement size    dg_pushdatastack(pBHarrayhead, dg_isdatasize);}const char* dg_forthx86wordlistname = "X86-WORDLIST";void dg_forthx86wordlist (Bufferhandle* pBHarrayhead){    UINT64 x86wordlist;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        x86wordlist = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_cpux86vocabid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthx86wordlistname);        return;    }        dg_pushdatastack(pBHarrayhead, x86wordlist);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthx86wordlistname);        return;    }}const char* dg_forthxbeginbranchcommaname = "XBEGINBRANCH,";void dg_forthxbeginbranchcomma (Bufferhandle* pBHarrayhead)// ( -- afterbranchoffset ){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pushdatastack(pBHarrayhead, 0); // offset to be determined later        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxbeginbranchcommaname);        return;    }        dg_forthxbeginn32comma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxbeginbranchcommaname);        return;    }        dg_forthohere(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxbeginbranchcommaname);        return;    }}const char* dg_compilebitoprofrname = "dg_compilebitoprofr";void dg_compilebitoprofr (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* psourceregtarget,  // holds count    struct dg_Sibformatter* pdestregtarget,  // indexes start of bit array    UINT64 baseopcode){    UINT64 addresssize;    unsigned char mybuf[3];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitoprofrname);        return;    }        // not supporting ah, bh, ch, or dh... would require using addition instructions    if ( (psourceregtarget->basereg >= 4) &&         (psourceregtarget->basereg < 8) )    {        dg_pusherror(pBHarrayhead, (const char*)"ah, bh, ch, and dh not support in r of r mode");        dg_pusherror(pBHarrayhead, dg_compilebitoprofrname);        return;    }        if ( (pdestregtarget->basereg >= 4) &&         (pdestregtarget->basereg < 8) )    {        dg_pusherror(pBHarrayhead, (const char*)"ah, bh, ch, and dh not support in r of r mode");        dg_pusherror(pBHarrayhead, dg_compilebitoprofrname);        return;    }        // these don't have prefixes I think        dg_compilerex (        pBHarrayhead,        pdestregtarget,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitoprofrname);        return;    }        // only low 5 bits of count are used so source size doesn't matter    // dest size doesn't really matter since count is doing the indexing    // so always going to use 32 bit mode        // mod = 3 for r to r, targetreg = sourcereg, modr/m = destreg    mybuf[0] = 0x0f;    mybuf[1] = baseopcode;    mybuf[2] = dg_packmodrslashm(        3,        psourceregtarget->basereg & 7,        pdestregtarget->basereg & 7);            dg_compilesegment (        pBHarrayhead,        (const char*)&mybuf[0],        3);                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitoprofrname);        return;    }}const char* dg_compilebitoprofmname = "dg_compilebitoprofm";void dg_compilebitoprofm (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* pregtarget,  // holds count    struct dg_Sibformatter* pmemtarget,  // indexes start of bit array    UINT64 baseopcode){    UINT64 regsize;    UINT64 regtarget;    UINT64 addresssize;        unsigned char mybuf[3];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);        return;    }        // could check to make sure reg is one of the known regs        regtarget = pregtarget->basereg;        regsize = dg_getsizefromreg(regtarget);        switch (regsize)    {        case 1:            dg_pusherror(pBHarrayhead, (const char*)"8 bit registers are not supported in bit r of m mode");            dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);            return;            break;                case 2:            dg_formatpsf(                pBHarrayhead,                pmemtarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                    mybuf[0] = 0x66; // this is a prefix.... hmm            mybuf[1] = 0x0f;            mybuf[2] = baseopcode;                    // I think this is a prefix            dg_compilesegment (                pBHarrayhead,                (const char*)&mybuf[0],                1);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                        dg_compilerex (                pBHarrayhead,                pmemtarget,                addresssize);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                        dg_compilesegment (                pBHarrayhead,                 (const char*)&mybuf[1],                2);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                        pmemtarget->targetreg = pregtarget->basereg;            dg_compilepsf (                pBHarrayhead,                pmemtarget);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                        break;                case 8:        case 4:            dg_formatpsf(                pBHarrayhead,                pmemtarget);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                    // no prefix                        dg_compilerex (                pBHarrayhead,                pmemtarget,                addresssize);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                        mybuf[0] = 0x0f;            mybuf[1] = baseopcode;                        dg_compilesegment (                pBHarrayhead,                 (const char*)&mybuf[0],                2);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }                        pmemtarget->targetreg = pregtarget->basereg;            dg_compilepsf (                pBHarrayhead,                pmemtarget);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);                return;            }            break;                    default:            dg_pusherror(pBHarrayhead, (const char*)"unknown reg size");            dg_pusherror(pBHarrayhead, dg_compilebitoprofmname);            return;            break;    }}const char* dg_compilebitopnofrname = "dg_compilebitopnofr";void dg_compilebitopnofr (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* pimmediatetarget,    struct dg_Sibformatter* pregtarget,    UINT64 opcodeextension){    UINT64 addresssize;    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofrname);        return;    }        if (pregtarget->basereg == dg_ah)    {        pregtarget->basereg = dg_al;        pimmediatetarget->immediatevalue += 8;    }        if (pregtarget->basereg == dg_bh)    {        pregtarget->basereg = dg_bl;        pimmediatetarget->immediatevalue += 8;    }        if (pregtarget->basereg == dg_ch)    {        pregtarget->basereg = dg_cl;        pimmediatetarget->immediatevalue += 8;    }        if (pregtarget->basereg == dg_dh)    {        pregtarget->basereg = dg_dl;        pimmediatetarget->immediatevalue += 8;    }        // no prefix        dg_compilerex (        pBHarrayhead,        pregtarget,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofrname);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)"\x0F\xBA",        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofrname);        return;    }        // mod = 3 for reg, r/m = basereg & 7, targetreg = opcodeextension    c = dg_packmodrslashm(3, opcodeextension, pregtarget->basereg & 7);        dg_compilesegment (        pBHarrayhead,         (const char*)&c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofrname);        return;    }        c = (unsigned char)(pimmediatetarget->immediatevalue & 0xff);        dg_compilesegment (        pBHarrayhead,         (const char*)&c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofrname);        return;    }}const char* dg_compilebitopnofmname = "dg_compilebitopnofm";void dg_compilebitopnofm (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* pimmediatetarget,    struct dg_Sibformatter* pmemtarget,    UINT64 opcodeextension){    UINT64 addresssize;    UINT64 n;    unsigned char c;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        pmemtarget->targetreg = opcodeextension;        n = pimmediatetarget->immediatevalue;        // get bit offset in 32 bit area    c = (unsigned char)(n & 0xff);        // get offset in bytes of which 32 bit area is being accessed    n = n >> 3;    n = n & 0xFFFFFFFFFFFFFFFC;    pmemtarget->displacement += n;        // bumping displacement and recalculating mod should word for both r/m and sib modes    dg_bumpdisplacementsizeifneeded(pmemtarget);        dg_setmod(pmemtarget);        dg_formatpsf(        pBHarrayhead,        pmemtarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        // no prefix        dg_compilerex (        pBHarrayhead,        pmemtarget,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)"\x0F\xBA",        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        dg_compilepsf(        pBHarrayhead,        pmemtarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)&c,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofrname);        return;    }}const char* dg_compilebitopname = "dg_compilebitop";void dg_compilebitop (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* pfirsttarget,  // top on stack    struct dg_Sibformatter* psecondtarget, // second on stack    UINT64 rofmbaseopcode,    UINT64 nofmopcodeextension) {    UINT64 twotargettype;    UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        twotargettype = dg_determine2targettype (        pBHarrayhead,        pfirsttarget,    // top on stack        psecondtarget);  // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopname);        return;    }        if ( (pfirsttarget->direction != 0) ||         (psecondtarget->direction != 0) )    {        isreverse = FORTH_TRUE;        //pfirsttarget->direction = 1;        //psecondtarget->direction = 1;    }        switch (twotargettype)    {        case dg_nton:                        dg_pusherror(pBHarrayhead, (const char*)"immediate to immediate operations not supported, just figure out result at compile time and use a constant");            dg_pusherror(pBHarrayhead, dg_compilebitopname);                        break;                    case dg_ntoa:        case dg_ntor:                    dg_compilebitopnofr (                pBHarrayhead,                psecondtarget,                pfirsttarget,                nofmopcodeextension);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                        break;            case dg_ntom:                        dg_compilebitopnofm (                pBHarrayhead,                psecondtarget,                pfirsttarget,                nofmopcodeextension);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                        break;                    case dg_aton:        case dg_rton:                    dg_compilebitopnofr (                pBHarrayhead,                pfirsttarget,                psecondtarget,                nofmopcodeextension);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                        break;                    case dg_mton:                    dg_compilebitopnofm (                pBHarrayhead,                pfirsttarget,                psecondtarget,                nofmopcodeextension);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                    break;                    // second target is used as mempsf        case dg_atoa:        case dg_ator:        case dg_rtoa:        case dg_rtor:                    if (isreverse == FORTH_FALSE)            {                dg_compilebitoprofr (                    pBHarrayhead,                    psecondtarget,  // holds count                    pfirsttarget,   // holds bit array                    rofmbaseopcode);            }            else            {                dg_compilebitoprofr (                    pBHarrayhead,                    pfirsttarget,   // holds bit array                    psecondtarget,  // holds count                    rofmbaseopcode);            }                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                        break;                        case dg_mtoa:        case dg_mtor:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"m to r\n");                        // ignore reverse...            dg_compilebitoprofm (                pBHarrayhead,                pfirsttarget,   // holds count                psecondtarget,  // indexes start of bit array                rofmbaseopcode);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                        break;                                case dg_atom:        case dg_rtom:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"r to m\n");                        // ignore reverse...            dg_compilebitoprofm (                pBHarrayhead,                psecondtarget,   // holds count                pfirsttarget,    // indexes start of bit array                rofmbaseopcode);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compilebitopname);                return;            }                break;                case dg_mtom:            dg_pusherror(pBHarrayhead, (const char*)"memory of memory operations not supported yet");            dg_pusherror(pBHarrayhead, dg_compilebitopname);            break;    }}const char* dg_forthbtcommaname = "BT,";void dg_forthbtcomma (Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtcommaname);        return;    }    dg_compilebitop (        pBHarrayhead,        &firsttarget,  // top on stack        &secondtarget, // second on stack        0xA3,        4);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtcommaname);        return;    }}const char* dg_forthbtccommaname = "BTC,";void dg_forthbtccomma (    Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtccommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtccommaname);        return;    }    dg_compilebitop (        pBHarrayhead,        &firsttarget,  // top on stack        &secondtarget, // second on stack        0xBB,        7);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtccommaname);        return;    }}const char* dg_forthbtrcommaname = "BTR,";void dg_forthbtrcomma (    Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtrcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtrcommaname);        return;    }    dg_compilebitop (        pBHarrayhead,        &firsttarget,  // top on stack        &secondtarget, // second on stack        0xB3,        6);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtrcommaname);        return;    }}const char* dg_forthbtscommaname = "BTS,";void dg_forthbtscomma (    Bufferhandle* pBHarrayhead){    dg_Sibformatter firsttarget;    dg_Sibformatter secondtarget;        dg_initSibformatter(&firsttarget);    dg_initSibformatter(&secondtarget);    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &firsttarget); // top on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtscommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &secondtarget); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtscommaname);        return;    }    dg_compilebitop (        pBHarrayhead,        &firsttarget,  // top on stack        &secondtarget, // second on stack        0xAB,        5);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbtscommaname);        return;    }}const char* dg_compiledshiftoprtomname = "dg_compiledshiftoprtomname";void dg_compiledshiftoprtom (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* pfirsttarget,  // mem operand    struct dg_Sibformatter* psecondtarget, // reg operand    UINT64 baseopcode){    UINT64 addresssize;    unsigned char mybuf[3];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        if (0 == pfirsttarget->size)    {        pfirsttarget->size = psecondtarget->size;    }        if (0 == psecondtarget->size)    {        psecondtarget->size = pfirsttarget->size;    }        if ( (0 == pfirsttarget->size) &&         (0 == psecondtarget->size) )    {        if (4 == addresssize)        {            // use default size dword            pfirsttarget->size = 4;            psecondtarget->size = 4;        }        else        {            pfirsttarget->size = 8;            psecondtarget->size = 8;        }                // I thinking this should be an error instead...        //dg_pusherror(pBHarrayhead, (const char*)"size for operation must be specified");        //dg_pusherror(pBHarrayhead, dg_compiletwotargetsname);        //return;    }        if (psecondtarget->size != pfirsttarget->size)    {        dg_pusherror(pBHarrayhead, (const char*)"Sizes of source and deastination targets must be the same.");        dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);        return;    }    // size must be 2 or 4...    if (psecondtarget->size < 2)    {        dg_pusherror(pBHarrayhead, (const char*)"Only 16bit and 32bit data sizes are supported.");        dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);        return;    }                if (2 == psecondtarget->size)    {        mybuf[0] = 0x66;                        dg_compilesegment (            pBHarrayhead,             (const char*)&mybuf,            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);            return;        }    }    else if ((psecondtarget->size != 4) && (psecondtarget->size) != 8)    {        dg_pusherror(pBHarrayhead, (const char*)"Unsupported data size. Only 16, 32, and 64 bits are supported.");        dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);        return;    }                pfirsttarget->targetreg = psecondtarget->basereg;        dg_formatpsf(        pBHarrayhead,        pfirsttarget);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);        return;    }        dg_compilerex (        pBHarrayhead,        pfirsttarget,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilebitopnofmname);        return;    }        mybuf[0] = 0x0f;    mybuf[1] = baseopcode;        dg_compilesegment (        pBHarrayhead,         (const char*)&mybuf,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);        return;    }        dg_compilepsf(        pBHarrayhead,        pfirsttarget);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compiledshiftoprtomname);        return;    }}const char* dg_compiledshiftopname = "dg_compiledshiftop";void dg_compiledshiftop (    Bufferhandle* pBHarrayhead,    struct dg_Sibformatter* pfirsttarget,  // top on stack    struct dg_Sibformatter* psecondtarget, // second on stack    UINT64 baseopcode){    UINT64 twotargettype;    UINT64 isreverse = FORTH_FALSE;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        twotargettype = dg_determine2targettype (        pBHarrayhead,        pfirsttarget,    // top on stack        psecondtarget);  // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compiledshiftopname);        return;    }        if ( (pfirsttarget->direction != 0) ||         (psecondtarget->direction != 0) )    {        isreverse = FORTH_TRUE;        pfirsttarget->direction = 1;        psecondtarget->direction = 1;    }        switch (twotargettype)    {        case dg_nton:                case dg_ntoa:        case dg_ntor:        case dg_ntom:                case dg_aton:        case dg_rton:        case dg_mton:                        dg_pusherror(pBHarrayhead, (const char*)"Immediate to/from anything operations not supported. Load immediate values into a register first.");            dg_pusherror(pBHarrayhead, dg_compiledshiftopname);                        break;                                        // second target is used as mempsf        case dg_atoa:        case dg_ator:        case dg_rtoa:        case dg_rtor:                    if (isreverse == FORTH_FALSE)            {                dg_compiledshiftoprtom (                    pBHarrayhead,                    pfirsttarget,  // mem operand                    psecondtarget, // reg operand                    baseopcode);            }            else            {                dg_compiledshiftoprtom (                    pBHarrayhead,                    psecondtarget,  // mem operand                    pfirsttarget, // reg operand                    baseopcode);            }                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_compiledshiftopname);                return;            }                        break;                        case dg_mtoa:        case dg_mtor:                    if (isreverse != FORTH_FALSE)            {                dg_compiledshiftoprtom (                    pBHarrayhead,                    psecondtarget, // reg operand                    pfirsttarget,  // mem operand                    baseopcode);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiledshiftopname);                    return;                }            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"Destination must be the memory operand.");                dg_pusherror(pBHarrayhead, dg_compiledshiftopname);                }                        break;                                case dg_atom:        case dg_rtom:                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"r to m\n");                        if (isreverse == FORTH_FALSE)            {                dg_compiledshiftoprtom (                    pBHarrayhead,                    pfirsttarget,  // mem operand                    psecondtarget, // reg operand                    baseopcode);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_compiledshiftopname);                    return;                }            }            else            {                dg_pusherror(pBHarrayhead, (const char*)"Destination must be the memory operand.");                dg_pusherror(pBHarrayhead, dg_compiledshiftopname);                }                        break;                case dg_mtom:            dg_pusherror(pBHarrayhead, (const char*)"Memory to memory operations not supported yet.");            dg_pusherror(pBHarrayhead, dg_compiledshiftopname);            break;    }}const char* dg_pullandcompiledshiftopname = "dg_pullandcompiledshiftop";void dg_pullandcompiledshiftop (    Bufferhandle* pBHarrayhead,    UINT64 immediatebaseopcode,    UINT64 clbaseopcode){    unsigned char c;        // cases CL, NN    //  all other cases are errors    UINT64 opcodetype;        dg_Sibformatter mymodesf;    dg_Sibformatter myfirstsf;    dg_Sibformatter mysecondsf;        dg_initSibformatter(&mymodesf);    dg_initSibformatter(&myfirstsf);    dg_initSibformatter(&mysecondsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }            dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mymodesf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);        return;    }        opcodetype = dg_getshiftopcodetype(&mymodesf);        if (opcodetype > 2)    {        dg_pusherror(pBHarrayhead, (const char*)"shift/rotate amount can only be a constant value or the CL register");        dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);        return;    }        if (opcodetype < 2)    {        dg_compiledshiftop (            pBHarrayhead,            &myfirstsf,  // top on stack            &mysecondsf, // second on stack            immediatebaseopcode);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);            return;        }                c = (unsigned char)(mymodesf.immediatevalue);                dg_compilesegment(            pBHarrayhead,            (const char*)&c,            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);            return;        }    }    else    {        dg_compiledshiftop (            pBHarrayhead,            &myfirstsf,  // top on stack            &mysecondsf, // second on stack            clbaseopcode);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_pullandcompiledshiftopname);            return;        }    }}const char* dg_forthshldcommaname = "SHLD,";void dg_forthshldcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompiledshiftop (        pBHarrayhead,        0xA4,        0xA5);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthshldcommaname);        return;    }}const char* dg_forthshrdcommaname = "SHRD,";void dg_forthshrdcomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pullandcompiledshiftop (        pBHarrayhead,        0xAC,        0xAD);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthshrdcommaname);        return;    }}const char* dg_forthimulacommaname = "IMULA,";void dg_forthimulacomma(Bufferhandle* pBHarrayhead){    struct Onetargetopcodestrings myopcodes;    dg_Sibformatter mytargetsf;        dg_initSibformatter(&mytargetsf);        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    //popcodes->n8.popcodestring[0] = 0;    myopcodes.n8.opcodestringlength = 0;    myopcodes.n8.opcodeextension = (UINT64)-1;        //popcodes->a8.popcodestring[0] = 0;    myopcodes.a8.opcodestringlength = 0;    myopcodes.a8.opcodeextension = (UINT64)-1;        //popcodes->r8.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.r8.opcodestringlength = 0;    myopcodes.r8.opcodeextension = (UINT64)-1;        myopcodes.m8.popcodestring[0] = (char)0xF6;    myopcodes.m8.opcodestringlength = 1;    myopcodes.m8.opcodeextension = 5;        //myopcodes.n32signextended.popcodestring[0] = 0;    myopcodes.n32signextended.opcodestringlength = 0;    myopcodes.n32signextended.opcodeextension = (UINT64)-1;        //popcodes->n32.popcodestring[0] = 0;    myopcodes.n32.opcodestringlength = 0;    myopcodes.n32.opcodeextension = (UINT64)-1;        //popcodes->a32.popcodestring = (unsigned char*)dg_badbufferid;    myopcodes.a32.opcodestringlength = 0;    myopcodes.a32.opcodeextension = (UINT64)-1;        //myopcodes.r32.popcodestring[0] = 0x40;    myopcodes.r32.opcodestringlength = 0;    myopcodes.r32.opcodeextension = (UINT64)-1;        myopcodes.m32.popcodestring[0] = (char)0xF7;    myopcodes.m32.opcodestringlength = 1;    myopcodes.m32.opcodeextension = 5;        myopcodes.m32fp.opcodestringlength = 0;        myopcodes.m64fp.opcodestringlength = 0;        myopcodes.m80fp.opcodestringlength = 0;        dg_pulloneaddressingmode(        pBHarrayhead,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulacommaname);        return;    }        dg_compileonetarget (        pBHarrayhead,        &myopcodes,        &mytargetsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulacommaname);        return;    }}const char* dg_forthimulcommaname = "IMUL,";void dg_forthimulcomma (Bufferhandle* pBHarrayhead){    struct Twotargetopcodestrings myopcodes;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_fill2targetemptyoptbl(        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulcommaname);        return;    }        myopcodes.m32tor32.popcodestring[0] = (char)0x0F;    myopcodes.m32tor32.popcodestring[1] = (char)0xAF;    myopcodes.m32tor32.opcodestringlength = 2;    myopcodes.m32tor32.opcodeextension = (UINT64)-1;        dg_pullandcompiletwotargets (        pBHarrayhead,        &myopcodes);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulcommaname);        return;    }}const char* dg_forthimulncommaname = "IMULN,";void dg_forthimulncomma (Bufferhandle* pBHarrayhead){        dg_Sibformatter myimmediatesf;    dg_Sibformatter myfirstsf;    dg_Sibformatter mysecondsf;        dg_initSibformatter(&myimmediatesf);    dg_initSibformatter(&myfirstsf);    dg_initSibformatter(&mysecondsf);        struct Twotargetopcodestrings myopcodes;        UINT64 baseopcode;    UINT64 fSignExtended = FORTH_FALSE;    UINT64 datasize;    const char* pError;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }            dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &myimmediatesf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }        if (myimmediatesf.memmode != dg_memmodeimmediate)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }        if ( (myimmediatesf.immediatesize < 2) &&         ((INT64)myimmediatesf.immediatevalue >= -0x80) &&         ((INT64)myimmediatesf.immediatevalue < 0x80 ) )    {        baseopcode = 0x6B;        fSignExtended = FORTH_TRUE;    }    else    {        baseopcode = 0x69;    }        dg_fill2targetemptyoptbl(        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }        myopcodes.m32tor32.popcodestring[0] = (char)(baseopcode & 0xff);    myopcodes.m32tor32.opcodestringlength = 1;    myopcodes.m32tor32.opcodeextension = (UINT64)-1;        dg_compiletwotargets (        pBHarrayhead,        &myopcodes,        &myfirstsf, // top on stack        &mysecondsf); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }        if (fSignExtended != FORTH_FALSE)    {        myimmediatesf.size = 1;    }        if ( (myimmediatesf.immediatesize < 2) &&         ((INT64)myimmediatesf.immediatevalue >= -0x80) &&         ((INT64)myimmediatesf.immediatevalue < 0x80 ) )    {        myimmediatesf.size = 1;    }    else    {        myimmediatesf.size = myfirstsf.size; // should be either 2 or 4                // in 64 bit address mode, you can get 8 but immediate values are limited to 4        if (myimmediatesf.size > 4)        {            myimmediatesf.size = 4;                        pError = dg_checkifvaluefits(                myimmediatesf.size,   //                8,   // sign extended to this size                myimmediatesf.immediatevalue);                if (pError != dg_success)            {                // dg_printzerostring(pBHarrayhead, (unsigned char*)"used value size = ");                // dg_writestdoutuint64tohex(pBHarrayhead, pregpsf->size);                // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                dg_pusherror(pBHarrayhead, pError);                dg_pusherror(pBHarrayhead, dg_checkifvaluefitsname);                dg_pusherror(pBHarrayhead, dg_forthimulncommaname);                return;            }        }    }        // assuming little endian... which it should always be on x86    dg_compilesegment(        pBHarrayhead,        (const char*)&(myimmediatesf.immediatevalue),        myimmediatesf.size);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthimulncommaname);        return;    }}// SSE3 I think...const char* dg_forthmovbecommaname = "MOVBE,";void dg_forthmovbecomma (Bufferhandle* pBHarrayhead){    dg_Sibformatter myfirstsf;    dg_Sibformatter mysecondsf;        dg_initSibformatter(&myfirstsf);    dg_initSibformatter(&mysecondsf);        struct Twotargetopcodestrings myopcodes;        UINT64 baseopcode;    UINT64 fSignExtended = FORTH_FALSE;    UINT64 datasize;    const char* pError;    UINT64 twotargettype;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }            dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);        return;    }        dg_fill2targetemptyoptbl(        pBHarrayhead,        &myopcodes);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);        return;    }        myopcodes.m32tor32.popcodestring[0] = 0x0F;    myopcodes.m32tor32.popcodestring[1] = 0x38;    myopcodes.m32tor32.popcodestring[2] = 0xF0;    myopcodes.m32tor32.opcodestringlength = 3;    myopcodes.m32tor32.opcodeextension = (UINT64)-1;        myopcodes.r32tom32.popcodestring[0] = 0x0F;    myopcodes.r32tom32.popcodestring[1] = 0x38;    myopcodes.r32tom32.popcodestring[2] = 0xF1;    myopcodes.r32tom32.opcodestringlength = 3;    myopcodes.r32tom32.opcodeextension = (UINT64)-1;        twotargettype = dg_determine2targettype (        pBHarrayhead,        &myfirstsf,        &mysecondsf);        switch (twotargettype)    {        case dg_nton:                case dg_ntoa:        case dg_ntor:        case dg_ntom:                case dg_aton:        case dg_rton:        case dg_mton:                        dg_pusherror(pBHarrayhead, (const char*)"Immediate to/from anything operations not supported.");            dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);            return;            break;                                        // second target is used as mempsf        case dg_atoa:        case dg_ator:        case dg_rtoa:        case dg_rtor:                                dg_pusherror(pBHarrayhead, (const char*)"Register to register operations not supported, one target must be memory.");            dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);            return;            break;                        case dg_mtoa:        case dg_mtor:                case dg_atom:        case dg_rtom:                        break;                case dg_mtom:            dg_pusherror(pBHarrayhead, (const char*)"Memory to memory operations not supported yet.");            dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);            return;            break;    }            dg_compiletwotargets (        pBHarrayhead,        &myopcodes,        &myfirstsf, // top on stack        &mysecondsf); // second on stack            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovbecommaname);        return;    }}const char* dg_forthmovzxcommaname = "MOVZX,";void dg_forthmovzxcomma (Bufferhandle* pBHarrayhead){        struct dg_Sibformatter myfirstsf;    struct dg_Sibformatter mysecondsf;        dg_initSibformatter(&myfirstsf);    dg_initSibformatter(&mysecondsf);        struct dg_Sibformatter* pregsf = &myfirstsf;    struct dg_Sibformatter* pmemsf = &mysecondsf;        unsigned char mybuf[2];    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        if ( (myfirstsf.direction != 0) ||         (mysecondsf.direction != 0) )     {        pregsf = &mysecondsf;        pmemsf = &myfirstsf;    }        if ( (pregsf->memmode != dg_memmodereg) &&         (pregsf->memmode != dg_memmodedefaultreg) )    {        dg_pusherror(pBHarrayhead, (const char*)"Destination must be a register.");        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        if ( (pregsf->size != 2) &&         (pregsf->size != 4) &&         (pregsf->size != 8) )    {        dg_pusherror(pBHarrayhead, (const char*)"Destination size must be either 16, 32, or 64 bits.");        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        if ( (pregsf->memmode == dg_memmodeunknown) ||         (pregsf->memmode > dg_memmodesib) )    {        dg_pusherror(pBHarrayhead, (const char*)"Source must be a register or memory.");        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        if ( (pmemsf->size != 1) &&         (pmemsf->size != 2) )    {        dg_pusherror(pBHarrayhead, (const char*)"Source size must be either 8 or 16 bits.");        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        if (pregsf->size == pmemsf->size)    {        dg_pusherror(pBHarrayhead, (const char*)"Source size and destination size must be different.");        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        pmemsf->targetreg = pregsf->basereg;        // doing prefix for non default register size    if ( ((8 == addresssize) && (2 == pregsf->size )) ||   // in 64 bit mode, 16 is the non default size         ((4 == addresssize) && (4 == pregsf->size )) )    // in 32 bit mode, 32 is the non default size    {        mybuf[0] = 0x66;                dg_compilesegment(            pBHarrayhead,            (const char*)&mybuf,            1);    }        mybuf[0] = 0x0F;        if (pmemsf->size == 1)    {        mybuf[1] = 0xB6;    }    else    {        mybuf[1] = 0xB7;    }        pmemsf->size = pregsf->size; // for determining rex size        dg_formatpsf(        pBHarrayhead,        pmemsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        dg_compilerex (        pBHarrayhead,        pmemsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&mybuf,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }            dg_compilepsf(        pBHarrayhead,        pmemsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovzxcommaname);        return;    }}const char* dg_forthmovsxcommaname = "MOVSX,";void dg_forthmovsxcomma (Bufferhandle* pBHarrayhead){        struct dg_Sibformatter myfirstsf;    struct dg_Sibformatter mysecondsf;        dg_initSibformatter(&myfirstsf);    dg_initSibformatter(&mysecondsf);        struct dg_Sibformatter* pregsf = &myfirstsf;    struct dg_Sibformatter* pmemsf = &mysecondsf;        unsigned char mybuf[2];    UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        if ( (myfirstsf.direction != 0) ||         (mysecondsf.direction != 0) )    {        pregsf = &mysecondsf;        pmemsf = &myfirstsf;    }        if ( (pregsf->memmode != dg_memmodereg) &&         (pregsf->memmode != dg_memmodedefaultreg) )    {        dg_pusherror(pBHarrayhead, (const char*)"Destination must be a register.");        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        if ( (pregsf->size != 2) &&         (pregsf->size != 4) &&         (pregsf->size != 8) )    {        dg_pusherror(pBHarrayhead, (const char*)"Destination size must be either 16, 32 or 64 bits.");        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        if ( (pregsf->memmode == dg_memmodeunknown) ||         (pregsf->memmode > dg_memmodesib) )    {        dg_pusherror(pBHarrayhead, (const char*)"Source must be a register or memory.");        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        if ( (pmemsf->size != 1) &&         (pmemsf->size != 2) )    {        dg_pusherror(pBHarrayhead, (const char*)"Source size must be either 8 or 16 bits.");        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        if (pregsf->size == pmemsf->size)    {        dg_pusherror(pBHarrayhead, (const char*)"Source size and destination size must be different.");        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        pmemsf->targetreg = pregsf->basereg;        // doing prefix for non default register size    if ( ((8 == addresssize) && (2 == pregsf->size )) ||   // in 64 bit mode, 16 is the non default size         ((4 == addresssize) && (4 == pregsf->size )) )    // in 32 bit mode, 32 is the non default size    {        mybuf[0] = 0x66;                dg_compilesegment(            pBHarrayhead,            (const char*)&mybuf,            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);            return;        }    }        mybuf[0] = 0x0F;        if (pmemsf->size == 1)    {        mybuf[1] = 0xBE;    }    else    {        mybuf[1] = 0xBF;    }        pmemsf->size = pregsf->size; // for determining rex size         dg_formatpsf(        pBHarrayhead,        pmemsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        dg_compilerex (        pBHarrayhead,        pmemsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&mybuf,        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }            dg_compilepsf(        pBHarrayhead,        pmemsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxcommaname);        return;    }}const char* dg_forthmovsxdcommaname = "MOVSXD,";void dg_forthmovsxdcomma (Bufferhandle* pBHarrayhead){    struct dg_Sibformatter myfirstsf;    struct dg_Sibformatter mysecondsf;        dg_initSibformatter(&myfirstsf);    dg_initSibformatter(&mysecondsf);        struct dg_Sibformatter* pregsf = &myfirstsf;    struct dg_Sibformatter* pmemsf = &mysecondsf;        UINT64 addresssize;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        if (addresssize != 8)    {        dg_pusherror(pBHarrayhead, (const char*)" 64 bit address mode only instruction");        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &mysecondsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        if ( (myfirstsf.direction != 0) ||         (mysecondsf.direction != 0) )    {        pregsf = &mysecondsf;        pmemsf = &myfirstsf;    }        if ( (pregsf->memmode != dg_memmodereg) &&         (pregsf->memmode != dg_memmodedefaultreg) )    {        dg_pusherror(pBHarrayhead, (const char*)"Destination must be a register.");        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        if (pregsf->size != 8)    {        dg_pusherror(pBHarrayhead, (const char*)"Destination size must be 64 bits.");        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        if ( (pregsf->memmode == dg_memmodeunknown) ||         (pregsf->memmode > dg_memmodesib) )    {        dg_pusherror(pBHarrayhead, (const char*)"Source must be a register or memory.");        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        if ( (pmemsf->size != 0) &&         (pmemsf->size != 4) )    {        dg_pusherror(pBHarrayhead, (const char*)"Source size must be 32 bits.");        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }            pmemsf->targetreg = pregsf->basereg;    pmemsf->size = 8;  // not really needed since I put rex in the opcode string...        dg_formatpsf(        pBHarrayhead,        pmemsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }        /*    dg_compilerex (        pBHarrayhead,        pmemsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }    */        // since this instruction always gets rex... putting it in the opcode string    dg_compilesegment(        pBHarrayhead,        (const char*)"\x48\x63",        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }            dg_compilepsf(        pBHarrayhead,        pmemsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthmovsxdcommaname);        return;    }}const char* dg_forthxabortcommaname = "XABORT,";void dg_forthxabortcomma (Bufferhandle* pBHarrayhead){    struct dg_Sibformatter myfirstsf;        dg_initSibformatter(&myfirstsf);    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxabortcommaname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)"\xC6\xF8",        2);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxabortcommaname);        return;    }        if (myfirstsf.memmode != dg_memmodeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"Target for this instruction must be immediate.");        dg_pusherror(pBHarrayhead, dg_forthxabortcommaname);        return;    }        // for the n8mtoxmmr instructions    if (myfirstsf.immediatesize == 0)    {        myfirstsf.immediatesize = 1;    }            if (myfirstsf.immediatesize != 1)    {        dg_pusherror(pBHarrayhead, (const char*)"only immediate size 1 is supported.");        dg_pusherror(pBHarrayhead, dg_forthxabortcommaname);        return;    }                dg_compilesegment(        pBHarrayhead,        (const char*)&(myfirstsf.immediatevalue), // assumes little endian        1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthxabortcommaname);        return;    }}const char* dg_forthcallcommaname = "CALL,";void dg_forthcallcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        dg_initSibformatter(&myfirstsf);            UINT64 mycurrentcompilebufferid;            unsigned char mybuf[3];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }        mycurrentcompilebufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }    if ( (myfirstsf.memmode == dg_memmodeimmediate) ||         (mycurrentcompilebufferid == DG_CORE_BUFFERID) )    {        dg_pusherror(pBHarrayhead, (const char*)"Calls to absolute addresses not supported on x86. Need to move address to a register or memory first.");        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {           if (mycurrentcompilebufferid != myfirstsf.bufferid)        {            dg_pusherror(pBHarrayhead, (const char*)"Only calls to same buffer are supported because buffers can move.");            dg_pusherror(pBHarrayhead, dg_forthcallcommaname);            return;        }                dg_compilecalloffsetinsamebuffer(            pBHarrayhead,            myfirstsf.offset);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallcommaname);            return;        }                return;    }        // does not check to make sure displacement is in current buffer    if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_compilecalloffset(pBHarrayhead, myfirstsf.displacement);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallcommaname);            return;        }                return;    }        // promote size if default (for immediate and memory operands)    if (0 == myfirstsf.size)    {        myfirstsf.size = addresssize;    }        if (addresssize != myfirstsf.size)    {        dg_pusherror(pBHarrayhead, (const char*)"register and memory targets must be same as address size for POP, (so 32 bits in 32 bit mode or 64 bits in 64 bit mode)");        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }        dg_formatpsf(        pBHarrayhead,        &myfirstsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }        // doing rex for mem but not size    //  size is automatically 64 bits in 64 bit mode    dg_compilerexnosizetargetreg (        pBHarrayhead,        &myfirstsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }        // compile call to register or memory    myfirstsf.targetreg = 2;    mybuf[0] = 0xff;        dg_compilesegment(        pBHarrayhead,        (const char*)&mybuf,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }            dg_compilepsf(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallcommaname);        return;    }}// callfar, CALL[SS]+16//  32 bit mode with 16 bit prefix  4 bit immediate value//                code segment selector is high 16 bits//                address is low 16 bits zero extended to 32 bits//// callfar, CALL[SS]+16//  32 bit mode with r/m with 16 bit prefix - no r//                data size is 32 bits... (16:16)//const char* dg_forthcallbracketssplusn16commaname = "CALL[SS]+N16,";void dg_forthcallbracketssplusn16comma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        UINT64 offset;        UINT64 targettype;        dg_initSibformatter(&myfirstsf);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);        return;    }        offset = dg_popdatastack(pBHarrayhead);    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);  // segment selector            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        dg_pusherror(pBHarrayhead, (const char*)"O not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);        return;    }        if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_pusherror(pBHarrayhead, (const char*)"EIP+N not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);        return;                return;    }        if ((myfirstsf.memmode == dg_memmodereg) ||        (myfirstsf.memmode == dg_memmodedefaultreg))    {        dg_pusherror(pBHarrayhead, (const char*)"register targets not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);        return;    }    if (myfirstsf.memmode == dg_memmodeimmediate)    {        if (addresssize != 4)        {            dg_pusherror(pBHarrayhead, (const char*)"immediate segment selectors are only supported in 32 bit address mode");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                dg_compilesegment (            pBHarrayhead,            (const char*)"\x66\x9A",            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                if (offset >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                if (myfirstsf.immediatevalue >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"segment selector does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(myfirstsf.immediatevalue),            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                return;    }    else    {        targettype = dg_gettargettype (            pBHarrayhead,            &myfirstsf);                    if (targettype != dg_targettypemem)        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate and memory targets are supported.");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                // ignoring size        myfirstsf.size = 4; // probably not needed... but just in case...                dg_formatpsf(            pBHarrayhead,            &myfirstsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                // 16 bit opcode prefix        dg_compilesegment (            pBHarrayhead,            (const char*)"\x66",            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                // doing rex for mem but not size        dg_compilerexnosizetargetreg (            pBHarrayhead,            &myfirstsf,            addresssize);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                // compile call to an offset in a code segment        //  using a segment selector and offset target in memory        myfirstsf.targetreg = 3;                dg_compilesegment(            pBHarrayhead,            (const char*)"\xff",            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                    dg_compilepsf(            pBHarrayhead,            &myfirstsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                if (offset >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn16commaname);            return;        }    }}// callfar, CALL[SS]+32//  32 bit mode  6 bit immediate value//                code segment selector is high 16 bits//                address is low 32 bits//// callfar, CALL[SS]+32//  32 bit mode with r/m  - no r//                data size is 48 bits... (16:32)////// callfar, CALL[SS]+32//  64 bit mode with r/m  - no r//                data size is 48 bits... (16:32)//const char* dg_forthcallbracketssplusn32commaname = "CALL[SS]+N32,";void dg_forthcallbracketssplusn32comma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        UINT64 offset;        UINT64 targettype;        dg_initSibformatter(&myfirstsf);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);        return;    }        offset = dg_popdatastack(pBHarrayhead);    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);  // segment selector            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        dg_pusherror(pBHarrayhead, (const char*)"O not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);        return;    }        if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_pusherror(pBHarrayhead, (const char*)"EIP+N not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);        return;                return;    }        if ((myfirstsf.memmode == dg_memmodereg) ||        (myfirstsf.memmode == dg_memmodedefaultreg))    {        dg_pusherror(pBHarrayhead, (const char*)"register targets not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);        return;    }    if (myfirstsf.memmode == dg_memmodeimmediate)    {        if (addresssize != 4)        {            dg_pusherror(pBHarrayhead, (const char*)"immediate segment selectors are only supported in 32 bit address mode");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                dg_compilesegment (            pBHarrayhead,            (const char*)"\x9A",            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                if (offset >= 0x100000000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 32 bit value");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            4);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                if (myfirstsf.immediatevalue >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"segment selector does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(myfirstsf.immediatevalue),            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                return;    }    else    {        targettype = dg_gettargettype (            pBHarrayhead,            &myfirstsf);                    if (targettype != dg_targettypemem)        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate and memory targets are supported.");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                // ignoring size        myfirstsf.size = 4; // probably not needed... but just in case...                dg_formatpsf(            pBHarrayhead,            &myfirstsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                // doing rex for mem but not size        dg_compilerexnosizetargetreg (            pBHarrayhead,            &myfirstsf,            addresssize);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                // compile call to an offset in a code segment        //  using a segment selector and offset target in memory        myfirstsf.targetreg = 3;                dg_compilesegment(            pBHarrayhead,            (const char*)"\xff",            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                    dg_compilepsf(            pBHarrayhead,            &myfirstsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                if (offset >= 0x100000000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 32 bit value");            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            4);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn32commaname);            return;        }    }}// callfar, CALL[SS]+64//  64 bit mode with r/m  - no r//                data size is 80 bits... (16:64)//const char* dg_forthcallbracketssplusn64commaname = "CALL[SS]+N64,";void dg_forthcallbracketssplusn64comma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        UINT64 offset;        UINT64 targettype;        dg_initSibformatter(&myfirstsf);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        offset = dg_popdatastack(pBHarrayhead);    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);  // segment selector            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        if (addresssize != 8)    {        dg_pusherror(pBHarrayhead, (const char*)"64 bit offsets are only supported in 64 bit address mode.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        dg_pusherror(pBHarrayhead, (const char*)"O not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_pusherror(pBHarrayhead, (const char*)"EIP+N not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;                return;    }        if ((myfirstsf.memmode == dg_memmodereg) ||        (myfirstsf.memmode == dg_memmodedefaultreg))    {        dg_pusherror(pBHarrayhead, (const char*)"register targets not supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }    if (myfirstsf.memmode == dg_memmodeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"immediate segment selectors are not supported with 64 bit offsets");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &myfirstsf);            if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported.");        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        // ignoring size    myfirstsf.size = 8; // probably not needed... but just in case...        dg_formatpsf(        pBHarrayhead,        &myfirstsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        // doing rex    dg_compilerexnotargetreg (        pBHarrayhead,        &myfirstsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        // compile call to an offset in a code segment    //  using a segment selector and offset target in memory    myfirstsf.targetreg = 3;        dg_compilesegment(        pBHarrayhead,        (const char*)"\xff",        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }            dg_compilepsf(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&offset,        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallbracketssplusn64commaname);        return;    }}const char* dg_forthjmpcommaname = "JMP,";void dg_forthjmpcomma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        dg_initSibformatter(&myfirstsf);            UINT64 mycurrentcompilebufferid;            unsigned char mybuf[3];        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }        mycurrentcompilebufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }    if ( (myfirstsf.memmode == dg_memmodeimmediate) ||         (mycurrentcompilebufferid == DG_CORE_BUFFERID) )    {        dg_pusherror(pBHarrayhead, (const char*)"Jumps to absolute addresses not supported on x86. Need to move address to a register or memory first.");        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        if (mycurrentcompilebufferid != myfirstsf.bufferid)        {            dg_pusherror(pBHarrayhead, (const char*)"Only jumps to same buffer are supported because buffers can move.");            dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);            return;        }                dg_compilejmpoffsetinsamebuffer(            pBHarrayhead,            myfirstsf.offset);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);            return;        }                return;    }        // does not check to make sure displacement is in current buffer    if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_compilejmpoffset(pBHarrayhead, myfirstsf.displacement);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);            return;        }                return;    }        // promote size if default (for immediate and memory operands)    if (0 == myfirstsf.size)    {        myfirstsf.size = addresssize;    }        if (addresssize != myfirstsf.size)    {        dg_pusherror(pBHarrayhead, (const char*)"register and memory targets must be same as address size for POP, (so 32 bits in 32 bit mode or 64 bits in 64 bit mode)");        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }        dg_formatpsf(        pBHarrayhead,        &myfirstsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }        // doing rex for mem but not size    //  size is automatically 64 bits in 64 bit mode    dg_compilerexnosizetargetreg (        pBHarrayhead,        &myfirstsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }        // compile call to register or memory    myfirstsf.targetreg = 4;    mybuf[0] = 0xff;        dg_compilesegment(        pBHarrayhead,        (const char*)&mybuf,        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }            dg_compilepsf(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpcommaname);        return;    }}// callfar, CALL[SS]+16//  32 bit mode with 16 bit prefix  4 bit immediate value//                code segment selector is high 16 bits//                address is low 16 bits zero extended to 32 bits//// callfar, CALL[SS]+16//  32 bit mode with r/m with 16 bit prefix - no r//                data size is 32 bits... (16:16)//const char* dg_forthjmpbracketssplusn16commaname = "JMP[SS]+N16,";void dg_forthjmpbracketssplusn16comma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        UINT64 offset;        UINT64 targettype;        dg_initSibformatter(&myfirstsf);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);        return;    }        offset = dg_popdatastack(pBHarrayhead);    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);  // segment selector            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        dg_pusherror(pBHarrayhead, (const char*)"O not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);        return;    }        if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_pusherror(pBHarrayhead, (const char*)"EIP+N not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);        return;                return;    }        if ((myfirstsf.memmode == dg_memmodereg) ||        (myfirstsf.memmode == dg_memmodedefaultreg))    {        dg_pusherror(pBHarrayhead, (const char*)"register targets not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);        return;    }    if (myfirstsf.memmode == dg_memmodeimmediate)    {        if (addresssize != 4)        {            dg_pusherror(pBHarrayhead, (const char*)"immediate segment selectors are only supported in 32 bit address mode");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                dg_compilesegment (            pBHarrayhead,            (const char*)"\x66\xEA",            2);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                if (offset >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                if (myfirstsf.immediatevalue >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"segment selector does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(myfirstsf.immediatevalue),            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                return;    }    else    {        targettype = dg_gettargettype (            pBHarrayhead,            &myfirstsf);                    if (targettype != dg_targettypemem)        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate and memory targets are supported.");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                // ignoring size        myfirstsf.size = 4; // probably not needed... but just in case...                dg_formatpsf(            pBHarrayhead,            &myfirstsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                // 16 bit opcode prefix        dg_compilesegment (            pBHarrayhead,            (const char*)"\x66",            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                // doing rex for mem but not size        dg_compilerexnosizetargetreg (            pBHarrayhead,            &myfirstsf,            addresssize);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                // compile call to an offset in a code segment        //  using a segment selector and offset target in memory        myfirstsf.targetreg = 5;                dg_compilesegment(            pBHarrayhead,            (const char*)"\xff",            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                    dg_compilepsf(            pBHarrayhead,            &myfirstsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                if (offset >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn16commaname);            return;        }    }}// callfar, CALL[SS]+32//  32 bit mode  6 bit immediate value//                code segment selector is high 16 bits//                address is low 32 bits//// callfar, CALL[SS]+32//  32 bit mode with r/m  - no r//                data size is 48 bits... (16:32)////// callfar, CALL[SS]+32//  64 bit mode with r/m  - no r//                data size is 48 bits... (16:32)//const char* dg_forthjmpbracketssplusn32commaname = "JMP[SS]+N32,";void dg_forthjmpbracketssplusn32comma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        UINT64 offset;        UINT64 targettype;        dg_initSibformatter(&myfirstsf);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);        return;    }        offset = dg_popdatastack(pBHarrayhead);    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);  // segment selector            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        dg_pusherror(pBHarrayhead, (const char*)"O not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);        return;    }        if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_pusherror(pBHarrayhead, (const char*)"EIP+N not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);        return;                return;    }        if ((myfirstsf.memmode == dg_memmodereg) ||        (myfirstsf.memmode == dg_memmodedefaultreg))    {        dg_pusherror(pBHarrayhead, (const char*)"register targets not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);        return;    }    if (myfirstsf.memmode == dg_memmodeimmediate)    {        if (addresssize != 4)        {            dg_pusherror(pBHarrayhead, (const char*)"immediate segment selectors are only supported in 32 bit address mode");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                dg_compilesegment (            pBHarrayhead,            (const char*)"\xEA",            1);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                if (offset >= 0x100000000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 32 bit value");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            4);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                if (myfirstsf.immediatevalue >= 0x10000)        {            dg_pusherror(pBHarrayhead, (const char*)"segment selector does not fit into a 16 bit value");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&(myfirstsf.immediatevalue),            2);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                return;    }    else    {        targettype = dg_gettargettype (            pBHarrayhead,            &myfirstsf);                    if (targettype != dg_targettypemem)        {            dg_pusherror(pBHarrayhead, (const char*)"only immediate and memory targets are supported.");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                // ignoring size        myfirstsf.size = 4; // probably not needed... but just in case...                dg_formatpsf(            pBHarrayhead,            &myfirstsf);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                // doing rex for mem but not size        dg_compilerexnosizetargetreg (            pBHarrayhead,            &myfirstsf,            addresssize);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                // compile call to an offset in a code segment        //  using a segment selector and offset target in memory        myfirstsf.targetreg = 5;                dg_compilesegment(            pBHarrayhead,            (const char*)"\xff",            1);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                    dg_compilepsf(            pBHarrayhead,            &myfirstsf);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                if (offset >= 0x100000000)        {            dg_pusherror(pBHarrayhead, (const char*)"offset does not fit into a 32 bit value");            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }                dg_compilesegment(            pBHarrayhead,            (const char*)&offset,            4);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn32commaname);            return;        }    }}// callfar, CALL[SS]+64//  64 bit mode with r/m  - no r//                data size is 80 bits... (16:64)//const char* dg_forthjmpbracketssplusn64commaname = "JMP[SS]+N64,";void dg_forthjmpbracketssplusn64comma (Bufferhandle* pBHarrayhead){    UINT64 addresssize;        struct dg_Sibformatter myfirstsf;        UINT64 offset;        UINT64 targettype;        dg_initSibformatter(&myfirstsf);            UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        addresssize = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_x86asmaddresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        offset = dg_popdatastack(pBHarrayhead);    dg_pulloneaddressingmode(        pBHarrayhead,        &myfirstsf);  // segment selector            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        if (addresssize != 8)    {        dg_pusherror(pBHarrayhead, (const char*)"64 bit offsets are only supported in 64 bit address mode.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        if (myfirstsf.memmode == dg_memmodebufferoffsetnobracket)    {        dg_pusherror(pBHarrayhead, (const char*)"O not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        if (myfirstsf.memmode == dg_memmodeeipplusn)    {        dg_pusherror(pBHarrayhead, (const char*)"EIP+N not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;                return;    }        if ((myfirstsf.memmode == dg_memmodereg) ||        (myfirstsf.memmode == dg_memmodedefaultreg))    {        dg_pusherror(pBHarrayhead, (const char*)"register targets not supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }    if (myfirstsf.memmode == dg_memmodeimmediate)    {        dg_pusherror(pBHarrayhead, (const char*)"immediate segment selectors are not supported with 64 bit offsets");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        targettype = dg_gettargettype (        pBHarrayhead,        &myfirstsf);            if (targettype != dg_targettypemem)    {        dg_pusherror(pBHarrayhead, (const char*)"only memory targets are supported.");        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        // ignoring size    myfirstsf.size = 8; // probably not needed... but just in case...        dg_formatpsf(        pBHarrayhead,        &myfirstsf);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        // doing rex    dg_compilerexnotargetreg (        pBHarrayhead,        &myfirstsf,        addresssize);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        // compile call to an offset in a code segment    //  using a segment selector and offset target in memory    myfirstsf.targetreg = 5;        dg_compilesegment(        pBHarrayhead,        (const char*)"\xff",        1);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }            dg_compilepsf(        pBHarrayhead,        &myfirstsf);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }        dg_compilesegment(        pBHarrayhead,        (const char*)&offset,        8);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthjmpbracketssplusn64commaname);        return;    }}const char dg_ntoeaxcommaname[] = "N->EAX,";void dg_ntoeaxcomma(    Bufferhandle* pBHarrayhead){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        n = dg_popbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_ntoeaxcommaname);        return;    }        dg_compilemovntoeax(        pBHarrayhead,        n);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_ntoeaxcommaname);        return;    }}const char dg_forthotormovcommaname[] = "O->RMOV,";void dg_forthotormovcomma(Bufferhandle* pBHarrayhead){    UINT64 o, reg;    UINT64 sourceoffset;    UINT64 instructionoffset;    UINT64 ccbufferid;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        ccbufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        reg = dg_popbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        o = dg_popbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        dg_compilecalloffset(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        sourceoffset = dg_getbufferlength(pBHarrayhead, ccbufferid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        // could check 0 < o < sourceoffset...    //  or could assume the programmer knows what they are doing    instructionoffset = o - sourceoffset;        // if value for reg is bad it gets converted to 32bit base reg    dg_compilepopregfromret(pBHarrayhead, reg);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        // do offsettotarget N reg ADD,    dg_pushbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID, instructionoffset);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        dg_forthzeroimmediate(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        dg_pushbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID, reg);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }        // dg_pushbufferuint64(pBHarrayhead, dg_isreg); // not necessary        dg_forthaddcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthotormovcommaname);        return;    }}const char dg_forthbracketotormovcommaname[] = "[O]->RMOV,";void dg_forthbracketotormovcomma(Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        UINT64 o, reg;    UINT64 sourceoffset;    UINT64 instructionoffset;    UINT64 ccbufferid;        ccbufferid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        reg = dg_popbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        o = dg_popbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        dg_compilecalloffset(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        sourceoffset = dg_getbufferlength(pBHarrayhead, ccbufferid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        // could check 0 < o < sourceoffset...    //  or could assume the programmer knows what they are doing    instructionoffset = o - sourceoffset;        // if value for reg is bad it gets converted to 32bit base reg    dg_compilepopregfromret(pBHarrayhead, reg);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        // do reg offsettotarget [R+N] reg -> MOV,    dg_pushbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID, reg);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        dg_pushbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID, instructionoffset);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        dg_forthbracketrplusd(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        dg_pushbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID, reg);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }    dg_pushbufferuint64(pBHarrayhead, DG_DATASTACK_BUFFERID, dg_isforward);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }        dg_forthmovcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketotormovcommaname);        return;    }}const char dg_forthopushcommaname[] = "OPUSH,";void dg_forthopushcomma (Bufferhandle* pBHarrayhead)// (  destoffset -- ){    UINT64 destoffset;    UINT64 srcoffset;    UINT64 ccbufid;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        destoffset = dg_popbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        dg_compilecalloffset(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        srcoffset = dg_getbufferlength(        pBHarrayhead,        ccbufid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        UINT64(destoffset - srcoffset));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        // N    dg_forthzeroimmediate(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        // push ESP    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_esp);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        // push [R]    dg_forthbracketr(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        // 32BIT    dg_forthdatasizedword(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }        // ADD,    dg_forthaddcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthopushcommaname);        return;    }}const char dg_forthbracketopushcommaname[] = "[O]PUSH,";void dg_forthbracketopushcomma (Bufferhandle* pBHarrayhead)// (  destoffset -- ){    UINT64 destoffset;    UINT64 srcoffset;    UINT64 ccbufid;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        destoffset = dg_popbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // 0 EIP+N CALL,    dg_compilecalloffset(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        srcoffset = dg_getbufferlength(        pBHarrayhead,        ccbufid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // EAX    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_eax);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // POP,    dg_forthpopcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // EAX    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_eax);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // offset    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        UINT64(destoffset - srcoffset));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // [R+N]    dg_forthbracketrplusd(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // 32BIT    dg_forthdatasizedword(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }        // PUSH,    dg_forthpushcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopushcommaname);        return;    }}const char dg_forthbracketopopcommaname[] = "[O]POP,";void dg_forthbracketopopcomma (Bufferhandle* pBHarrayhead)// (  destoffset -- ){    UINT64 destoffset;    UINT64 srcoffset;    UINT64 ccbufid;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        destoffset = dg_popbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // 0 EIP+N CALL,    dg_compilecalloffset(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        srcoffset = dg_getbufferlength(        pBHarrayhead,        ccbufid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // EAX    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_eax);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // POP,    dg_forthpopcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // EAX    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        dg_eax);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // offset    dg_pushbufferuint64(        pBHarrayhead,        DG_DATASTACK_BUFFERID,        UINT64(destoffset - srcoffset));        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // [R+N]    dg_forthbracketrplusd(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // 32BIT    dg_forthdatasizedword(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }        // POP,    dg_forthpopcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbracketopopcommaname);        return;    }}const char dg_forthstrtopstrpushcommaname[] = "$>P$PUSH,";void dg_forthstrtopstrpushcomma (Bufferhandle* pBHarrayhead)// (  $ -$- ){    UINT64 stringstackdepth, stringlength;    unsigned char* pstring;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        stringstackdepth = dg_getnumberoflstringsonstack(        pBHarrayhead,         DG_STRINGOFFSETSTACK_BUFFERID);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthstrtopstrpushcommaname);        return;    }    pstring = (unsigned char*)dg_getplstring(        pBHarrayhead,         DG_STRINGOFFSETSTACK_BUFFERID,         DG_STRINGSTRINGSTACK_BUFFERID,        stringstackdepth - 1,        &stringlength);        dg_compilecalloffset(pBHarrayhead, stringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthstrtopstrpushcommaname);        return;    }        dg_compilesegment(pBHarrayhead, (const char*)pstring, stringlength);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthstrtopstrpushcommaname);        return;    }        dg_forthdropstring(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthstrtopstrpushcommaname);        return;    }}// const char dg_forthparencurlyname[] = "(<";const char dg_forthframeparamscurlyname[] = "FRAME-PARAMS<";void dg_forthframeparamscurly (Bufferhandle* pBHarrayhead){    UINT64 localwordid;    UINT64 localswordlistid;        UINT64 numberofintparameters = 0;    UINT64 numberoffloatparameters = 0;        UINT64 foundendflag = FORTH_FALSE;    unsigned char* pname;    UINT64 namelength = 0;        INT64 compareflag;    UINT64 parsingfloatsflag = FORTH_FALSE; // start out parsing ints        UINT64 i;    UINT64 stringstackdepth;        const char* pError;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }            localswordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_localswordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);        return;    }        while(foundendflag == FORTH_FALSE)    {        pname = dg_parsewords(            pBHarrayhead,            &namelength,            (unsigned char)'>',            &foundendflag,            FORTH_FALSE);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);            return;        }                    if (namelength != 0)        {                        pError = dg_comparebytes (                pname,                 // pstring1,                 namelength,            // string1length,                (unsigned char*)"INT", //  pstring2,                3,                     // string2length,                &compareflag);         // pflag);                            if (pError != dg_success)            {                dg_pusherror(pBHarrayhead, pError);                dg_pusherror(pBHarrayhead, dg_comparebytesname);                dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                return;            }                        if (0 == compareflag)            {                parsingfloatsflag = FORTH_FALSE;            }            else            {                pError = dg_comparebytes (                    pname,                 // pstring1,                     namelength,            // string1length,                    (unsigned char*)"FLOAT", //  pstring2,                    5,                     // string2length,                    &compareflag);         // pflag);                                if (pError != dg_success)                {                    dg_pusherror(pBHarrayhead, pError);                    dg_pusherror(pBHarrayhead, dg_comparebytesname);                    dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                    return;                }                                if (0 == compareflag)                {                    parsingfloatsflag = FORTH_TRUE;                }                else                {                    // it's a parameter name                    //  if we are in float mode push this to the string stack for later                    //  because on Mac, floating point parameters come after int parameters                    //  on the stack, regardless of their position in the C prototype                    if (parsingfloatsflag != FORTH_FALSE)                    {                        // we are parsing float paramters                        dg_pushlstring (                            pBHarrayhead,                            DG_STRINGOFFSETSTACK_BUFFERID,                            DG_STRINGSTRINGSTACK_BUFFERID,                            namelength,                            pname);                                                    if (dg_geterrorcount(pBHarrayhead) != 0)                        {                            dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                            return;                        }                                                numberoffloatparameters++;                    }                    else                    {                        // it's an int parameter                        // add the symbol name - it's a constant                        localwordid = dg_createdconstantdef (                            pBHarrayhead,                            numberofintparameters, // databufoffset                            dg_isparamusingframe, // databufid,                            pname,                            namelength);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                        {                            dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                            return;                        }                                        dg_linkdefinition(                            pBHarrayhead,                            localswordlistid,                            localwordid);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                        {                            dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                            return;                        }                                                numberofintparameters++;                    }                }            }        }    }    // time to do the floating point parameters that are on the string stack        // for each parameter name on the string stack:    //  get a pointer to and length of the string staring with the deepest string    //  create a constant definition and link it into the locals wordlist    //    the parameter index is numberofintparameters plus which float this is    //  that's it    if (numberoffloatparameters != 0)    {        stringstackdepth = dg_getnumberoflstringsonstack(            pBHarrayhead,            DG_STRINGOFFSETSTACK_BUFFERID);              if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);            return;        }                for (i = 0; i < numberoffloatparameters; i++)        {            pname = dg_getplstring(                pBHarrayhead,                DG_STRINGOFFSETSTACK_BUFFERID,                DG_STRINGSTRINGSTACK_BUFFERID,                stringstackdepth - (numberoffloatparameters - i),  // stringid,                &namelength);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                return;            }                            // add the symbol name - it's a dconstant, paramindex dg_isparamusingframe            localwordid = dg_createdconstantdef (                pBHarrayhead,                numberofintparameters + i, // databufoffset                dg_isparamusingframe, // databufid,                pname,                namelength);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                return;            }                            dg_linkdefinition(                pBHarrayhead,                localswordlistid,                localwordid);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);                return;            }        }    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_extraparametersfloatsflag,        parsingfloatsflag);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcparameters,        numberofintparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcfparameters,        numberoffloatparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframeparamscurlyname);        return;    }}const char dg_forthnoframeparamscurlyname[] = "NO-FRAME-PARAMS<";void dg_forthnoframeparamscurly (Bufferhandle* pBHarrayhead){    UINT64 localwordid;    UINT64 localswordlistid;        UINT64 numberofintparameters = 0;    UINT64 numberoffloatparameters = 0;        UINT64 foundendflag = FORTH_FALSE;    unsigned char* pname;    UINT64 namelength = 0;        INT64 compareflag;    UINT64 parsingfloatsflag = FORTH_FALSE; // start out parsing ints        UINT64 i;    UINT64 stringstackdepth;        const char* pError;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // setting default return stack depth to 1 (the return address is on the stack)    //  this is used to calculate offset to parameters based on return stack pointer    dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_noframereturnstackdepth,        dg_defaultnoframerstackdepth);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);        return;    }                localswordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_localswordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);        return;    }        while(foundendflag == FORTH_FALSE)    {        pname = dg_parsewords(            pBHarrayhead,            &namelength,            (unsigned char)'>',            &foundendflag,            FORTH_FALSE);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);            return;        }                    if (namelength != 0)        {                        pError = dg_comparebytes (                pname,                 // pstring1,                 namelength,            // string1length,                (unsigned char*)"INT", //  pstring2,                3,                     // string2length,                &compareflag);         // pflag);                            if (pError != dg_success)            {                dg_pusherror(pBHarrayhead, pError);                dg_pusherror(pBHarrayhead, dg_comparebytesname);                dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                return;            }                        if (0 == compareflag)            {                parsingfloatsflag = FORTH_FALSE;            }            else            {                pError = dg_comparebytes (                    pname,                 // pstring1,                     namelength,            // string1length,                    (unsigned char*)"FLOAT", //  pstring2,                    5,                     // string2length,                    &compareflag);         // pflag);                                if (pError != dg_success)                {                    dg_pusherror(pBHarrayhead, pError);                    dg_pusherror(pBHarrayhead, dg_comparebytesname);                    dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                    return;                }                                if (0 == compareflag)                {                    parsingfloatsflag = FORTH_TRUE;                }                else                {                    // it's a parameter name                    //  if we are in float mode push this to the string stack for later                    //  because on Mac, floating point parameters come after int parameters                    //  on the stack, regardless of their position in the C prototype                    if (parsingfloatsflag != FORTH_FALSE)                    {                        // we are parsing float paramters                        dg_pushlstring (                            pBHarrayhead,                            DG_STRINGOFFSETSTACK_BUFFERID,                            DG_STRINGSTRINGSTACK_BUFFERID,                            namelength,                            pname);                                                    if (dg_geterrorcount(pBHarrayhead) != 0)                        {                            dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                            return;                        }                                                numberoffloatparameters++;                    }                    else                    {                        // it's an int parameter                        // add the symbol name - it's a constant                        localwordid = dg_createdconstantdef (                            pBHarrayhead,                            numberofintparameters, // databufoffset                            dg_isparamusingnoframe, // databufid,                            pname,                            namelength);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                        {                            dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                            return;                        }                                        dg_linkdefinition(                            pBHarrayhead,                            localswordlistid,                            localwordid);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                        {                            dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                            return;                        }                                                numberofintparameters++;                    }                }            }        }    }    // time to do the floating point parameters that are on the string stack        // for each parameter name on the string stack:    //  get a pointer to and length of the string staring with the deepest string    //  create a constant definition and link it into the locals wordlist    //    the parameter index is numberofintparameters plus which float this is    //  that's it    if (numberoffloatparameters != 0)    {        stringstackdepth = dg_getnumberoflstringsonstack(            pBHarrayhead,            DG_STRINGOFFSETSTACK_BUFFERID);              if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);            return;        }                for (i = 0; i < numberoffloatparameters; i++)        {            pname = dg_getplstring(                pBHarrayhead,                DG_STRINGOFFSETSTACK_BUFFERID,                DG_STRINGSTRINGSTACK_BUFFERID,                stringstackdepth - (numberoffloatparameters - i),  // stringid,                &namelength);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                return;            }                            // add the symbol name - it's a dconstant, paramindex dg_isparamusingframe            localwordid = dg_createdconstantdef (                pBHarrayhead,                numberofintparameters + i, // databufoffset                dg_isparamusingnoframe, // databufid,                pname,                namelength);                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                return;            }                            dg_linkdefinition(                pBHarrayhead,                localswordlistid,                localwordid);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)            {                dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);                return;            }        }    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_extraparametersfloatsflag,        parsingfloatsflag);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcparameters,        numberofintparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcfparameters,        numberoffloatparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthnoframeparamscurlyname);        return;    }}// framelocalscurlycomma// assumes using diaperglu standard frame//  assigns 0 1 2 to local names, doesn't care about type//   default size of local variable is 8 bytes for UINT64 and FLOAT64//   allow user to specify other size? (need to make sure alignment not compromised...)//  compiles code to add locals to stack// also need parametertoaddressmodeconst char dg_forthcreturnscurlyname[] = "CRETURNS<";void dg_forthcreturnscurly (Bufferhandle* pBHarrayhead){    UINT64 localwordid;    UINT64 localswordlistid;    UINT64 data;    UINT64 compiletype;        UINT64 numberofreturns = 0;        UINT64 foundendflag = FORTH_FALSE;    unsigned char* pname;    UINT64 namelength = 0;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        localswordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_localswordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcreturnscurlyname);        return;    }        while(foundendflag == FORTH_FALSE)    {        pname = dg_parsewords(            pBHarrayhead,            &namelength,            (unsigned char)'>',            &foundendflag,            FORTH_FALSE);                    if (namelength != 0)        {            if (numberofreturns < 2)            {                if (numberofreturns == 0)                {                    data = dg_rax;                }                else                {                    data = dg_rdx;                }                                compiletype = (UINT64)&dg_forthdocompiletypedpushn;                            localwordid = dg_newwordcopyname (                    pBHarrayhead,                    (UINT64)DG_CORE_BUFFERID,                    compiletype,                    0, // databufid,                    data, // databufoffset,                    (UINT64)DG_CORE_BUFFERID,                    (UINT64)pname,                    namelength);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthcreturnscurlyname);                    return;                }                                dg_linkdefinition(                    pBHarrayhead,                    localswordlistid,                    localwordid);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthcreturnscurlyname);                    return;                }            }                        numberofreturns++;        }    }}const char dg_forthcfreturnscurlyname[] = "CFRETURNS<";void dg_forthcfreturnscurly (Bufferhandle* pBHarrayhead){    UINT64 localwordid;    UINT64 localswordlistid;    UINT64 data;    UINT64 compiletype;        UINT64 numberofreturns = 0;        UINT64 foundendflag = FORTH_FALSE;    unsigned char* pname;    UINT64 namelength = 0;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        localswordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_localswordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcfreturnscurlyname);        return;    }        while(foundendflag == FORTH_FALSE)    {        pname = dg_parsewords(            pBHarrayhead,            &namelength,            (unsigned char)'>',            &foundendflag,            FORTH_FALSE);                    if (namelength != 0)        {            if (numberofreturns < 2)            {                if (numberofreturns == 0)                {                    data = dg_xmm0;                }                else                {                    data = dg_xmm1;                }                                compiletype = (UINT64)&dg_forthdocompiletypedpushn;                            localwordid = dg_newwordcopyname (                    pBHarrayhead,                    (UINT64)DG_CORE_BUFFERID,                    compiletype,                    0, // databufid,                    data, // databufoffset,                    (UINT64)DG_CORE_BUFFERID,                    (UINT64)pname,                    namelength);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthcfreturnscurlyname);                    return;                }                                dg_linkdefinition(                    pBHarrayhead,                    localswordlistid,                    localwordid);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthcfreturnscurlyname);                    return;                }            }                        numberofreturns++;        }    }}const char dg_forthlocalbracketrbppncurlyname[] = "LOCAL-[RBP+N]<";void dg_forthlocalbracketrbppncurly (Bufferhandle* pBHarrayhead){    UINT64 data = 0;    UINT64 base;    UINT64 foundendflag = FORTH_FALSE;    UINT64 flag;    unsigned char* pname;    UINT64 namelength = 0;        UINT64 localswordlistid;    UINT64 localwordid;        UINT64 numberoflocalvariables = 0;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        base = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        basevariable);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbasename);        dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);        return;    }        localswordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_localswordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);        return;    }        while(foundendflag == FORTH_FALSE)    {        pname = dg_parsewords(            pBHarrayhead,            &namelength,            (unsigned char)'>',            &foundendflag,            FORTH_FALSE);                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);            return;        }        if (namelength != 0)        {            // this is a signed conversion, a - sign in front of the number is acceptable            data = dg_pchartonumber(                pname,                namelength,                base,                &flag); // this routine doesn't return errors            if (flag != FORTH_FALSE)            {                dg_pushbufferuint64(                    pBHarrayhead,                    DG_DATASTACK_BUFFERID,                    data);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);                    dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);                    return;                }            }            else            {                data = dg_popbufferuint64(                    pBHarrayhead,                    DG_DATASTACK_BUFFERID);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);                    dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);                    return;                }                                localwordid = dg_newwordcopyname (                    pBHarrayhead,                    (UINT64)DG_CORE_BUFFERID,                    (UINT64)&dg_forthdocompiletypedpushbracketrbpplusn,                    0, // databufid,                    data, // databufoffset,                    (UINT64)DG_CORE_BUFFERID,                    (UINT64)pname,                    namelength);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);                    return;                }                                    dg_linkdefinition(                    pBHarrayhead,                    localswordlistid,                    localwordid);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthlocalbracketrbppncurlyname);                    return;                }            }        }    }}const char dg_forthframecurlyname[] = "FRAME<";void dg_forthframecurly (Bufferhandle* pBHarrayhead){    UINT64 localwordid;    UINT64 localswordlistid;    UINT64 data;    UINT64 compiletype = (UINT64)&dg_forthdocompiletypedpushbracketrbpplusn;        UINT64 startingdepth;    UINT64 base;    UINT64 flag;        UINT64 currentdepth;        UINT64 currentrbpoffset = 0;        UINT64 foundendflag = FORTH_FALSE;        UINT64 numberofcellsonstack = 0;    unsigned char* pname;    UINT64 namelength = 0;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }            localswordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_localswordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecurlyname);        return;    }        startingdepth = dg_getbufferlength(        pBHarrayhead,        DG_DATASTACK_BUFFERID);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);        dg_pusherror(pBHarrayhead, dg_forthframecurlyname);        return;    }        base = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        basevariable);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbasename);        dg_pusherror(pBHarrayhead, dg_forthframecurlyname);        return;    }        while(foundendflag == FORTH_FALSE)    {        pname = dg_parsewords(            pBHarrayhead,            &namelength,            (unsigned char)'>',            &foundendflag,            FORTH_FALSE);                    if (namelength != 0)        {            data = dg_pchartonumber(                pname,                namelength,                base,                &flag); // this routine doesn't return errors            if (flag != FORTH_FALSE)            {                // this is the number of cells to allocate on the return stack                //  the default is 1                dg_pushbufferuint64(                    pBHarrayhead,                    DG_DATASTACK_BUFFERID,                    data);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);                    dg_pusherror(pBHarrayhead, dg_forthframecurlyname);                    return;                }            }            else            {                currentdepth = dg_getbufferlength(                    pBHarrayhead,                    DG_DATASTACK_BUFFERID);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthdatastackbufferidname);                    dg_pusherror(pBHarrayhead, dg_forthframecurlyname);                    return;                }                                if (currentdepth > startingdepth)                {                    data = dg_popdatastack(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthframecurlyname);                        return;                    }                }                else                {                    data = 1;                }                                currentrbpoffset -= data * sizeof(UINT64);                                numberofcellsonstack += data;                        // this assumes you are using RBP PUSH, RSP RBP MOV, at the entry of your subroutine                localwordid = dg_newwordcopyname (                    pBHarrayhead,                    (UINT64)DG_CORE_BUFFERID,                    compiletype,                    0, // databufid,                    currentrbpoffset, // databufoffset,                    (UINT64)DG_CORE_BUFFERID,                    (UINT64)pname,                    namelength);                                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthframecurlyname);                    return;                }                                dg_linkdefinition(                    pBHarrayhead,                    localswordlistid,                    localwordid);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                {                    dg_pusherror(pBHarrayhead, dg_forthframecurlyname);                    return;                }            }        }    }        dg_pushdatastack(        pBHarrayhead,         numberofcellsonstack);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecurlyname);        return;    }}const char dg_forthenterframecommaname[]         = "ENTER-FRAME,";const char dg_forthenterrbpframecommaname[] = "ENTER-RBP-FRAME,";void dg_forthenterrbpframecomma (Bufferhandle* pBHarrayhead){    // I think the ENTER, instruction can be used for this....    unsigned char pbuf[5] = "\x55\x48\x8B\xEC";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         4);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthenterrbpframecommaname);        return;    }        }const char dg_forthexitframecommaname[]     = "EXIT-FRAME,";void dg_forthexitframecomma (Bufferhandle* pBHarrayhead){    // I think the EXIT, instruction can be used for this....    unsigned char pbuf[5] = "\x48\x8B\xE5\x5D";        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_compilesegment (        pBHarrayhead,         (const char*)pbuf,         4);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthexitframecommaname);        return;    }        }const char dg_forthlocalcellsallocatecommaname[] = "LOCAL-CELLS-ALLOCATE,";void dg_forthlocalcellsallocatecomma (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        // need to subtract 8 * numberoflocalvariables from RSP    dg_pushdatastack(pBHarrayhead, sizeof(UINT64));        dg_forthstar(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlocalcellsallocatecommaname);        return;    }        dg_forthzeroimmediate(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlocalcellsallocatecommaname);        return;    }        dg_pushdatastack(pBHarrayhead, dg_rsp);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlocalcellsallocatecommaname);        return;    }        dg_forthsubcomma(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthlocalcellsallocatecommaname);        return;    }}const char dg_forthframecommacurlyname[] = "FRAME,<";void dg_forthframecommacurly (Bufferhandle* pBHarrayhead){    UINT64 numberofcellsonreturnstack;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_forthframecurly(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecommacurlyname);        return;    }        numberofcellsonreturnstack = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecommacurlyname);        return;    }        dg_pushdatastack(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecommacurlyname);        return;    }        dg_forthzeroimmediate(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecommacurlyname);        return;    }        dg_pushdatastack(pBHarrayhead, numberofcellsonreturnstack*8);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecommacurlyname);        return;    }        dg_forthzeroimmediate(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthframecommacurlyname);        return;    }        dg_forthentercomma(pBHarrayhead);}const char dg_forthdgluforthframelocalscommacurlyname[] = "DGLU-FORTH-FRAME-LOCALS,<";const char dg_forthcallsubsframelocalscommacurlyname[]  = "CALL-SUBS-FRAME-LOCALS,<";void dg_forthcallsubsframelocalscommacurly (Bufferhandle* pBHarrayhead){    UINT64 n;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pushdatastack(pBHarrayhead, 1);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallsubsframelocalscommacurlyname);        return;    }        dg_pushdatastack(pBHarrayhead, 0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallsubsframelocalscommacurlyname);        return;    }        dg_pushdatastack(pBHarrayhead, dg_isdgluforthframelocal);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallsubsframelocalscommacurlyname);        return;    }        dg_forthtypedlocalenumcurly(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallsubsframelocalscommacurlyname);        return;    }        n = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallsubsframelocalscommacurlyname);        return;    }        dg_compileaddnlocalstocallsubsframe (        pBHarrayhead,        n);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthcallsubsframelocalscommacurlyname);        return;    }}void dg_forthoimportcodelink(Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_pushdatastack(pBHarrayhead, DG_IMPORT_LINK_IMPORT_OFFSET);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_isoimportcodelinkname);        return;    }        dg_forthminus(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_isoimportcodelinkname);        return;    }        dg_pushdatastack(pBHarrayhead, dg_isccbufferoffsetnobracket);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_isoimportcodelinkname);        return;    }}const char dg_forthtoiparamname[] = ">IPARAM";void dg_forthtoiparam(Bufferhandle* pBHarrayhead){    UINT64 numberofintparameters;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        numberofintparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtoiparamname);        return;    }        numberofintparameters++;        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints,        numberofintparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtoiparamname);        return;    }        dg_pushdatastack(        pBHarrayhead,        dg_istointsubparam);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtoiparamname);        return;    }}const char dg_forthptoiparamname[] = "P>IPARAM";void dg_forthptoiparam(Bufferhandle* pBHarrayhead){    UINT64 numberofintparameters;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        numberofintparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthptoiparamname);        return;    }        numberofintparameters++;        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints,        numberofintparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthptoiparamname);        return;    }        dg_pushdatastack(        pBHarrayhead,        dg_isptointsubparam);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthptoiparamname);        return;    }}const char dg_forthtofparamname[] = ">FPARAM";void dg_forthtofparam(Bufferhandle* pBHarrayhead){    UINT64 numberoffloatparameters;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        numberoffloatparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberoffloats);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtofparamname);        return;    }        numberoffloatparameters++;        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberoffloats,        numberoffloatparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtofparamname);        return;    }        dg_pushdatastack(        pBHarrayhead,        dg_istofloatsubparam);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthtofparamname);        return;    }}const char dg_forthiparamfromname[] = "IPARAM>";void dg_forthiparamfrom(Bufferhandle* pBHarrayhead){    UINT64 numberofintparameters;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        numberofintparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthiparamfromname);        return;    }        numberofintparameters++;        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints,        numberofintparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthiparamfromname);        return;    }        dg_pushdatastack(        pBHarrayhead,        dg_isfromintsubparam);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthiparamfromname);        return;    }}const char dg_forthfparamfromname[] = "FPARAM>";void dg_forthfparamfrom(Bufferhandle* pBHarrayhead){    UINT64 numberoffloatparameters;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        numberoffloatparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberoffloats);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfparamfromname);        return;    }        numberoffloatparameters++;        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberoffloats,        numberoffloatparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfparamfromname);        return;    }        dg_pushdatastack(        pBHarrayhead,        dg_isfromfloatsubparam);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthfparamfromname);        return;    }}const char dg_forthbeginsubparamsname[] = "((";void dg_forthbeginsubparams(Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints,        0);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbeginsubparamsname);        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberoffloats,        0);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbeginsubparamsname);        return;    }        // push marker on data stack    dg_pushdatastack(pBHarrayhead, dg_subparamscommamarker);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthbeginsubparamsname);        return;    }}const char* dg_subparamsnotbalanced = " - parameters not balanced. If before function call, need one >IPARAM or >FPARAM after each parameter. If after function call, need one IPARAM> or FPARAM> before each parameter.";const char dg_forthendsubparamscommaname[] = ")),";void dg_forthendsubparamscomma(Bufferhandle* pBHarrayhead){    UINT64 numberofintparameters;    UINT64 numberoffloatparameters;    UINT64 numberofintparametersonstack;    UINT64 numberoffloatparametersonstack;        UINT64 i = 0;    UINT64 x;     UINT64 whichintparameter;    UINT64 whichfloatparameter;           UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }    // could check for misaligned datastack here    numberofintparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberofints);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);        return;    }        whichintparameter = numberofintparameters;        numberoffloatparameters = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_callsubnumberoffloats);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);        return;    }        whichfloatparameter = numberoffloatparameters;        dg_compilealignretstackb(        pBHarrayhead,        numberofintparameters,        numberoffloatparameters);            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);        return;    }        numberofintparametersonstack = 0;                    if     (        numberofintparameters > ( sizeof(intparameterslookuptable) / sizeof(UINT64) )     )    {        numberofintparametersonstack =             (numberofintparameters - (sizeof(intparameterslookuptable)/sizeof(UINT64)));    }        numberoffloatparametersonstack = 0;        if     (        numberoffloatparameters > ( sizeof(floatparameterslookuptable) / sizeof(UINT64) )     )    {        numberoffloatparametersonstack =             (numberoffloatparameters - (sizeof(floatparameterslookuptable)/sizeof(UINT64)));    }        // compile room for parameters on stack    i = numberofintparametersonstack + numberoffloatparametersonstack;        if (i != 0)    {        if (i > (largestsignedint / sizeof(UINT64)))        {            dg_pusherror(pBHarrayhead, dg_invalidparametererror);            dg_pusherror(pBHarrayhead, dg_compileaddnlocalstocallsubsframename);            return;        }            dg_compilesubnfromrsp(            pBHarrayhead,            i * sizeof(UINT64));            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);            return;        }    }        i = numberofintparameters + numberoffloatparameters;        while (i > 0)    {        // data stack doesn't move, but BHarray does... so the length pointer        //  might become invalid        x = dg_popdatastack(pBHarrayhead);                if (dg_geterrorcount(pBHarrayhead) != olderrorcount)        {            dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);            return;        }            // the top number on the stack should be one of >IPARAM >FPARAM IPARAM> FPARAM>        switch(x)        {            // dg_printzerostring(pBHarrayhead, (unsigned char*)"x = ");            // dg_writestdoutuint64tohex(pBHarrayhead, x);            // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                        case dg_istointsubparam:                            if (0 == whichintparameter)                {                    dg_pusherror(pBHarrayhead, dg_invalidparametererror);                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                // predecrement                whichintparameter--;                                // dg_printzerostring(pBHarrayhead, (unsigned char*)"which int = ");                // dg_writestdoutuint64tohex(pBHarrayhead, whichintparameter);                // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                                if (whichintparameter < (sizeof(intparameterslookuptable)/sizeof(UINT64)))                {                    // it's an int register                    dg_pushdatastack(                        pBHarrayhead,                        intparameterslookuptable[whichintparameter]);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthmovcomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                else                {                    dg_pushdatastack(pBHarrayhead, dg_rsp);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_pushdatastack(                        pBHarrayhead,                        (whichintparameter - (sizeof(intparameterslookuptable)/sizeof(UINT64))) * sizeof(UINT64));                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthbracketrplusd(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthmovcomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                                break;                            case dg_isptointsubparam:                            if (0 == whichintparameter)                {                    dg_pusherror(pBHarrayhead, dg_invalidparametererror);                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                // predecrement                whichintparameter--;                                // dg_printzerostring(pBHarrayhead, (unsigned char*)"which int = ");                // dg_writestdoutuint64tohex(pBHarrayhead, whichintparameter);                // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                                if (whichintparameter < (sizeof(intparameterslookuptable)/sizeof(UINT64)))                {                    // it's an int register                    dg_pushdatastack(                        pBHarrayhead,                        intparameterslookuptable[whichintparameter]);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthleacomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                else                {                    dg_pushdatastack(pBHarrayhead, dg_rsp);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_pushdatastack(                        pBHarrayhead,                        (whichintparameter - (sizeof(intparameterslookuptable)/sizeof(UINT64))) * sizeof(UINT64));                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthbracketrplusd(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthleacomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                                break;                            case dg_istofloatsubparam:                                if (0 == whichfloatparameter)                {                    dg_pusherror(pBHarrayhead, dg_invalidparametererror);                    dg_pusherror(pBHarrayhead, dg_pulloneaddressingmodename);                    return;                }                                // predecrement                whichfloatparameter--;                                if (whichfloatparameter < (sizeof(floatparameterslookuptable)/sizeof(UINT64)))                {                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"which float = ");                    // dg_writestdoutuint64tohex(pBHarrayhead, whichfloatparameter);                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                                        // dg_printzerostring(pBHarrayhead, (unsigned char*)"reg = ");                    // dg_writestdoutuint64tohex(pBHarrayhead, floatparameterslookuptable[whichfloatparameter]);                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                                    dg_pushdatastack(                        pBHarrayhead,                        floatparameterslookuptable[whichfloatparameter]);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                             dg_forthmovqcomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                else                {                    dg_pushdatastack(pBHarrayhead, dg_rsp);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_pushdatastack(                        pBHarrayhead,                        ( sizeof(UINT64) *                            (                                numberofintparametersonstack +                                ( whichfloatparameter  - (sizeof(floatparameterslookuptable)/sizeof(UINT64)) )                                // not checking for overflow                            )                         )                     );                                        // dg_printzerostring(pBHarrayhead, (unsigned char*)" - displacement = ");                    // dg_writestdoutuint64tohex(pBHarrayhead, ( sizeof(UINT64) *                    //        (                    //            ( whichfloatparameter  - (sizeof(floatparameterslookuptable)/sizeof(UINT64)) )                    //            + numberofintparametersonstack // not checking for overflow                    //        )                     //    ));                    // dg_printzerostring(pBHarrayhead, (unsigned char*)"\n");                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthbracketrplusd(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_forthmovqcomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                                break;                            case dg_isfromintsubparam:                                if (0 == whichintparameter)                {                    dg_pusherror(pBHarrayhead, dg_invalidparametererror);                    dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                    return;                }                                // predecrement                whichintparameter--;                                if (whichintparameter < (sizeof(intreturnparameterstable)/sizeof(UINT64)))                {                    // it's an int register                    dg_pushdatastack(                        pBHarrayhead,                        intreturnparameterstable[whichintparameter]);                                            if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                    dg_pushdatastack(                        pBHarrayhead,                        dg_isreverse);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                          return;                    }                                        dg_forthmovcomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                else                {                    // only two int return parameters are specified                    dg_pusherror(pBHarrayhead, (const char*)"too many integer return parameters (only two are allowed)");                    dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                    return;                }                                break;                            case dg_isfromfloatsubparam:                            if (0 == whichfloatparameter)                {                    dg_pusherror(pBHarrayhead, dg_invalidparametererror);                    dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                }                                // predecrement                whichfloatparameter--;                                if (whichfloatparameter < (sizeof(floatparameterslookuptable)/sizeof(UINT64)))                {                    dg_pushdatastack(                        pBHarrayhead,                        floatparameterslookuptable[whichfloatparameter]);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                                        dg_pushdatastack(                        pBHarrayhead,                        dg_isreverse);                                    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                          return;                    }                                             dg_forthmovqcomma(pBHarrayhead);                                        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)                    {                        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                        return;                    }                }                else                {                    // only two float return parameters are specified, but I'll allow 8                    dg_pusherror(pBHarrayhead, (const char*)"too many float return parameters (only two are allowed... but I'm allowing eight)");                    dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                    return;                }                                break;                            default:                            dg_pusherror(pBHarrayhead, (const char*)" - expected an >IPARAM or >FPARAM or IPARAM> or FPARAM> marker on top of the data stack for each parameter. Anything else is an error.");                dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);                                break;        }                i--;    }        // next on the stack should be the marker    i = dg_popdatastack(pBHarrayhead);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);        return;    }        if (i != dg_subparamscommamarker)    {        dg_pusherror(pBHarrayhead, dg_subparamsnotbalanced);        dg_pusherror(pBHarrayhead, dg_forthendsubparamscommaname);        return;    }}const char dg_forthimpname[] = "IMP";void dg_forthimp(Bufferhandle* pBHarrayhead){    dg_pushdatastack(pBHarrayhead, dg_rip);    dg_pushdatastack(pBHarrayhead, 0);  // displacement     dg_pushdatastack(pBHarrayhead, 4);  // displacement size      dg_pushdatastack(pBHarrayhead, dg_isbasedisplacement); }const char* dg_compileosymbolimportstuffname = "dg_compileosymbolimportstuff";// on windows you need to branch over where the import link will go//  the displacement of the previous instruction should already be set with the IMP command...// on Mac you don't need to do anything... and the displacement for IMP has to be 0//  since the Mac linker adds to the compiled offset instead of just setting itUINT64 dg_compileosymbolimportstuff(Bufferhandle* pBHarrayhead){    UINT64 ccbufid;    UINT64 ccbuflength;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return ((UINT64)-1);    }    ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileosymbolimportstuffname);    }    ccbuflength = dg_getbufferlength(        pBHarrayhead,        ccbufid);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compileosymbolimportstuffname);    }        return(ccbuflength - sizeof(UINT32));}const char* dg_compilecodelinkname = "dg_compilecodelink";UINT64 dg_compilecodelink(Bufferhandle* pBHarrayhead){    UINT64 x = 0;    UINT64 ccbufid;    UINT64 ccbuflength;    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);    if (baderrorcount == olderrorcount)    {        return ((UINT64)-1);    }    // on mac you do this:    dg_compilejmpbracketoffset(        pBHarrayhead,        0); // this is the link on Mac...             // has to be 0 because the mac linker adds the offset to the true link    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecodelinkname);    }    ccbufid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        currentcompilebuffer);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecodelinkname);    }    ccbuflength = dg_getbufferlength(        pBHarrayhead,        ccbufid);    if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_compilecodelinkname);    }    x = 0;    return(ccbuflength - sizeof(UINT32));  // the size of the displacement}struct Premadeword presortedx86words[dg_presortedx86wordlistsize + 2];Premadeword* dg_getppresortedx86words (){    UINT64 i = 0;    // 0    presortedx86words[i].pname                 = dg_forthstrtopstrpushcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstrtopstrpushcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstrtopstrpushcomma;    i++;        presortedx86words[i].pname                 = dg_forthbeginsubparamsname;    presortedx86words[i].namelength            = sizeof(dg_forthbeginsubparamsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbeginsubparams;    i++;        presortedx86words[i].pname                 = dg_forthendsubparamscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthendsubparamscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthendsubparamscomma;    i++;        presortedx86words[i].pname                 = dg_isforwardname;    presortedx86words[i].namelength            = sizeof(dg_isforwardname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isforward;    i++;        presortedx86words[i].pname                 = dg_forthdatasize128bitname;    presortedx86words[i].namelength            = sizeof(dg_forthdatasize128bitname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasize128bit;    i++;        presortedx86words[i].pname                 = dg_forthdatasizewordname;    presortedx86words[i].namelength            = sizeof(dg_forthdatasizewordname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasizeword;    i++;        presortedx86words[i].pname                 = dg_forthdatasize256bitname;    presortedx86words[i].namelength            = sizeof(dg_forthdatasize256bitname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasize256bit;    i++;        presortedx86words[i].pname                 = dg_forthdatasizedwordname;    presortedx86words[i].namelength            = sizeof(dg_forthdatasizedwordname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasizedword;    i++;        presortedx86words[i].pname                 = dg_isthreebytevexname;    presortedx86words[i].namelength            = sizeof(dg_isthreebytevexname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isthreebytevex;    i++;        presortedx86words[i].pname                 = dg_forthdatasizeqwordname;    presortedx86words[i].namelength            = sizeof(dg_forthdatasizeqwordname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasizeqword;    i++;        presortedx86words[i].pname                 = dg_forthdatasize80bitname;    presortedx86words[i].namelength            = sizeof(dg_forthdatasize80bitname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasize80bit;    i++;        presortedx86words[i].pname                 = dg_forthdatasizebytename;    presortedx86words[i].namelength            = sizeof(dg_forthdatasizebytename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdatasizebyte;    i++;        presortedx86words[i].pname                 = dg_isreversename;    presortedx86words[i].namelength            = sizeof(dg_isreversename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isreverse;    i++;        presortedx86words[i].pname                 = dg_forthtofparamname;    presortedx86words[i].namelength            = sizeof(dg_forthtofparamname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)dg_forthtofparam;    i++;        presortedx86words[i].pname                 = dg_forthtoiparamname;    presortedx86words[i].namelength            = sizeof(dg_forthtoiparamname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)dg_forthtoiparam;    i++;        presortedx86words[i].pname                 = dg_forthaaacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaaacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaaacomma;    i++;        presortedx86words[i].pname                 = dg_forthaadcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaadcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaadcomma;    i++;        presortedx86words[i].pname                 = dg_forthaamcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaamcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaamcomma;    i++;        presortedx86words[i].pname                 = dg_forthaascommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaascommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaascomma;    i++;        // 10    presortedx86words[i].pname                 = dg_forthadccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthadccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthadccomma;    i++;        presortedx86words[i].pname                 = dg_forthadcxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthadcxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthadcxcomma;    i++;        presortedx86words[i].pname                 = dg_forthaddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddcomma;    i++;        presortedx86words[i].pname                 = dg_forthaddpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthaddpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddpscomma;    i++;        presortedx86words[i].pname                 = dg_forthaddsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthaddsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddsscomma;    i++;        presortedx86words[i].pname                 = dg_forthaddsubpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddsubpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddsubpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthaddsubpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaddsubpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaddsubpscomma;    i++;        presortedx86words[i].pname                 = dg_forthadoxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthadoxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthadoxcomma;    i++;        presortedx86words[i].pname                 = dg_forthaesdeccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaesdeccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaesdeccomma;    i++;        presortedx86words[i].pname                 = dg_forthaesdeclastcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaesdeclastcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaesdeclastcomma;    i++;        presortedx86words[i].pname                 = dg_forthaesenccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaesenccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaesenccomma;    i++;        presortedx86words[i].pname                 = dg_forthaesenclastcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaesenclastcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaesenclastcomma;    i++;        presortedx86words[i].pname                 = dg_forthaesimccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaesimccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaesimccomma;    i++;        presortedx86words[i].pname                 = dg_forthaeskeygenassistcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaeskeygenassistcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaeskeygenassistcomma;    i++;        presortedx86words[i].pname                 = dg_ahname;    presortedx86words[i].namelength            = sizeof(dg_ahname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ah;    i++;        presortedx86words[i].pname                 = dg_forthahtoeflagscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthahtoeflagscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsahfcomma;    i++;        presortedx86words[i].pname                 = dg_alname;    presortedx86words[i].namelength            = sizeof(dg_alname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_al;    i++;        presortedx86words[i].pname                 = dg_forthaltoaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaltoaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthaltooutdxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaltooutdxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaltooutdxcomma;    i++;        presortedx86words[i].pname                 = dg_forthaltooutn8commaname;    presortedx86words[i].namelength            = sizeof(dg_forthaltooutn8commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaltooutn8comma;    i++;        presortedx86words[i].pname                 = dg_ccalwaysname;    presortedx86words[i].namelength            = sizeof(dg_ccalwaysname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccalways;    i++;        presortedx86words[i].pname                 = dg_forthandcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthandcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthandcomma;    i++;        presortedx86words[i].pname                 = dg_forthandncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthandncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthandncomma;    i++;        presortedx86words[i].pname                 = dg_forthandnpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthandnpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthandnpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthandnpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthandnpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthandnpscomma;    i++;        presortedx86words[i].pname                 = dg_forthandpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthandpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthandpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthandpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthandpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthandpscomma;    i++;        presortedx86words[i].pname                 = dg_fortharplcommaname;    presortedx86words[i].namelength            = sizeof(dg_fortharplcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_fortharplcomma;    i++;        presortedx86words[i].pname                 = dg_axname;    presortedx86words[i].namelength            = sizeof(dg_axname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ax;    i++;        // 20    presortedx86words[i].pname                 = dg_forthaxtodxaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaxtodxaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthaxtoeaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaxtoeaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcwdecomma;    i++;        presortedx86words[i].pname                 = dg_forthaxtooutdxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthaxtooutdxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaxtooutdxcomma;    i++;        presortedx86words[i].pname                 = dg_forthaxtooutn8commaname;    presortedx86words[i].namelength            = sizeof(dg_forthaxtooutn8commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthaxtooutn8comma;    i++;        presortedx86words[i].pname                 = dg_forthbegincommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbegincommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbegincomma;    i++;        presortedx86words[i].pname                 = dg_forthbextrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbextrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbextrcomma;    i++;        presortedx86words[i].pname                 = dg_bhname;    presortedx86words[i].namelength            = sizeof(dg_bhname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_bh;    i++;        presortedx86words[i].pname                 = dg_blname;    presortedx86words[i].namelength            = sizeof(dg_blname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_bl;    i++;        presortedx86words[i].pname                 = dg_forthblendpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblendpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblendpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthblendpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblendpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblendpscomma;    i++;        presortedx86words[i].pname                 = dg_forthblendvpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblendvpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblendvpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthblendvpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblendvpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblendvpscomma;    i++;        presortedx86words[i].pname                 = dg_forthblsicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblsicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblsicomma;    i++;        presortedx86words[i].pname                 = dg_forthblsmskcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblsmskcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblsmskcomma;    i++;        presortedx86words[i].pname                 = dg_forthblsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthblsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthblsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthboundcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthboundcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthboundcomma;    i++;        presortedx86words[i].pname                 = dg_bpname;    presortedx86words[i].namelength            = sizeof(dg_bpname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_bp;    i++;        presortedx86words[i].pname                 = dg_bplname;    presortedx86words[i].namelength            = sizeof(dg_bplname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_bpl;    i++;        presortedx86words[i].pname                 = dg_forthbsfcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbsfcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbsfcomma;    i++;        presortedx86words[i].pname                 = dg_forthbsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthbswapcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbswapcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbswapcomma;    i++;        // 30    presortedx86words[i].pname                 = dg_forthbtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbtcomma;    i++;        presortedx86words[i].pname                 = dg_forthbtccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbtccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbtccomma;    i++;        presortedx86words[i].pname                 = dg_forthbtrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbtrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbtrcomma;    i++;        presortedx86words[i].pname                 = dg_forthbtscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbtscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbtscomma;    i++;        presortedx86words[i].pname                 = dg_isbufferoffsetname;    presortedx86words[i].namelength            = sizeof(dg_isbufferoffsetname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isbufferoffset;    i++;        presortedx86words[i].pname                 = dg_bxname;    presortedx86words[i].namelength            = sizeof(dg_bxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_bx;    i++;        presortedx86words[i].pname                 = dg_forthbzhicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbzhicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbzhicomma;    i++;        presortedx86words[i].pname                 = dg_fortcctor8orm8name;    presortedx86words[i].namelength            = sizeof(dg_fortcctor8orm8name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsetcomma;    i++;        presortedx86words[i].pname                 = dg_forthcallcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcallcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcallcomma;    i++;        presortedx86words[i].pname                 = dg_iscallsubsframelocalname;    presortedx86words[i].namelength            = sizeof(dg_iscallsubsframelocalname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isdgluforthframelocal;    i++;        presortedx86words[i].pname                 = dg_forthcallsubsframelocalscommacurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthcallsubsframelocalscommacurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcallsubsframelocalscommacurly;    i++;        presortedx86words[i].pname                 = dg_forthcallbracketssplusn16commaname;    presortedx86words[i].namelength            = sizeof(dg_forthcallbracketssplusn16commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcallbracketssplusn16comma;    i++;        presortedx86words[i].pname                 = dg_forthcallbracketssplusn32commaname;    presortedx86words[i].namelength            = sizeof(dg_forthcallbracketssplusn32commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcallbracketssplusn32comma;    i++;        presortedx86words[i].pname                 = dg_forthcallbracketssplusn64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthcallbracketssplusn64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcallbracketssplusn64comma;    i++;        presortedx86words[i].pname                 = dg_forthcbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthcdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthcdqecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcdqecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcdqecomma;    i++;        presortedx86words[i].pname                 = dg_forthcflushcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcflushcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcflushcomma;    i++;    /*    presortedx86words[i].pname                 = dg_forthcfparameterscurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthcfparameterscurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcfparameterscurly;    i++;    */    presortedx86words[i].pname                 = dg_forthcfreturnscurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthcfreturnscurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcfreturnscurly;    i++;        // 40    presortedx86words[i].pname                 = dg_chname;    presortedx86words[i].namelength            = sizeof(dg_chname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ch;    i++;        presortedx86words[i].pname                 = dg_clname;    presortedx86words[i].namelength            = sizeof(dg_clname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cl;    i++;        presortedx86words[i].pname                 = dg_forthclaccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthclaccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthclaccomma;    i++;        presortedx86words[i].pname                 = dg_forthclccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthclccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthclccomma;    i++;        presortedx86words[i].pname                 = dg_forthcldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcldcomma;    i++;        presortedx86words[i].pname                 = dg_forthclicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthclicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthclicomma;    i++;        presortedx86words[i].pname                 = dg_forthcltscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcltscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcltscomma;    i++;        presortedx86words[i].pname                 = dg_forthcmccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmccomma;    i++;        presortedx86words[i].pname                 = dg_forthcmovcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmovcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmovcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmppdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmppdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmppdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmppscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmppscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmppscomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpsd2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpsd2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpsd2comma;    i++;        presortedx86words[i].pname                 = dg_forthcmpsqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpsqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpsqcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpsscomma;    i++;    // 50    presortedx86words[i].pname                 = dg_forthcmpswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpswcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpxchgcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpxchgcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpxchgcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpxchg16bcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpxchg16bcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpxchg16bcomma;    i++;        presortedx86words[i].pname                 = dg_forthcmpxchg8bcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcmpxchg8bcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcmpxchg8bcomma;    i++;        presortedx86words[i].pname                 = dg_forthcomisdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcomisdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcomisdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcomisscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcomisscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcomisscomma;    i++;        presortedx86words[i].pname                 = dg_compilepusholderrcnttoretname;    presortedx86words[i].namelength            = sizeof(dg_compilepusholderrcnttoretname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_compilepusholderrorcounttoret;    i++;        presortedx86words[i].pname                 = dg_compilequeryerrorname;    presortedx86words[i].namelength            = sizeof(dg_compilequeryerrorname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_compilequeryerror;    i++;        presortedx86words[i].pname                 = dg_forthcpuidcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcpuidcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcpuidcomma;    i++;        presortedx86words[i].pname                 = dg_forthcqocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcqocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcqocomma;    i++;        presortedx86words[i].pname                 = dg_iscontrolregname;    presortedx86words[i].namelength            = sizeof(dg_iscontrolregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_iscontrolreg;    i++;        presortedx86words[i].pname                 = dg_cr0name;    presortedx86words[i].namelength            = sizeof(dg_cr0name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cr0;    i++;        presortedx86words[i].pname                 = dg_cr2name;    presortedx86words[i].namelength            = sizeof(dg_cr2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cr2;    i++;        presortedx86words[i].pname                 = dg_cr3name;    presortedx86words[i].namelength            = sizeof(dg_cr3name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cr3;    i++;        presortedx86words[i].pname                 = dg_cr4name;    presortedx86words[i].namelength            = sizeof(dg_cr4name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cr4;    i++;        presortedx86words[i].pname                 = dg_cr8name;    presortedx86words[i].namelength            = sizeof(dg_cr8name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cr8;    i++;        presortedx86words[i].pname                 = dg_forthcrc32commaname;    presortedx86words[i].namelength            = sizeof(dg_forthcrc32commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcrc32comma;    i++;        presortedx86words[i].pname                 = dg_forthcreturnscurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthcreturnscurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcreturnscurly;    i++;        presortedx86words[i].pname                 = dg_cccsname;    presortedx86words[i].namelength            = sizeof(dg_cccsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cccs;    i++;        presortedx86words[i].pname                 = dg_isccbufferoffsetname;    presortedx86words[i].namelength            = sizeof(dg_isccbufferoffsetname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_iscurrentcompilebufferoffset;    i++;        presortedx86words[i].pname                 = dg_forthcvtdq2pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtdq2pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtdq2pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtdq2pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtdq2pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtdq2pscomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtpd2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtpd2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtpd2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtpd2picommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtpd2picommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtpd2picomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtpd2pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtpd2pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtpd2pscomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtpi2pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtpi2pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtpi2pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtpi2pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtpi2pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtpi2pscomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtps2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtps2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtps2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtps2pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtps2pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtps2pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtps2picommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtps2picommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtps2picomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtsd2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtsd2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtsd2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtsd2sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtsd2sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtsd2sscomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtsi2sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtsi2sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtsi2sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtsi2sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtsi2sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtsi2sscomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtss2sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtss2sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtss2sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvtss2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvtss2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvtss2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthcvttpd2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvttpd2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvttpd2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvttpd2picommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvttpd2picommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvttpd2picomma;    i++;        presortedx86words[i].pname                 = dg_forthcvttps2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvttps2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvttps2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthcvttps2picommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvttps2picommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvttps2picomma;    i++;        presortedx86words[i].pname                 = dg_forthcvttsd2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvttsd2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvttsd2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthcvttss2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcvttss2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcvttss2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthcwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthcwdecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthcwdecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcwdecomma;    i++;        presortedx86words[i].pname                 = dg_cxname;    presortedx86words[i].namelength            = sizeof(dg_cxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cx;    i++;    // 60    presortedx86words[i].pname                 = dg_forthdaacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdaacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdaacomma;    i++;        presortedx86words[i].pname                 = dg_forthdascommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdascommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdascomma;    i++;        presortedx86words[i].pname                 = dg_isdatasizename;    presortedx86words[i].namelength            = sizeof(dg_isdatasizename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isdatasize;    i++;        presortedx86words[i].pname                 = dg_forthdeccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdeccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdeccomma;    i++;        presortedx86words[i].pname                 = dg_isdgluforthframelocalname;    presortedx86words[i].namelength            = sizeof(dg_isdgluforthframelocalname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isdgluforthframelocal;    i++;        presortedx86words[i].pname                 = dg_forthdgluforthframelocalscommacurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthdgluforthframelocalscommacurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcallsubsframelocalscommacurly;    i++;        presortedx86words[i].pname                 = dg_dhname;    presortedx86words[i].namelength            = sizeof(dg_dhname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dh;    i++;        presortedx86words[i].pname                 = dg_diname;    presortedx86words[i].namelength            = sizeof(dg_diname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_di;    i++;        presortedx86words[i].pname                 = dg_dilname;    presortedx86words[i].namelength            = sizeof(dg_dilname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dil;    i++;        presortedx86words[i].pname                 = dg_forthdivcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdivcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdivcomma;    i++;        presortedx86words[i].pname                 = dg_forthdivpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdivpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdivpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthdivpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdivpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdivpscomma;    i++;        presortedx86words[i].pname                 = dg_forthdivsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdivsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdivsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthdivsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdivsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdivsscomma;    i++;        presortedx86words[i].pname                 = dg_dlname;    presortedx86words[i].namelength            = sizeof(dg_dlname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dl;    i++;        presortedx86words[i].pname                 = dg_forthdppdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdppdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdppdcomma;    i++;        presortedx86words[i].pname                 = dg_forthdppscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthdppscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthdppscomma;    i++;        presortedx86words[i].pname                 = dg_isdebugregname;    presortedx86words[i].namelength            = sizeof(dg_isdebugregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isdebugreg;    i++;        presortedx86words[i].pname                 = dg_dr0name;    presortedx86words[i].namelength            = sizeof(dg_dr0name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr0;    i++;        presortedx86words[i].pname                 = dg_dr1name;    presortedx86words[i].namelength            = sizeof(dg_dr1name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr1;    i++;        presortedx86words[i].pname                 = dg_dr2name;    presortedx86words[i].namelength            = sizeof(dg_dr2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr2;    i++;        presortedx86words[i].pname                 = dg_dr3name;    presortedx86words[i].namelength            = sizeof(dg_dr3name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr3;    i++;        presortedx86words[i].pname                 = dg_dr4name;    presortedx86words[i].namelength            = sizeof(dg_dr4name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr4;    i++;        presortedx86words[i].pname                 = dg_dr5name;    presortedx86words[i].namelength            = sizeof(dg_dr5name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr5;    i++;        presortedx86words[i].pname                 = dg_dr6name;    presortedx86words[i].namelength            = sizeof(dg_dr6name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr6;    i++;        presortedx86words[i].pname                 = dg_dr7name;    presortedx86words[i].namelength            = sizeof(dg_dr7name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dr7;    i++;        presortedx86words[i].pname                 = dg_dxname;    presortedx86words[i].namelength            = sizeof(dg_dxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_dx;    i++;        presortedx86words[i].pname                 = dg_eaxname;    presortedx86words[i].namelength            = sizeof(dg_eaxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_eax;    i++;    // 70    presortedx86words[i].pname                 = dg_fortheaxtoedxeaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_fortheaxtoedxeaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcdqcomma;    i++;     presortedx86words[i].pname                 = dg_fortheaxtooutdxcommaname;    presortedx86words[i].namelength            = sizeof(dg_fortheaxtooutdxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_fortheaxtooutdxcomma;    i++;        presortedx86words[i].pname                 = dg_fortheaxtooutn8commaname;    presortedx86words[i].namelength            = sizeof(dg_fortheaxtooutn8commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_fortheaxtooutn8comma;    i++;        presortedx86words[i].pname                 = dg_fortheaxtoraxcommaname;    presortedx86words[i].namelength            = sizeof(dg_fortheaxtoraxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcdqecomma;    i++;        presortedx86words[i].pname                 = dg_fortheaxjumpcommaname;    presortedx86words[i].namelength            = sizeof(dg_fortheaxjumpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_compilejumptorax;    i++;    presortedx86words[i].pname                 = dg_ebpname;    presortedx86words[i].namelength            = sizeof(dg_ebpname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ebp;    i++;        presortedx86words[i].pname                 = dg_ebxname;    presortedx86words[i].namelength            = sizeof(dg_ebxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ebx;    i++;        presortedx86words[i].pname                 = dg_ecxname;    presortedx86words[i].namelength            = sizeof(dg_ecxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ecx;    i++;        presortedx86words[i].pname                 = dg_ediname;    presortedx86words[i].namelength            = sizeof(dg_ediname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_edi;    i++;        presortedx86words[i].pname                 = dg_edxname;    presortedx86words[i].namelength            = sizeof(dg_edxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_edx;    i++;        presortedx86words[i].pname                 = dg_fortheflagstoahcommaname;    presortedx86words[i].namelength            = sizeof(dg_fortheflagstoahcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlahfcomma;    i++;        presortedx86words[i].pname                 = dg_eipname;    presortedx86words[i].namelength            = sizeof(dg_eipname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_eip;    i++;    // 80    presortedx86words[i].pname                 = dg_ishereplusdisplacementname;    presortedx86words[i].namelength            = sizeof(dg_ishereplusdisplacementname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ishereplusdisplacement;    i++;     presortedx86words[i].pname                 = dg_forthelsecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthelsecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthelse;    i++;        presortedx86words[i].pname                 = dg_forthemmscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthemmscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthemmscomma;    i++;        presortedx86words[i].pname                 = dg_forthentercommaname;    presortedx86words[i].namelength            = sizeof(dg_forthentercommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthentercomma;    i++;        presortedx86words[i].pname                 = dg_forthentercallsubsframecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthentercallsubsframecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthentercallsubsframecomma;    i++;        presortedx86words[i].pname                 = dg_forthenterframecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthenterframecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthenterrbpframecomma;    i++;        presortedx86words[i].pname                 = dg_forthenterrbpframecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthenterrbpframecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthenterrbpframecomma;    i++;        presortedx86words[i].pname                 = dg_cceqname;    presortedx86words[i].namelength            = sizeof(dg_cceqname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cceq;    i++;        presortedx86words[i].pname                 = dg_forthloopnzcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthloopnzcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthloopnzcomma;    i++;        presortedx86words[i].pname                 = dg_fortheqorloopwhilecommaname;    presortedx86words[i].namelength            = sizeof(dg_fortheqorloopwhilecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthzsorloopwhilecomma;    i++;        presortedx86words[i].pname                 = dg_esiname;    presortedx86words[i].namelength            = sizeof(dg_esiname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_esi;    i++;        presortedx86words[i].pname                 = dg_espname;    presortedx86words[i].namelength            = sizeof(dg_espname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_esp;    i++;        presortedx86words[i].pname                 = dg_forthexitcallsubsframecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthexitcallsubsframecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_compileexitlocals;    i++;        presortedx86words[i].pname                 = dg_forthexitframecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthexitframecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthexitframecomma;    i++;        presortedx86words[i].pname                 = dg_forthextractpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthextractpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthextractpscomma;    i++;        presortedx86words[i].pname                 = dg_forthf2xm1commaname;    presortedx86words[i].namelength            = sizeof(dg_forthf2xm1commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthf2xm1comma;    i++;        presortedx86words[i].pname                 = dg_forthfabscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfabscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfabscomma;    i++;        presortedx86words[i].pname                 = dg_forthfaddtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfaddtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfaddtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfaddpst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfaddpst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfaddpst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfaddst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfaddst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfaddst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfbldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfbldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfbldcomma;    i++;        presortedx86words[i].pname                 = dg_forthfbstpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfbstpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfbstpcomma;    i++;        presortedx86words[i].pname                 = dg_forthfchscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfchscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfchscomma;    i++;        presortedx86words[i].pname                 = dg_forthfclexcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfclexcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfclexcomma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovbtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovbtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovbtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovbtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovbecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovbecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovbetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovbetost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovbetost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovbetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovetost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovetost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnbtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnbtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnbtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnbtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnbecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnbecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnbetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnbetost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnbetost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnbetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnetost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnetost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnetost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnutost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovnutost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovnutost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovnutost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovutost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcmovutost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcmovutost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcmovutost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomitost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomitost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomitost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomitost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomipcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomipcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomiptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomiptost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomiptost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomiptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcompcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcompcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomptost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomptost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfcomppcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcomppcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcomppcomma;    i++;        presortedx86words[i].pname                 = dg_forthfcoscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfcoscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfcoscomma;    i++;        presortedx86words[i].pname                 = dg_forthfdecstpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdecstpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdecstpcomma;    i++;        presortedx86words[i].pname                 = dg_forthfdivtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdivtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdivtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfdivpst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdivpst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdivpst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfdivrtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdivrtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdivrtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfdivrpst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdivrpst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdivrpst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfdivrst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdivrst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdivrst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfdivst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdivst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdivst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfdupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfdupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfdupcomma;    i++;        presortedx86words[i].pname                 = dg_forthffreecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthffreecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthffreecomma;    i++;        presortedx86words[i].pname                 = dg_forthfiaddtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfiaddtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfiaddtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthficomtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthficomtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthficomtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthficomptost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthficomptost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthficomptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfidivtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfidivtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfidivtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfidivrtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfidivrtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfidivrtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfildcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfildcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfildcomma;    i++;        presortedx86words[i].pname                 = dg_forthfimultost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfimultost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfimultost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfincstpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfincstpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfincstpcomma;    i++;        presortedx86words[i].pname                 = dg_forthfinitcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfinitcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfinitcomma;    i++;        presortedx86words[i].pname                 = dg_forthfistcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfistcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfistcomma;    i++;        presortedx86words[i].pname                 = dg_forthfistpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfistpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfistpcomma;    i++;        presortedx86words[i].pname                 = dg_forthfisttpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfisttpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfisttpcomma;    i++;        presortedx86words[i].pname                 = dg_forthfisubtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfisubtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfisubtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfisubrtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfisubrtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfisubrtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfldcomma;    i++;        presortedx86words[i].pname                 = dg_forthfld1commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfld1commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfld1comma;    i++;        presortedx86words[i].pname                 = dg_forthfldcwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfldcwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfldcwcomma;    i++;        presortedx86words[i].pname                 = dg_forthfldenvcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfldenvcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfldenvcomma;    i++;        presortedx86words[i].pname                 = dg_forthfldpicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfldpicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfldpicomma;    i++;        presortedx86words[i].pname                 = dg_forthfldzcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfldzcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfldzcomma;    i++;    presortedx86words[i].pname                 = dg_forthfmultost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfmultost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfmultost0comma;    i++;            presortedx86words[i].pname                 = dg_forthfmulpst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfmulpst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfmulpst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfmulst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfmulst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfmulst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfnclexcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfnclexcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfnclexcomma;    i++;        presortedx86words[i].pname                 = dg_forthfninitcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfninitcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfninitcomma;    i++;        presortedx86words[i].pname                 = dg_forthfnopcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfnopcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfnopcomma;    i++;        presortedx86words[i].pname                 = dg_forthfnsavecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfnsavecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfnsavecomma;    i++;        presortedx86words[i].pname                 = dg_forthfnstcwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfnstcwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfnstcwcomma;    i++;        presortedx86words[i].pname                 = dg_forthfnstenvcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfnstenvcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfnstenvcomma;    i++;        presortedx86words[i].pname                 = dg_forthfnstswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfnstswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfnstswcomma;    i++;        presortedx86words[i].pname                 = dg_forthfparamfromname;    presortedx86words[i].namelength            = sizeof(dg_forthfparamfromname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfparamfrom;    i++;        presortedx86words[i].pname                 = dg_forthfpatancommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfpatancommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfpatancomma;    i++;        presortedx86words[i].pname                 = dg_forthfpremcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfpremcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfpremcomma;    i++;        presortedx86words[i].pname                 = dg_forthfprem1commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfprem1commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfprem1comma;    i++;        presortedx86words[i].pname                 = dg_forthfptancommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfptancommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfptancomma;    i++;        presortedx86words[i].pname                 = dg_forthframecommacurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthframecommacurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthframecommacurly;    i++;        presortedx86words[i].pname                 = dg_isparamusingframename;    presortedx86words[i].namelength            = sizeof(dg_isparamusingframename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isparamusingframe;    i++;        presortedx86words[i].pname                 = dg_forthframeparamscurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthframeparamscurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthframeparamscurly;    i++;        presortedx86words[i].pname                 = dg_forthframecurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthframecurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthframecurly;    i++;        presortedx86words[i].pname                 = dg_forthfrndintcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfrndintcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfrndintcomma;    i++;        presortedx86words[i].pname                 = dg_forthfrstorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfrstorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfrstorcomma;    i++;        presortedx86words[i].pname                 = dg_forthfsavecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsavecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsavecomma;    i++;        presortedx86words[i].pname                 = dg_forthfscalecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfscalecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfscalecomma;    i++;        presortedx86words[i].pname                 = dg_forthfsincommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsincommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsincomma;    i++;        presortedx86words[i].pname                 = dg_forthfsincoscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsincoscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsincoscomma;    i++;        presortedx86words[i].pname                 = dg_forthfsqrtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsqrtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsqrtcomma;    i++;    presortedx86words[i].pname                 = dg_forthfstcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfstcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfstcomma;    i++;        presortedx86words[i].pname                 = dg_forthfstcwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfstcwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfstcwcomma;    i++;        presortedx86words[i].pname                 = dg_forthfstenvcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfstenvcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfstenvcomma;    i++;        presortedx86words[i].pname                 = dg_forthfstpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfstpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfstpcomma;    i++;        presortedx86words[i].pname                 = dg_forthfstswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfstswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfstswcomma;    i++;        presortedx86words[i].pname                 = dg_forthfstswtoaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfstswtoaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfstswtoaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthfsubtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsubtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsubtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfsubpst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsubpst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsubpst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfsubrtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsubrtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsubrtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfsubrpst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsubrpst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsubrpst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfsubrst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsubrst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsubrst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfsubst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfsubst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfsubst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfswapcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfswapcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfswapcomma;    i++;        presortedx86words[i].pname                 = dg_forthftstcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthftstcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthftstcomma;    i++;        presortedx86words[i].pname                 = dg_forthfucomcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomtost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomitost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomitost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomitost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomitost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomipcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomipcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomiptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomiptost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomiptost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomiptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucompcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucompcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomptost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomptost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomptost0comma;    i++;        presortedx86words[i].pname                 = dg_forthfucomppcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfucomppcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfucomppcomma;    i++;        presortedx86words[i].pname                 = dg_forthfxamcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxamcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfxamcomma;    i++;        presortedx86words[i].pname                 = dg_forthfxchcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxchcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfswapcomma;    i++;        presortedx86words[i].pname                 = dg_forthfxchtost0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxchtost0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfxchst0tocomma;    i++;    presortedx86words[i].pname                 = dg_forthfxchst0tocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxchst0tocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfxchst0tocomma;    i++;        presortedx86words[i].pname                 = dg_forthfxrstorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxrstorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfxrstorcomma;    i++;        presortedx86words[i].pname                 = dg_forthfxsavecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxsavecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfxsavecomma;    i++;        presortedx86words[i].pname                 = dg_forthfxtractcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfxtractcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfxtractcomma;    i++;        presortedx86words[i].pname                 = dg_forthfyl2xcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthfyl2xcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfyl2xcomma;    i++;        presortedx86words[i].pname                 = dg_forthfyl2xp1commaname;    presortedx86words[i].namelength            = sizeof(dg_forthfyl2xp1commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthfyl2xp1comma;    i++;        presortedx86words[i].pname                 = dg_ccgename;    presortedx86words[i].namelength            = sizeof(dg_ccgename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccge;    i++;        presortedx86words[i].pname                 = dg_ccgtname;    presortedx86words[i].namelength            = sizeof(dg_ccgtname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccgt;    i++;    // 90        presortedx86words[i].pname                 = dg_forthhaddpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthhaddpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthhaddpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthhaddpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthhaddpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthhaddpscomma;    i++;        presortedx86words[i].pname                 = dg_forthhltcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthhltcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthhltcomma;    i++;        presortedx86words[i].pname                 = dg_forthhsubpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthhsubpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthhsubpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthhsubpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthhsubpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthhsubpscomma;    i++;        presortedx86words[i].pname                 = dg_forthidivcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthidivcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthidivcomma;    i++;        presortedx86words[i].pname                 = dg_forthifcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthifcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthifcomma;    i++;        presortedx86words[i].pname                 = dg_isimmediatename;    presortedx86words[i].namelength            = sizeof(dg_isimmediatename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isimmediate;    i++;        presortedx86words[i].pname                 = dg_forthimpname;    presortedx86words[i].namelength            = sizeof(dg_forthimpname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthimp;    i++;        presortedx86words[i].pname                 = dg_forthimulcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthimulcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthimulcomma;    i++;        presortedx86words[i].pname                 = dg_forthimulacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthimulacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthimulacomma;    i++;        presortedx86words[i].pname                 = dg_forthimulncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthimulncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthimulncomma;    i++;        presortedx86words[i].pname                 = dg_forthinccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinccomma;    i++;        presortedx86words[i].pname                 = dg_forthinsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthinsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthinsertpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinsertpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinsertpscomma;    i++;        presortedx86words[i].pname                 = dg_forthinsqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinsqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinsqcomma;    i++;        presortedx86words[i].pname                 = dg_forthinswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinswcomma;    i++;        presortedx86words[i].pname                 = dg_forthintcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthintcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthintcomma;    i++;        presortedx86words[i].pname                 = dg_forthint3commaname;    presortedx86words[i].namelength            = sizeof(dg_forthint3commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthint3comma;    i++;        // 100    presortedx86words[i].pname                 = dg_forthintocommaname;    presortedx86words[i].namelength            = sizeof(dg_forthintocommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthintocomma;    i++;        presortedx86words[i].pname                 = dg_forthinvdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinvdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinvdcomma;    i++;        presortedx86words[i].pname                 = dg_forthinvlpgcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinvlpgcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinvlpgcomma;    i++;        presortedx86words[i].pname                 = dg_forthinvpcidcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinvpcidcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinvpcidcomma;    i++;        presortedx86words[i].pname                 = dg_forthindxtoalcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthindxtoalcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthindxtoalcomma;    i++;        presortedx86words[i].pname                 = dg_forthindxtoaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthindxtoaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthindxtoaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthindxtoeaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthindxtoeaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthindxtoeaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthinn8toalcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinn8toalcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinn8toalcomma;    i++;        presortedx86words[i].pname                 = dg_forthinn8toaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinn8toaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinn8toaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthinn8toeaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthinn8toeaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthinn8toeaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthiparamfromname;    presortedx86words[i].namelength            = sizeof(dg_forthiparamfromname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthiparamfrom;    i++;        presortedx86words[i].pname                 = dg_forthiretdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthiretdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthiretdcomma;    i++;        presortedx86words[i].pname                 = dg_forthiretqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthiretqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthiretqcomma;    i++;        presortedx86words[i].pname                 = dg_forthjmpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthjmpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthjmpcomma;    i++;        presortedx86words[i].pname                 = dg_forthjmpbracketssplusn16commaname;    presortedx86words[i].namelength            = sizeof(dg_forthjmpbracketssplusn16commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthjmpbracketssplusn16comma;    i++;        presortedx86words[i].pname                 = dg_forthjmpbracketssplusn32commaname;    presortedx86words[i].namelength            = sizeof(dg_forthjmpbracketssplusn32commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthjmpbracketssplusn32comma;    i++;        presortedx86words[i].pname                 = dg_forthjmpbracketssplusn64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthjmpbracketssplusn64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthjmpbracketssplusn64comma;    i++;        presortedx86words[i].pname                 = dg_forthlahfcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlahfcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlahfcomma;    i++;        presortedx86words[i].pname                 = dg_forthlarcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlarcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlarcomma;    i++;        presortedx86words[i].pname                 = dg_forthlddqucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlddqucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlddqucomma;    i++;        presortedx86words[i].pname                 = dg_forthldmxcsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthldmxcsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthldmxcsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthldscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthldscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthldscomma;    i++;        presortedx86words[i].pname                 = dg_cclename;    presortedx86words[i].namelength            = sizeof(dg_cclename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccle;    i++;        presortedx86words[i].pname                 = dg_forthleacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthleacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthleacomma;    i++;        presortedx86words[i].pname                 = dg_forthleavecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthleavecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthleavecomma;    i++;        presortedx86words[i].pname                 = dg_forthlescommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlescommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlescomma;    i++;        presortedx86words[i].pname                 = dg_forthlfencecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlfencecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlfencecomma;    i++;        presortedx86words[i].pname                 = dg_forthlfscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlfscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlfscomma;    i++;        presortedx86words[i].pname                 = dg_forthlgdtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlgdtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlgdtcomma;    i++;        presortedx86words[i].pname                 = dg_forthlgscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlgscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlgscomma;    i++;        presortedx86words[i].pname                 = dg_forthlidtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlidtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlidtcomma;    i++;        presortedx86words[i].pname                 = dg_forthlldtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlldtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlldtcomma;    i++;        presortedx86words[i].pname                 = dg_forthlmswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlmswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlmswcomma;    i++;        presortedx86words[i].pname                 = dg_forthlocalcellsallocatecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlocalcellsallocatecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlocalcellsallocatecomma;    i++;        presortedx86words[i].pname                 = dg_forthlocalbracketrbppncurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthlocalbracketrbppncurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlocalbracketrbppncurly;    i++;        presortedx86words[i].pname                 = dg_forthlodsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlodsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlodsbcomma;    i++;    // 110    presortedx86words[i].pname                 = dg_forthlodsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlodsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlodsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthlodsqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlodsqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlodsqcomma;    i++;        presortedx86words[i].pname                 = dg_forthlodswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlodswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlodswcomma;    i++;        presortedx86words[i].pname                 = dg_forthloopcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthloopcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthloopcomma;    i++;        presortedx86words[i].pname                 = dg_forthloopwhilecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthloopwhilecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthloopwhilecomma;    i++;        presortedx86words[i].pname                 = dg_forthlslcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlslcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlslcomma;    i++;        presortedx86words[i].pname                 = dg_forthlsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlsscomma;    i++;        presortedx86words[i].pname                 = dg_ccltname;    presortedx86words[i].namelength            = sizeof(dg_ccltname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cclt;    i++;        presortedx86words[i].pname                 = dg_forthltrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthltrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthltrcomma;    i++;        presortedx86words[i].pname                 = dg_forthlzcntcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthlzcntcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthlzcntcomma;    i++;        presortedx86words[i].pname                 = dg_forthmaskmovdqucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmaskmovdqucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmaskmovdqucomma;    i++;        presortedx86words[i].pname                 = dg_forthmaskmovqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmaskmovqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmaskmovqcomma;    i++;        presortedx86words[i].pname                 = dg_forthmaxpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmaxpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmaxpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmaxpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmaxpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmaxpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmaxsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmaxsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmaxsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmaxsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmaxsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmaxsscomma;    i++;        presortedx86words[i].pname                 = dg_forthmfencecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmfencecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmfencecomma;    i++;        presortedx86words[i].pname                 = dg_ccminame;    presortedx86words[i].namelength            = sizeof(dg_ccminame);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccmi;    i++;        presortedx86words[i].pname                 = dg_forthminpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthminpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthminpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthminpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthminpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthminpscomma;    i++;        presortedx86words[i].pname                 = dg_forthminsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthminsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthminsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthminsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthminsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthminsscomma;    i++;        presortedx86words[i].pname                 = dg_forthmonitorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmonitorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmonitorcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovaltobracketncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovaltobracketncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovaltobracketncomma;    i++;        presortedx86words[i].pname                 = dg_forthmovapdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovapdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovapdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovapscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovapscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovapscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovaxtobracketncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovaxtobracketncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovaxtobracketncomma;    i++;        presortedx86words[i].pname                 = dg_forthmovbecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovbecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovbecomma;    i++;        presortedx86words[i].pname                 = dg_forthmovcrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovcrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovcrcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovddupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovddupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovddupcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovdq2qcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovdq2qcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovdq2qcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovdqacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovdqacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovdqacomma;    i++;        presortedx86words[i].pname                 = dg_forthmovdqucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovdqucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovdqucomma;    i++;        presortedx86words[i].pname                 = dg_forthmovdrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovdrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovdrcomma;    i++;        presortedx86words[i].pname                 = dg_forthmoveaxtobracketncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmoveaxtobracketncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmoveaxtobracketncomma;    i++;        presortedx86words[i].pname                 = dg_forthmovhlpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovhlpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovhlpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovhpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovhpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovhpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovhpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovhpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovhpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovlhpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovlhpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovlhpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovlpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovlpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovlpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovlpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovlpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovlpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovmskpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovmskpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovmskpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovmskpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovmskpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovmskpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovntdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovntdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovntdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovntdqacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovntdqacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovntdqacomma;    i++;        presortedx86words[i].pname                 = dg_forthmovnticommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovnticommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovnticomma;    i++;        presortedx86words[i].pname                 = dg_forthmovntpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovntpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovntpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovntpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovntpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovntpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovntqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovntqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovntqcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovqcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovq2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovq2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovq2comma;    i++;        presortedx86words[i].pname                 = dg_forthmovq2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovq2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovq2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovraxtobracketncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovraxtobracketncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovraxtobracketncomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsd2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsd2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsd2comma;    i++;        presortedx86words[i].pname                 = dg_forthmovshdupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovshdupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovshdupcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsldupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsldupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsldupcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsqcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsscomma;    i++;    // 120    presortedx86words[i].pname                 = dg_forthmovswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovswcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsxcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovsxdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovsxdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovsxdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovupdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovupdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovupdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovupscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovupscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovupscomma;    i++;        presortedx86words[i].pname                 = dg_forthmovzxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovzxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovzxcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovbracketntoalcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovbracketntoalcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovbracketntoalcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovbracketntoaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovbracketntoaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovbracketntoaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovbracketntoeaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovbracketntoeaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovbracketntoeaxcomma;    i++;        presortedx86words[i].pname                 = dg_forthmovbracketntoraxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmovbracketntoraxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmovbracketntoraxcomma;    i++;        presortedx86words[i].pname                 = dg_forthmpsadbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmpsadbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmpsadbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthmulcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmulcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmulcomma;    i++;        presortedx86words[i].pname                 = dg_forthmulpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmulpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmulpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmulpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmulpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmulpscomma;    i++;        presortedx86words[i].pname                 = dg_forthmulsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmulsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmulsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthmulsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmulsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmulsscomma;    i++;        presortedx86words[i].pname                 = dg_forthmulxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmulxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmulxcomma;    i++;        presortedx86words[i].pname                 = dg_forthmwaitcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthmwaitcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthmwaitcomma;    i++;        presortedx86words[i].pname                 = dg_forthzeroimmediatename;    presortedx86words[i].namelength            = sizeof(dg_forthzeroimmediatename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthzeroimmediate;    i++;        presortedx86words[i].pname                 = dg_ntoeaxcommaname;    presortedx86words[i].namelength            = sizeof(dg_ntoeaxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_ntoeaxcomma;    i++;        presortedx86words[i].pname                 = dg_ccncname;    presortedx86words[i].namelength            = sizeof(dg_ccncname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccnc;    i++;        presortedx86words[i].pname                 = dg_ccnename;    presortedx86words[i].namelength            = sizeof(dg_ccnename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccne;    i++;        presortedx86words[i].pname                 = dg_forthnegcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthnegcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthnegcomma;    i++;    // 130    presortedx86words[i].pname                 = dg_forthloopeqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthloopeqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthloopzscomma;    i++;        presortedx86words[i].pname                 = dg_forthneorloopwhilecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthneorloopwhilecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthnzorloopwhilecomma;    i++;        presortedx86words[i].pname                 = dg_ccnevername;    presortedx86words[i].namelength            = sizeof(dg_ccnevername);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccnever;    i++;        presortedx86words[i].pname                 = dg_isparamusingnoframename;    presortedx86words[i].namelength            = sizeof(dg_isparamusingnoframename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isparamusingnoframe;    i++;        presortedx86words[i].pname                 = dg_forthnoframeparamscurlyname;    presortedx86words[i].namelength            = sizeof(dg_forthnoframeparamscurlyname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthnoframeparamscurly;    i++;        presortedx86words[i].pname                 = dg_forthnopcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthnopcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthnopcomma;    i++;        presortedx86words[i].pname                 = dg_noregname;    presortedx86words[i].namelength            = sizeof(dg_noregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_noreg;    i++;        presortedx86words[i].pname                 = dg_forthnotcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthnotcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthnotcomma;    i++;        presortedx86words[i].pname                 = dg_ccnpname;    presortedx86words[i].namelength            = sizeof(dg_ccnpname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccnp;    i++;        presortedx86words[i].pname                 = dg_ccnsname;    presortedx86words[i].namelength            = sizeof(dg_ccnsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccns;    i++;        presortedx86words[i].pname                 = dg_ccnvname;    presortedx86words[i].namelength            = sizeof(dg_ccnvname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccnv;    i++;        presortedx86words[i].pname                 = dg_ccnzname;    presortedx86words[i].namelength            = sizeof(dg_ccnzname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccnz;    i++;        // 140    presortedx86words[i].pname                 = dg_forthloopzscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthloopzscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthloopzscomma;    i++;        presortedx86words[i].pname                 = dg_forthnzorloopwhilecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthnzorloopwhilecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthnzorloopwhilecomma;    i++;        presortedx86words[i].pname                 = dg_forthnzuntilrepcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthnzuntilrepcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrepecomma;    i++;        presortedx86words[i].pname                 = dg_isccbufferoffset2name;    presortedx86words[i].namelength            = sizeof(dg_isccbufferoffset2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isccbufferoffsetnobracket;    i++;        presortedx86words[i].pname                 = dg_isoimportcodelinkname;    presortedx86words[i].namelength            = sizeof(dg_isoimportcodelinkname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthoimportcodelink;    i++;        presortedx86words[i].pname                 = dg_forthopushcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthopushcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthopushcomma;    i++;        presortedx86words[i].pname                 = dg_forthorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthorcomma;    i++;        presortedx86words[i].pname                 = dg_forthorpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthorpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthorpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthorpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthorpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthorpscomma;    i++;        presortedx86words[i].pname                 = dg_forthoutsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthoutsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthoutsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthoutsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthoutsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthoutsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthoutsqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthoutsqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthoutsqcomma;    i++;        presortedx86words[i].pname                 = dg_forthoutswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthoutswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthoutswcomma;    i++;        presortedx86words[i].pname                 = dg_forthptoiparamname;    presortedx86words[i].namelength            = sizeof(dg_forthptoiparamname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthptoiparam;    i++;        presortedx86words[i].pname                 = dg_forthpabsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpabsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpabsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpabsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpabsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpabsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpabswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpabswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpabswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpackssdwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpackssdwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpackssdwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpacksswbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpacksswbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpacksswbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpackusdwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpackusdwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpackusdwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpackuswbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpackuswbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpackuswbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpaddbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpaddbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpaddbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpadddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpadddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpadddcomma;    i++;        presortedx86words[i].pname                 = dg_forthpaddqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpaddqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpaddqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpaddsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpaddsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpaddsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpaddswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpaddswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpaddswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpaddusbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpaddusbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpaddusbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpadduswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpadduswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpadduswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpaddwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpaddwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpaddwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpalignrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpalignrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpalignrcomma;    i++;        presortedx86words[i].pname                 = dg_forthpandcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpandcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpandcomma;    i++;        presortedx86words[i].pname                 = dg_forthpandncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpandncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpandncomma;    i++;        presortedx86words[i].pname                 = dg_forthpausecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpausecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpausecomma;    i++;        presortedx86words[i].pname                 = dg_forthpavgbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpavgbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpavgbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpavgwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpavgwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpavgwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpblendvbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpblendvbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpblendvbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpblendwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpblendwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpblendwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpclmulqdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpclmulqdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpclmulqdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpeqbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpeqbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpeqbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpeqdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpeqdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpeqdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpeqqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpeqqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpeqqcomma;            i++;        presortedx86words[i].pname                 = dg_forthpcmpeqwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpeqwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpeqwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpestricommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpestricommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpestricomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpestrmcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpestrmcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpestrmcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpgtbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpgtbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpgtbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpgtdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpgtdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpgtdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpgtqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpgtqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpgtqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpgtwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpgtwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpgtwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpistricommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpistricommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpistricomma;    i++;        presortedx86words[i].pname                 = dg_forthpcmpistrmcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpcmpistrmcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpcmpistrmcomma;    i++;        presortedx86words[i].pname                 = dg_forthpdepcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpdepcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpdepcomma;    i++;        presortedx86words[i].pname                 = dg_forthpextcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpextcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpextcomma;    i++;        presortedx86words[i].pname                 = dg_forthpextrbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpextrbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpextrbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpextrdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpextrdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpextrdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpextrqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpextrqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpextrqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpextrwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpextrwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpextrwcomma;    i++;        presortedx86words[i].pname                 = dg_forthphadddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphadddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphadddcomma;    i++;        presortedx86words[i].pname                 = dg_forthphaddswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphaddswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphaddswcomma;    i++;        presortedx86words[i].pname                 = dg_forthphaddwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphaddwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphaddwcomma;    i++;        presortedx86words[i].pname                 = dg_forthphminposuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphminposuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphminposuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthphsubdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphsubdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphsubdcomma;    i++;        presortedx86words[i].pname                 = dg_forthphsubswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphsubswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphsubswcomma;    i++;        presortedx86words[i].pname                 = dg_forthphsubwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthphsubwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthphsubwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpinsrbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpinsrbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpinsrbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpinsrdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpinsrdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpinsrdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpinsrqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpinsrqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpinsrqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpinsrwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpinsrwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpinsrwcomma;    i++;        presortedx86words[i].pname                 = dg_ccplname;    presortedx86words[i].namelength            = sizeof(dg_ccplname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccpl;    i++;        presortedx86words[i].pname                 = dg_forthpmaddubswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaddubswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaddubswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaddubwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaddubwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaddubwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaddwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaddwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaddwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaxsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaxsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaxsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaxsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaxsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaxsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaxswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaxswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaxswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaxubcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaxubcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaxubcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaxudcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaxudcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaxudcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmaxuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmaxuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmaxuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpminsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpminsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpminsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpminsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpminsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpminsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpminswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpminswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpminswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpminubcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpminubcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpminubcomma;    i++;        presortedx86words[i].pname                 = dg_forthpminudcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpminudcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpminudcomma;    i++;        presortedx86words[i].pname                 = dg_forthpminuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpminuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpminuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovmskbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovmskbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovmskbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovsxbdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovsxbdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovsxbdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovsxbqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovsxbqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovsxbqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovsxbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovsxbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovsxbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovsxdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovsxdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovsxdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovsxwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovsxwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovsxwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovsxwqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovsxwqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovsxwqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovzxbdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovzxbdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovzxbdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovzxbqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovzxbqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovzxbqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovzxbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovzxbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovzxbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovzxdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovzxdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovzxdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovzxwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovzxwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovzxwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmovzxwqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmovzxwqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmovzxwqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmuldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmuldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmuldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmulhrswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmulhrswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmulhrswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmulhuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmulhuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmulhuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmulhwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmulhwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmulhwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmulldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmulldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmulldcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmullwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmullwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmullwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpmuludqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpmuludqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpmuludqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpopcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpopcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpopcomma;    i++;        presortedx86words[i].pname                 = dg_forthpopadcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpopadcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpopadcomma;    i++;    // 150        presortedx86words[i].pname                 = dg_forthpopcntcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpopcntcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpopcntcomma;    i++;        presortedx86words[i].pname                 = dg_forthpopfcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpopfcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpopfdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpopfdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpopfdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpopfdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpopfqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpopfqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpopfdcomma;    i++;        presortedx86words[i].pname                 = dg_forthporcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthporcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthporcomma;    i++;        presortedx86words[i].pname                 = dg_forthprefetchntacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthprefetchntacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthprefetchntacomma;    i++;        presortedx86words[i].pname                 = dg_forthprefetcht0commaname;    presortedx86words[i].namelength            = sizeof(dg_forthprefetcht0commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthprefetcht0comma;    i++;        presortedx86words[i].pname                 = dg_forthprefetcht1commaname;    presortedx86words[i].namelength            = sizeof(dg_forthprefetcht1commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthprefetcht1comma;    i++;        presortedx86words[i].pname                 = dg_forthprefetcht2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthprefetcht2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthprefetcht2comma;    i++;        presortedx86words[i].pname                 = dg_forthprefetchwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthprefetchwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthprefetchwcomma;    i++;        presortedx86words[i].pname                 = dg_forthprefetchwt1commaname;    presortedx86words[i].namelength            = sizeof(dg_forthprefetchwt1commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthprefetchwt1comma;    i++;        presortedx86words[i].pname                 = dg_ccpsname;    presortedx86words[i].namelength            = sizeof(dg_ccpsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccps;    i++;        presortedx86words[i].pname                 = dg_forthpsadbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsadbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsadbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpshufbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpshufbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpshufbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpshufdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpshufdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpshufdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpshufhwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpshufhwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpshufhwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpshuflwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpshuflwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpshuflwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpshufwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpshufwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpshufwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsignbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsignbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsignbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsigndcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsigndcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsigndcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsignwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsignwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsignwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpslldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpslldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpslldcomma;    i++;        presortedx86words[i].pname                 = dg_forthpslldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpslldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpslldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsllqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsllqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsllqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsllwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsllwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsllwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsradcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsradcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsradcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsrawcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsrawcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsrawcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsrldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsrldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsrldcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsrldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsrldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsrldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsrlqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsrlqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsrlqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsrlwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsrlwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsrlwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubusbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubusbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubusbcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubuswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubuswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubuswcomma;    i++;        presortedx86words[i].pname                 = dg_forthpsubwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpsubwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpsubwcomma;    i++;        presortedx86words[i].pname                 = dg_forthptestcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthptestcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthptestcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpckhbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpckhbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpckhbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpckhdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpckhdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpckhdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpckhqdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpckhqdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpckhqdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpckhwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpckhwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpckhwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpcklbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpcklbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpcklbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpckldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpckldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpckldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpcklqdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpcklqdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpcklqdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthpunpcklwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpunpcklwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpunpcklwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpushcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpushcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpushcomma;    i++;        presortedx86words[i].pname                 = dg_forthpushadcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpushadcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpushadcomma;    i++;        presortedx86words[i].pname                 = dg_forthpushfcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpushfcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpushfdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpushfdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpushfdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpushfdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpushfqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpushfqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpushfdcomma;    i++;        presortedx86words[i].pname                 = dg_forthpxorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthpxorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthpxorcomma;    i++;        presortedx86words[i].pname                 = dg_isregname;    presortedx86words[i].namelength            = sizeof(dg_isregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isreg;    i++;        presortedx86words[i].pname                 = dg_r10name;    presortedx86words[i].namelength            = sizeof(dg_r10name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r10;    i++;        presortedx86words[i].pname                 = dg_r10dname;    presortedx86words[i].namelength            = sizeof(dg_r10dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r10d;        i++;    presortedx86words[i].pname                 = dg_r10lname;    presortedx86words[i].namelength            = sizeof(dg_r10lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r10l;        i++;    presortedx86words[i].pname                 = dg_r10wname;    presortedx86words[i].namelength            = sizeof(dg_r10wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r10w;    i++;        presortedx86words[i].pname                 = dg_r11name;    presortedx86words[i].namelength            = sizeof(dg_r11name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r11;    i++;        presortedx86words[i].pname                 = dg_r11dname;    presortedx86words[i].namelength            = sizeof(dg_r11dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r11d;        i++;    presortedx86words[i].pname                 = dg_r11lname;    presortedx86words[i].namelength            = sizeof(dg_r11lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r11l;        i++;    presortedx86words[i].pname                 = dg_r11wname;    presortedx86words[i].namelength            = sizeof(dg_r11wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r11w;    i++;        presortedx86words[i].pname                 = dg_r12name;    presortedx86words[i].namelength            = sizeof(dg_r12name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r12;    i++;        presortedx86words[i].pname                 = dg_r12dname;    presortedx86words[i].namelength            = sizeof(dg_r12dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r12d;        i++;    presortedx86words[i].pname                 = dg_r12lname;    presortedx86words[i].namelength            = sizeof(dg_r12lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r12l;        i++;    presortedx86words[i].pname                 = dg_r12wname;    presortedx86words[i].namelength            = sizeof(dg_r12wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r12w;    i++;        presortedx86words[i].pname                 = dg_r13name;    presortedx86words[i].namelength            = sizeof(dg_r13name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r13;    i++;        presortedx86words[i].pname                 = dg_r13dname;    presortedx86words[i].namelength            = sizeof(dg_r13dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r13d;        i++;    presortedx86words[i].pname                 = dg_r13lname;    presortedx86words[i].namelength            = sizeof(dg_r13lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r13l;        i++;    presortedx86words[i].pname                 = dg_r13wname;    presortedx86words[i].namelength            = sizeof(dg_r13wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r13w;    i++;        presortedx86words[i].pname                 = dg_r14name;    presortedx86words[i].namelength            = sizeof(dg_r14name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r14;    i++;        presortedx86words[i].pname                 = dg_r14dname;    presortedx86words[i].namelength            = sizeof(dg_r14dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r14d;        i++;    presortedx86words[i].pname                 = dg_r14lname;    presortedx86words[i].namelength            = sizeof(dg_r14lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r14l;        i++;    presortedx86words[i].pname                 = dg_r14wname;    presortedx86words[i].namelength            = sizeof(dg_r14wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r14w;    i++;        presortedx86words[i].pname                 = dg_r15name;    presortedx86words[i].namelength            = sizeof(dg_r15name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r15;    i++;        presortedx86words[i].pname                 = dg_r15dname;    presortedx86words[i].namelength            = sizeof(dg_r15dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r15d;        i++;    presortedx86words[i].pname                 = dg_r15lname;    presortedx86words[i].namelength            = sizeof(dg_r15lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r15l;        i++;    presortedx86words[i].pname                 = dg_r15wname;    presortedx86words[i].namelength            = sizeof(dg_r15wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r15w;    i++;        presortedx86words[i].pname                 = dg_r8name;    presortedx86words[i].namelength            = sizeof(dg_r8name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r8;    i++;        presortedx86words[i].pname                 = dg_r8dname;    presortedx86words[i].namelength            = sizeof(dg_r8dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r8d;        i++;    presortedx86words[i].pname                 = dg_r8lname;    presortedx86words[i].namelength            = sizeof(dg_r8lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r8l;        i++;    presortedx86words[i].pname                 = dg_r8wname;    presortedx86words[i].namelength            = sizeof(dg_r8wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r8w;    i++;        presortedx86words[i].pname                 = dg_r9name;    presortedx86words[i].namelength            = sizeof(dg_r9name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r9;    i++;        presortedx86words[i].pname                 = dg_r9dname;    presortedx86words[i].namelength            = sizeof(dg_r9dname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r9d;        i++;    presortedx86words[i].pname                 = dg_r9lname;    presortedx86words[i].namelength            = sizeof(dg_r9lname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r9l;        i++;    presortedx86words[i].pname                 = dg_r9wname;    presortedx86words[i].namelength            = sizeof(dg_r9wname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_r9w;    i++;        presortedx86words[i].pname                 = dg_raxname;    presortedx86words[i].namelength            = sizeof(dg_raxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rax;    i++;        presortedx86words[i].pname                 = dg_forthraxtordxraxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthraxtordxraxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthcqocomma;    i++;            presortedx86words[i].pname                 = dg_forthraxjumpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthraxjumpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_compilejumptorax;    i++;        presortedx86words[i].pname                 = dg_rbpname;    presortedx86words[i].namelength            = sizeof(dg_rbpname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rbp;    i++;        presortedx86words[i].pname                 = dg_rbxname;    presortedx86words[i].namelength            = sizeof(dg_rbxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rbx;    i++;        presortedx86words[i].pname                 = dg_forthrclcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrclcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrclcomma;    i++;        presortedx86words[i].pname                 = dg_forthrcppscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrcppscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrcppscomma;    i++;        presortedx86words[i].pname                 = dg_forthrcpsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrcpsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrcpsscomma;    i++;        presortedx86words[i].pname                 = dg_forthrcrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrcrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrcrcomma;    i++;        presortedx86words[i].pname                 = dg_rcxname;    presortedx86words[i].namelength            = sizeof(dg_rcxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rcx;    i++;        presortedx86words[i].pname                 = dg_forthrdfsbasecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdfsbasecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdfsbasecomma;    i++;        presortedx86words[i].pname                 = dg_forthrdgsbasecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdgsbasecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdgsbasecomma;    i++;        presortedx86words[i].pname                 = dg_rdiname;    presortedx86words[i].namelength            = sizeof(dg_rdiname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rdi;    i++;        presortedx86words[i].pname                 = dg_forthrdmsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdmsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdmsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthrdpmccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdpmccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdpmccomma;    i++;        presortedx86words[i].pname                 = dg_forthrdrandcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdrandcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdrandcomma;    i++;        presortedx86words[i].pname                 = dg_forthrdseedcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdseedcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdseedcomma;    i++;        presortedx86words[i].pname                 = dg_forthrdtsccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdtsccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdtsccomma;    i++;        presortedx86words[i].pname                 = dg_forthrdtscpcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrdtscpcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrdtscpcomma;    i++;        presortedx86words[i].pname                 = dg_rdxname;    presortedx86words[i].namelength            = sizeof(dg_rdxname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rdx;    i++;        presortedx86words[i].pname                 = dg_forthrepcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrepcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrepcomma;    i++;        presortedx86words[i].pname                 = dg_forthrepecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrepecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrepecomma;    i++;    // 160    presortedx86words[i].pname                 = dg_forthrepeatcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrepeatcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrepeat;    i++;        presortedx86words[i].pname                 = dg_forthrepnecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrepnecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrepnecomma;    i++;        presortedx86words[i].pname                 = dg_forthretcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthretcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthretcomma;    i++;        presortedx86words[i].pname                 = dg_forthretdropn16commaname;    presortedx86words[i].namelength            = sizeof(dg_forthretdropn16commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthretdropn16comma;    i++;        presortedx86words[i].pname                 = dg_forthretfarcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthretfarcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthretfarcomma;    i++;        presortedx86words[i].pname                 = dg_forthretfardropn16commaname;    presortedx86words[i].namelength            = sizeof(dg_forthretfardropn16commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthretfardropn16comma;    i++;        presortedx86words[i].pname                 = dg_ripname;    presortedx86words[i].namelength            = sizeof(dg_ripname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rip;    i++;        presortedx86words[i].pname                 = dg_ishereplusdisplacement64name;    presortedx86words[i].namelength            = sizeof(dg_ishereplusdisplacement64name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ishereplusdisplacement;    i++;        presortedx86words[i].pname                 = dg_forthrolcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrolcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrolcomma;    i++;        presortedx86words[i].pname                 = dg_forthrorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrorcomma;    i++;        presortedx86words[i].pname                 = dg_forthrorxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrorxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrorxcomma;    i++;        presortedx86words[i].pname                 = dg_forthroundpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthroundpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthroundpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthroundpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthroundpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthroundpscomma;    i++;        presortedx86words[i].pname                 = dg_forthroundsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthroundsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthroundsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthroundsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthroundsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthroundsscomma;    i++;        presortedx86words[i].pname                 = dg_rsiname;    presortedx86words[i].namelength            = sizeof(dg_rsiname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rsi;    i++;        presortedx86words[i].pname                 = dg_forthrsmcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrsmcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrsmcomma;    i++;        presortedx86words[i].pname                 = dg_rspname;    presortedx86words[i].namelength            = sizeof(dg_rspname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_rsp;    i++;        presortedx86words[i].pname                 = dg_forthrsqrtpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrsqrtpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrsqrtpscomma;    i++;        presortedx86words[i].pname                 = dg_forthrsqrtsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthrsqrtsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrsqrtsscomma;    i++;        presortedx86words[i].pname                 = dg_forthsahfcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsahfcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsahfcomma;    i++;        presortedx86words[i].pname                 = dg_forthsalcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsalcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshlcomma;    i++;        presortedx86words[i].pname                 = dg_forthsarcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsarcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsarcomma;    i++;        presortedx86words[i].pname                 = dg_forthsarxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsarxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsarxcomma;    i++;        presortedx86words[i].pname                 = dg_forthsbbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsbbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsbbcomma;    i++;        presortedx86words[i].pname                 = dg_scale1name;    presortedx86words[i].namelength            = sizeof(dg_scale1name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)(1);    i++;    // 170    presortedx86words[i].pname                 = dg_scale2name;    presortedx86words[i].namelength            = sizeof(dg_scale2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)(2);    i++;        presortedx86words[i].pname                 = dg_scale4name;    presortedx86words[i].namelength            = sizeof(dg_scale4name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)(4);    i++;        presortedx86words[i].pname                 = dg_scale8name;    presortedx86words[i].namelength            = sizeof(dg_scale8name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)(8);    i++;        presortedx86words[i].pname                 = dg_forthscasbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthscasbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthscasbcomma;    i++;        presortedx86words[i].pname                 = dg_forthscasdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthscasdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthscasdcomma;    i++;        presortedx86words[i].pname                 = dg_forthscasqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthscasqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthscasqcomma;    i++;        presortedx86words[i].pname                 = dg_forthscaswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthscaswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthscaswcomma;    i++;        presortedx86words[i].pname                 = dg_forthsetcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsetcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsetcomma;    i++;        presortedx86words[i].pname                 = dg_forthsfencecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsfencecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsfencecomma;    i++;        presortedx86words[i].pname                 = dg_forthsgdtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsgdtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsgdtcomma;    i++;        presortedx86words[i].pname                 = dg_forthshlcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshlcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshlcomma;    i++;        presortedx86words[i].pname                 = dg_forthshldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshldcomma;    i++;        presortedx86words[i].pname                 = dg_forthshlxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshlxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshlxcomma;    i++;        presortedx86words[i].pname                 = dg_forthshrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshrcomma;    i++;        presortedx86words[i].pname                 = dg_forthshrdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshrdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshrdcomma;    i++;        presortedx86words[i].pname                 = dg_forthshrxcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshrxcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshrxcomma;    i++;        presortedx86words[i].pname                 = dg_forthshufpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshufpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshufpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthshufpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthshufpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthshufpscomma;    i++;        presortedx86words[i].pname                 = dg_siname;    presortedx86words[i].namelength            = sizeof(dg_siname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_si;    i++;        presortedx86words[i].pname                 = dg_forthsidtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsidtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsidtcomma;    i++;        presortedx86words[i].pname                 = dg_silname;    presortedx86words[i].namelength            = sizeof(dg_silname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_sil;    i++;        presortedx86words[i].pname                 = dg_forthsldtcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsldtcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsldtcomma;    i++;        presortedx86words[i].pname                 = dg_forthsmswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsmswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsmswcomma;    i++;        presortedx86words[i].pname                 = dg_spname;    presortedx86words[i].namelength            = sizeof(dg_spname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_sp;    i++;        presortedx86words[i].pname                 = dg_splname;    presortedx86words[i].namelength            = sizeof(dg_splname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_spl;    i++;        presortedx86words[i].pname                 = dg_forthsqrtpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsqrtpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsqrtpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthsqrtpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsqrtpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsqrtpscomma;    i++;        presortedx86words[i].pname                 = dg_forthsqrtsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsqrtsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsqrtsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthsqrtsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsqrtsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsqrtsscomma;    i++;        presortedx86words[i].pname                 = dg_issegmentregname;    presortedx86words[i].namelength            = sizeof(dg_issegmentregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_issegmentreg;    i++;        presortedx86words[i].pname                 = dg_srcsname;    presortedx86words[i].namelength            = sizeof(dg_srcsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_segregcs;    i++;        presortedx86words[i].pname                 = dg_srdsname;    presortedx86words[i].namelength            = sizeof(dg_srdsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_segregds;    i++;        presortedx86words[i].pname                 = dg_sresname;    presortedx86words[i].namelength            = sizeof(dg_sresname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_segreges;    i++;        presortedx86words[i].pname                 = dg_srfsname;    presortedx86words[i].namelength            = sizeof(dg_srfsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_segregfs;    i++;        presortedx86words[i].pname                 = dg_srgsname;    presortedx86words[i].namelength            = sizeof(dg_srgsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_segreggs;    i++;        presortedx86words[i].pname                 = dg_srssname;    presortedx86words[i].namelength            = sizeof(dg_srssname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_segregss;    i++;        presortedx86words[i].pname                 = dg_ccssname;    presortedx86words[i].namelength            = sizeof(dg_ccssname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccss;    i++;        presortedx86words[i].pname                 = dg_st0name;    presortedx86words[i].namelength            = sizeof(dg_st0name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st0;    i++;        presortedx86words[i].pname                 = dg_st1name;    presortedx86words[i].namelength            = sizeof(dg_st1name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st1;    i++;        presortedx86words[i].pname                 = dg_st2name;    presortedx86words[i].namelength            = sizeof(dg_st2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st2;    i++;        presortedx86words[i].pname                 = dg_st3name;    presortedx86words[i].namelength            = sizeof(dg_st3name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st3;    i++;        presortedx86words[i].pname                 = dg_st4name;    presortedx86words[i].namelength            = sizeof(dg_st4name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st4;    i++;        presortedx86words[i].pname                 = dg_st5name;    presortedx86words[i].namelength            = sizeof(dg_st5name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st5;    i++;        presortedx86words[i].pname                 = dg_st6name;    presortedx86words[i].namelength            = sizeof(dg_st6name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st6;    i++;        presortedx86words[i].pname                 = dg_st7name;    presortedx86words[i].namelength            = sizeof(dg_st7name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_st7;    i++;        presortedx86words[i].pname                 = dg_forthstaccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstaccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstaccomma;    i++;        presortedx86words[i].pname                 = dg_forthstccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstccomma;    i++;        presortedx86words[i].pname                 = dg_forthstdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstdcomma;    i++;        presortedx86words[i].pname                 = dg_forthsticommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsticommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsticomma;    i++;        presortedx86words[i].pname                 = dg_forthstmxcsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstmxcsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstmxcsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthstosbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstosbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstosbcomma;    i++;        presortedx86words[i].pname                 = dg_forthstosdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstosdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstosdcomma;    i++;        presortedx86words[i].pname                 = dg_forthstosqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstosqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstosqcomma;    i++;    // 190    presortedx86words[i].pname                 = dg_forthstoswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstoswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstoswcomma;    i++;        presortedx86words[i].pname                 = dg_forthstrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthstrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthstrcomma;    i++;        presortedx86words[i].pname                 = dg_forthsubcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsubcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsubcomma;    i++;        presortedx86words[i].pname                 = dg_forthsubpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsubpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsubpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthsubpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsubpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsubpscomma;    i++;        presortedx86words[i].pname                 = dg_forthsubsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsubsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsubsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthsubsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsubsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsubsscomma;    i++;        presortedx86words[i].pname                 = dg_forthswapgscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthswapgscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthswapgscomma;    i++;        presortedx86words[i].pname                 = dg_forthsyscallcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsyscallcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsyscallcomma;    i++;        presortedx86words[i].pname                 = dg_forthsysentercommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsysentercommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsysentercomma;    i++;        presortedx86words[i].pname                 = dg_forthsysexitcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthsysexitcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsysexitcomma;    i++;        presortedx86words[i].pname                 = dg_forthsysretto32commaname;    presortedx86words[i].namelength            = sizeof(dg_forthsysretto32commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsysretto32comma;    i++;        presortedx86words[i].pname                 = dg_forthsysretto64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthsysretto64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthsysretto64comma;    i++;        presortedx86words[i].pname                 = dg_forthtestcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthtestcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthtestcomma;    i++;        presortedx86words[i].pname                 = dg_forththencommaname;    presortedx86words[i].namelength            = sizeof(dg_forththencommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forththen;    i++;        presortedx86words[i].pname                 = dg_forthtzcntcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthtzcntcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthtzcntcomma;    i++;        presortedx86words[i].pname                 = dg_forthucomisdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthucomisdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthucomisdcomma;    i++;        presortedx86words[i].pname                 = dg_forthucomisscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthucomisscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthucomisscomma;    i++;        presortedx86words[i].pname                 = dg_forthud2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthud2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthud2comma;    i++;        presortedx86words[i].pname                 = dg_ccugename;    presortedx86words[i].namelength            = sizeof(dg_ccugename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccuge;    i++;        presortedx86words[i].pname                 = dg_ccugtname;    presortedx86words[i].namelength            = sizeof(dg_ccugtname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccugt;    i++;        presortedx86words[i].pname                 = dg_cculename;    presortedx86words[i].namelength            = sizeof(dg_cculename);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccule;    i++;        presortedx86words[i].pname                 = dg_ccultname;    presortedx86words[i].namelength            = sizeof(dg_ccultname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccult;    i++;        presortedx86words[i].pname                 = dg_forthunpckhpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthunpckhpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthunpckhpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthunpckhpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthunpckhpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthunpckhpscomma;    i++;        presortedx86words[i].pname                 = dg_forthunpcklpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthunpcklpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthunpcklpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthunpcklpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthunpcklpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthunpcklpscomma;    i++;        // 200    presortedx86words[i].pname                 = dg_forthuntilcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthuntilcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthuntilcomma;    i++;        presortedx86words[i].pname                 = dg_forthvaddpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaddpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaddpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvaddpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaddpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaddpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvaddsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaddsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaddsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvaddsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaddsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaddsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvaddsubpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaddsubpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaddsubpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvaddsubpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaddsubpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaddsubpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvaesdeccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaesdeccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaesdeccomma;    i++;        presortedx86words[i].pname                 = dg_forthvaesdeclastcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaesdeclastcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaesdeclastcomma;    i++;        presortedx86words[i].pname                 = dg_forthvaesenccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaesenccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaesenccomma;    i++;        presortedx86words[i].pname                 = dg_forthvaesenclastcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaesenclastcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaesenclastcomma;    i++;        presortedx86words[i].pname                 = dg_forthvaesimccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaesimccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaesimccomma;    i++;        presortedx86words[i].pname                 = dg_forthvaeskeygenassistcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvaeskeygenassistcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvaeskeygenassistcomma;    i++;        presortedx86words[i].pname                 = dg_forthvandnpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvandnpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvandnpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvandnpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvandnpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvandnpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvandpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvandpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvandpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvandpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvandpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvandpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvblendpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvblendpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvblendpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvblendpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvblendpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvblendpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvblendvpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvblendvpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvblendvpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvblendvpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvblendvpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvblendvpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvbroadcastf128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvbroadcastf128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvbroadcastf128comma;    i++;        presortedx86words[i].pname                 = dg_forthvbroadcastsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvbroadcastsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvbroadcastsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvbroadcastsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvbroadcastsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvbroadcastsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcmppdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcmppdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcmppdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcmppscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcmppscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcmppscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcmpsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcmpsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcmpsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcmpsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcmpsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcmpsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcomisdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcomisdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcomisdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcomisscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcomisscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcomisscomma;    i++;    presortedx86words[i].pname                 = dg_forthvcvtdq2pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtdq2pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtdq2pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtdq2pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtdq2pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtdq2pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtpd2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtpd2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtpd2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtpd2pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtpd2pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtpd2pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtph2pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtph2pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtph2pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtps2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtps2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtps2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtps2pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtps2pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtps2pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtps2phcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtps2phcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtps2phcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtsd2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtsd2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtsd2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtsd2sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtsd2sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtsd2sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtsi2sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtsi2sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtsi2sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtsi2sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtsi2sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtsi2sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtss2sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtss2sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtss2sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvtss2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvtss2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvtss2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvttpd2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvttpd2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvttpd2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvttps2dqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvttps2dqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvttps2dqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvttsd2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvttsd2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvttsd2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthvcvttss2sicommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvcvttss2sicommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvcvttss2sicomma;    i++;        presortedx86words[i].pname                 = dg_forthvdivpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvdivpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvdivpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvdivpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvdivpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvdivpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvdivsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvdivsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvdivsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvdivsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvdivsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvdivsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvdppdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvdppdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvdppdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvdppscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvdppscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvdppscomma;    i++;        presortedx86words[i].pname                 = dg_forthverrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthverrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthverrcomma;    i++;        presortedx86words[i].pname                 = dg_forthverwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthverwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthverwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvextractf128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvextractf128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvextractf128comma;    i++;        presortedx86words[i].pname                 = dg_forthvextracti128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvextracti128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvextracti128comma;    i++;        presortedx86words[i].pname                 = dg_forthvextractpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvextractpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvextractpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd132pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd132pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd132pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd132pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd132pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd132pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd132sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd132sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd132sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd132sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd132sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd132sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd213pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd213pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd213pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd213pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd213pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd213pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd213sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd213sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd213sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd213sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd213sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd213sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd231pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd231pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd231pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd231pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd231pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd231pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd231sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd231sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd231sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmadd231sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmadd231sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmadd231sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmaddsub132pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmaddsub132pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmaddsub132pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmaddsub132pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmaddsub132pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmaddsub132pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmaddsub213pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmaddsub213pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmaddsub213pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmaddsub213pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmaddsub213pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmaddsub213pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmaddsub231pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmaddsub231pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmaddsub231pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmaddsub231pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmaddsub231pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmaddsub231pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub132pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub132pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub132pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub132pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub132pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub132pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub132sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub132sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub132sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub132sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub132sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub132sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub213pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub213pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub213pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub213pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub213pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub213pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub213sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub213sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub213sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub213sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub213sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub213sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub231pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub231pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub231pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub231pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub231pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub231pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub231sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub231sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub231sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsub231sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsub231sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsub231sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsubadd132pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsubadd132pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsubadd132pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsubadd132pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsubadd132pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsubadd132pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsubadd213pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsubadd213pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsubadd213pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsubadd213pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsubadd213pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsubadd213pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsubadd231pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsubadd231pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsubadd231pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfmsubadd231pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfmsubadd231pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfmsubadd231pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd132pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd132pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd132pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd132pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd132pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd132pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd132sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd132sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd132sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd132sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd132sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd132sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd213pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd213pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd213pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd213pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd213pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd213pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd213sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd213sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd213sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd213sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd213sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd213sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd231pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd231pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd231pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd231pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd231pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd231pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd231sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd231sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd231sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmadd231sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmadd231sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmadd231sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub132pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub132pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub132pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub132pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub132pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub132pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub132sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub132sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub132sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub132sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub132sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub132sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub213pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub213pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub213pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub213pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub213pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub213pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub213sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub213sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub213sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub213sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub213sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub213sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub231pdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub231pdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub231pdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub231pscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub231pscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub231pscomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub231sdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub231sdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub231sdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvfnmsub231sscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvfnmsub231sscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvfnmsub231sscomma;    i++;        presortedx86words[i].pname                 = dg_forthvgatherdpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvgatherdpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvgatherdpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvgatherdpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvgatherdpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvgatherdpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvgatherqpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvgatherqpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvgatherqpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvgatherqpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvgatherqpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvgatherqpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvhaddpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvhaddpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvhaddpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvhaddpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvhaddpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvhaddpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvhsubpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvhsubpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvhsubpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvhsubpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvhsubpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvhsubpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvinsertf128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvinsertf128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvinsertf128comma;    i++;        presortedx86words[i].pname                 = dg_forthvinserti128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvinserti128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvinserti128comma;    i++;        presortedx86words[i].pname                 = dg_forthvinsertpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvinsertpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvinsertpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvlddqucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvlddqucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvlddqucomma;    i++;        presortedx86words[i].pname                 = dg_forthvldmxcsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvldmxcsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvldmxcsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaskmovdqucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaskmovdqucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaskmovdqucomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaskmovpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaskmovpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaskmovpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaskmovpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaskmovpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaskmovpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaxpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaxpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaxpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaxpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaxpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaxpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaxsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaxsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaxsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmaxsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmaxsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmaxsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvminpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvminpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvminpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvminpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvminpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvminpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvminsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvminsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvminsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvminsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvminsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvminsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovapdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovapdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovapdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovapscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovapscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovapscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovddupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovddupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovddupcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovdqacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovdqacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovdqacomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovdqucommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovdqucommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovdqucomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovhlpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovhlpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovhlpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovhpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovhpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovhpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovhpd2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovhpd2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovhpd2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovhpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovhpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovhpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovhps2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovhps2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovhps2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovlhpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovlhpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovlhpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovlpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovlpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovlpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovlpd2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovlpd2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovlpd2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovlpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovlpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovlpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovlps2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovlps2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovlps2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovmskpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovmskpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovmskpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovmskpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovmskpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovmskpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovntdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovntdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovntdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovntdqacommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovntdqacommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovntdqacomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovntpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovntpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovntpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovntpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovntpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovntpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovq2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovq2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovq2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovsd2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovsd2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovsd2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovshdupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovshdupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovshdupcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovsldupcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovsldupcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovsldupcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovss2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovss2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovss2comma;    i++;        presortedx86words[i].pname                 = dg_forthvmovupdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovupdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovupdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmovupscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmovupscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmovupscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmpsadbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmpsadbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmpsadbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmulpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmulpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmulpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmulpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmulpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmulpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvmulsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmulsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmulsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvmulsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvmulsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvmulsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvorpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvorpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvorpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvorpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvorpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvorpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvpabsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpabsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpabsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpabsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpabsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpabsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpabswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpabswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpabswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpackssdwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpackssdwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpackssdwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpacksswbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpacksswbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpacksswbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpackusdwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpackusdwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpackusdwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpackuswbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpackuswbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpackuswbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpaddbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpaddbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpaddbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpadddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpadddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpadddcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpaddqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpaddqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpaddqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpaddsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpaddsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpaddsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpaddswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpaddswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpaddswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpaddusbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpaddusbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpaddusbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpadduswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpadduswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpadduswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpaddwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpaddwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpaddwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpalignrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpalignrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpalignrcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpandcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpandcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpandcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpandncommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpandncommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpandncomma;    i++;        presortedx86words[i].pname                 = dg_forthvpavgbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpavgbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpavgbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpavgwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpavgwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpavgwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpblenddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpblenddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpblenddcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpblendvbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpblendvbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpblendvbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpblendwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpblendwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpblendwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpbroadcastbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpbroadcastbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpbroadcastbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpbroadcastdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpbroadcastdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpbroadcastdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpbroadcasti128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpbroadcasti128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpbroadcasti128comma;    i++;        presortedx86words[i].pname                 = dg_forthvpbroadcastqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpbroadcastqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpbroadcastqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpbroadcastwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpbroadcastwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpbroadcastwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpclmulqdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpclmulqdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpclmulqdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpeqbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpeqbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpeqbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpeqdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpeqdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpeqdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpeqqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpeqqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpeqqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpeqwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpeqwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpeqwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpestricommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpestricommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpestricomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpestrmcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpestrmcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpestrmcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpgtbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpgtbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpgtbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpgtdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpgtdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpgtdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpgtqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpgtqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpgtqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpgtwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpgtwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpgtwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpistricommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpistricommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpistricomma;    i++;        presortedx86words[i].pname                 = dg_forthvpcmpistrmcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpcmpistrmcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpcmpistrmcomma;    i++;        presortedx86words[i].pname                 = dg_forthvperm2f128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvperm2f128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvperm2f128comma;    i++;        presortedx86words[i].pname                 = dg_forthvperm2i128commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvperm2i128commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvperm2i128comma;    i++;        presortedx86words[i].pname                 = dg_forthvpermdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpermdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpermdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpermilpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpermilpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpermilpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpermilpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpermilpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpermilpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvpermpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpermpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpermpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpermpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpermpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpermpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvpermqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpermqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpermqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpextrbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpextrbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpextrbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpextrdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpextrdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpextrdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpextrqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpextrqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpextrqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpextrwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpextrwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpextrwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpextrw2commaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpextrw2commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpextrw2comma;    i++;        presortedx86words[i].pname                 = dg_forthvpgatherddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpgatherddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpgatherddcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpgatherdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpgatherdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpgatherdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpgatherqdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpgatherqdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpgatherqdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpgatherqqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpgatherqqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpgatherqqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphadddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphadddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphadddcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphaddswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphaddswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphaddswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphaddwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphaddwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphaddwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphminposuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphminposuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphminposuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphsubdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphsubdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphsubdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphsubswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphsubswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphsubswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvphsubwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvphsubwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvphsubwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpinsrbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpinsrbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpinsrbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpinsrdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpinsrdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpinsrdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpinsrqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpinsrqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpinsrqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpinsrwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpinsrwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpinsrwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaddubswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaddubswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaddubswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaddwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaddwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaddwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaskmovdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaskmovdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaskmovdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaskmovqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaskmovqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaskmovqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaxsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaxsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaxsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaxsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaxsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaxsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaxswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaxswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaxswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaxubcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaxubcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaxubcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaxudcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaxudcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaxudcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmaxuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmaxuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmaxuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpminsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpminsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpminsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpminsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpminsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpminsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpminswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpminswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpminswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpminubcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpminubcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpminubcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpminudcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpminudcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpminudcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpminuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpminuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpminuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovmskbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovmskbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovmskbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovsxbdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovsxbdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovsxbdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovsxbqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovsxbqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovsxbqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovsxbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovsxbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovsxbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovsxdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovsxdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovsxdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovsxwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovsxwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovsxwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovsxwqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovsxwqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovsxwqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovzxbdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovzxbdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovzxbdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovzxbqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovzxbqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovzxbqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovzxbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovzxbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovzxbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovzxdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovzxdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovzxdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovzxwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovzxwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovzxwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmovzxwqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmovzxwqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmovzxwqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmuldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmuldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmuldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmulhrswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmulhrswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmulhrswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmulhuwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmulhuwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmulhuwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmulhwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmulhwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmulhwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmulldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmulldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmulldcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmullwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmullwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmullwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpmuludqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpmuludqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpmuludqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvporcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvporcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvporcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsadbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsadbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsadbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpshufbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpshufbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpshufbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpshufdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpshufdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpshufdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpshufhwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpshufhwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpshufhwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpshuflwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpshuflwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpshuflwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsignbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsignbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsignbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsigndcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsigndcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsigndcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsignwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsignwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsignwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpslldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpslldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpslldcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpslldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpslldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpslldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsllqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsllqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsllqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsllvdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsllvdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsllvdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsllvqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsllvqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsllvqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsllwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsllwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsllwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsradcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsradcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsradcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsravdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsravdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsravdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrawcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrawcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrawcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrldcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrldcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrldcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrlqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrlqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrlqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrlvdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrlvdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrlvdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrlvqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrlvqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrlvqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsrlwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsrlwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsrlwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubsbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubsbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubsbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubusbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubusbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubusbcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubuswcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubuswcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubuswcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpsubwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpsubwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpsubwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvptestcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvptestcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvptestcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpckhbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpckhbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpckhbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpckhdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpckhdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpckhdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpckhqdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpckhqdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpckhqdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpckhwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpckhwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpckhwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpcklbwcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpcklbwcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpcklbwcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpckldqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpckldqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpckldqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpcklqdqcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpcklqdqcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpcklqdqcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpunpcklwdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpunpcklwdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpunpcklwdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvpxorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvpxorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvpxorcomma;    i++;        presortedx86words[i].pname                 = dg_forthvrcppscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvrcppscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvrcppscomma;    i++;        presortedx86words[i].pname                 = dg_forthvrcpsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvrcpsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvrcpsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvroundpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvroundpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvroundpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvroundpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvroundpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvroundpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvroundsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvroundsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvroundsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvroundsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvroundsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvroundsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvrsqrtpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvrsqrtpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvrsqrtpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvrsqrtsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvrsqrtsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvrsqrtsscomma;    i++;        presortedx86words[i].pname                 = dg_ccvsname;    presortedx86words[i].namelength            = sizeof(dg_ccvsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ccvs;    i++;        presortedx86words[i].pname                 = dg_forthvshufpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvshufpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvshufpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvshufpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvshufpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvshufpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvsqrtpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsqrtpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsqrtpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvsqrtpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsqrtpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsqrtpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvsqrtsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsqrtsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsqrtsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvsqrtsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsqrtsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsqrtsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvstmxcsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvstmxcsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvstmxcsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthvsubpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsubpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsubpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvsubpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsubpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsubpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvsubsdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsubsdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsubsdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvsubsscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvsubsscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvsubsscomma;    i++;        presortedx86words[i].pname                 = dg_forthvtestpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvtestpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvtestpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvtestpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvtestpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvtestpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvucomisdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvucomisdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvucomisdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvucomisscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvucomisscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvucomisscomma;    i++;        presortedx86words[i].pname                 = dg_forthvunpckhpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvunpckhpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvunpckhpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvunpckhpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvunpckhpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvunpckhpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvunpcklpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvunpcklpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvunpcklpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvunpcklpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvunpcklpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvunpcklpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvxorpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvxorpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvxorpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthvxorpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvxorpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvxorpscomma;    i++;        presortedx86words[i].pname                 = dg_forthvzeroallcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvzeroallcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvzeroallcomma;    i++;        presortedx86words[i].pname                 = dg_forthvzerouppercommaname;    presortedx86words[i].namelength            = sizeof(dg_forthvzerouppercommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthvzerouppercomma;    i++;        presortedx86words[i].pname                 = dg_forthwaitcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthwaitcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthwaitcomma;    i++;        presortedx86words[i].pname                 = dg_forthwbinvdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthwbinvdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthwbinvdcomma;    i++;        presortedx86words[i].pname                 = dg_forthwhilecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthwhilecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthwhilecomma;    i++;        presortedx86words[i].pname                 = dg_forthwrfsbasecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthwrfsbasecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthwrfsbasecomma;    i++;        presortedx86words[i].pname                 = dg_forthwrgsbasecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthwrgsbasecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthwrgsbasecomma;    i++;        presortedx86words[i].pname                 = dg_forthwrmsrcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthwrmsrcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthwrmsrcomma;    i++;        presortedx86words[i].pname                 = dg_forthxabortcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxabortcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxabortcomma;    i++;        presortedx86words[i].pname                 = dg_forthxacquirecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxacquirecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxacquirecomma;    i++;        presortedx86words[i].pname                 = dg_forthxaddcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxaddcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxaddcomma;    i++;        presortedx86words[i].pname                 = dg_forthxbeginbranchcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxbeginbranchcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxbeginbranchcomma;    i++;        presortedx86words[i].pname                 = dg_forthxbeginn16commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxbeginn16commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxbeginn16comma;    i++;        presortedx86words[i].pname                 = dg_forthxbeginn32commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxbeginn32commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxbeginn32comma;    i++;        presortedx86words[i].pname                 = dg_forthxchgcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxchgcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxchgcomma;    i++;        presortedx86words[i].pname                 = dg_forthxendcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxendcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxendcomma;    i++;        presortedx86words[i].pname                 = dg_forthxgetbvcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxgetbvcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxgetbvcomma;    i++;        presortedx86words[i].pname                 = dg_forthxlatbcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxlatbcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxlatbcomma;    i++;        presortedx86words[i].pname                 = dg_xmm0name;    presortedx86words[i].namelength            = sizeof(dg_xmm0name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm0;    i++;        presortedx86words[i].pname                 = dg_xmm1name;    presortedx86words[i].namelength            = sizeof(dg_xmm1name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm1;    i++;        presortedx86words[i].pname                 = dg_xmm10name;    presortedx86words[i].namelength            = sizeof(dg_xmm10name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm10;    i++;        presortedx86words[i].pname                 = dg_xmm11name;    presortedx86words[i].namelength            = sizeof(dg_xmm11name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm11;    i++;        presortedx86words[i].pname                 = dg_xmm12name;    presortedx86words[i].namelength            = sizeof(dg_xmm12name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm12;    i++;        presortedx86words[i].pname                 = dg_xmm13name;    presortedx86words[i].namelength            = sizeof(dg_xmm13name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm13;    i++;        presortedx86words[i].pname                 = dg_xmm14name;    presortedx86words[i].namelength            = sizeof(dg_xmm14name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm14;    i++;        presortedx86words[i].pname                 = dg_xmm15name;    presortedx86words[i].namelength            = sizeof(dg_xmm15name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm15;    i++;        presortedx86words[i].pname                 = dg_xmm2name;    presortedx86words[i].namelength            = sizeof(dg_xmm2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm2;    i++;        presortedx86words[i].pname                 = dg_xmm3name;    presortedx86words[i].namelength            = sizeof(dg_xmm3name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm3;    i++;        presortedx86words[i].pname                 = dg_xmm4name;    presortedx86words[i].namelength            = sizeof(dg_xmm4name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm4;    i++;        presortedx86words[i].pname                 = dg_xmm5name;    presortedx86words[i].namelength            = sizeof(dg_xmm5name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm5;    i++;        presortedx86words[i].pname                 = dg_xmm6name;    presortedx86words[i].namelength            = sizeof(dg_xmm6name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm6;    i++;        presortedx86words[i].pname                 = dg_xmm7name;    presortedx86words[i].namelength            = sizeof(dg_xmm7name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm7;    i++;        presortedx86words[i].pname                 = dg_xmm8name;    presortedx86words[i].namelength            = sizeof(dg_xmm8name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm8;    i++;        presortedx86words[i].pname                 = dg_xmm9name;    presortedx86words[i].namelength            = sizeof(dg_xmm9name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_xmm9;    i++;        presortedx86words[i].pname                 = dg_isxmmregname;    presortedx86words[i].namelength            = sizeof(dg_isxmmregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isxmmreg;    i++;        presortedx86words[i].pname                 = dg_forthxorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxorcomma;    i++;        presortedx86words[i].pname                 = dg_forthxorpdcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxorpdcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxorpdcomma;    i++;        presortedx86words[i].pname                 = dg_forthxorpscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxorpscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxorpscomma;    i++;        presortedx86words[i].pname                 = dg_forthxreleasecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxreleasecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxreleasecomma;    i++;        presortedx86words[i].pname                 = dg_forthxrstorcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxrstorcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxrstorcomma;    i++;        presortedx86words[i].pname                 = dg_forthxrstor64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxrstor64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxrstor64comma;    i++;        presortedx86words[i].pname                 = dg_forthxrstorscommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxrstorscommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxrstorscomma;    i++;        presortedx86words[i].pname                 = dg_forthxrstors64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxrstors64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxrstors64comma;    i++;        presortedx86words[i].pname                 = dg_forthxsavecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsavecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsavecomma;    i++;        presortedx86words[i].pname                 = dg_forthxsave64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsave64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsave64comma;    i++;        presortedx86words[i].pname                 = dg_forthxsaveccommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsaveccommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsaveccomma;    i++;        presortedx86words[i].pname                 = dg_forthxsavec64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsavec64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsavec64comma;    i++;        presortedx86words[i].pname                 = dg_forthxsaveoptcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsaveoptcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsaveoptcomma;    i++;        presortedx86words[i].pname                 = dg_forthxsaveopt64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsaveopt64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsaveopt64comma;    i++;        presortedx86words[i].pname                 = dg_forthxsavescommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsavescommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsavescomma;    i++;        presortedx86words[i].pname                 = dg_forthxsaves64commaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsaves64commaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsaves64comma;    i++;        presortedx86words[i].pname                 = dg_forthxsetbvcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxsetbvcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxsetbvcomma;    i++;        presortedx86words[i].pname                 = dg_forthxtestcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthxtestcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxtestcomma;    i++;        presortedx86words[i].pname                 = dg_ymm0name;    presortedx86words[i].namelength            = sizeof(dg_ymm0name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm0;    i++;        presortedx86words[i].pname                 = dg_ymm1name;    presortedx86words[i].namelength            = sizeof(dg_ymm1name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm1;    i++;        presortedx86words[i].pname                 = dg_ymm10name;    presortedx86words[i].namelength            = sizeof(dg_ymm10name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm10;    i++;        presortedx86words[i].pname                 = dg_ymm11name;    presortedx86words[i].namelength            = sizeof(dg_ymm11name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm11;    i++;        presortedx86words[i].pname                 = dg_ymm12name;    presortedx86words[i].namelength            = sizeof(dg_ymm12name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm12;    i++;        presortedx86words[i].pname                 = dg_ymm13name;    presortedx86words[i].namelength            = sizeof(dg_ymm13name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm13;    i++;        presortedx86words[i].pname                 = dg_ymm14name;    presortedx86words[i].namelength            = sizeof(dg_ymm14name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm14;    i++;        presortedx86words[i].pname                 = dg_ymm15name;    presortedx86words[i].namelength            = sizeof(dg_ymm15name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm15;    i++;        presortedx86words[i].pname                 = dg_ymm2name;    presortedx86words[i].namelength            = sizeof(dg_ymm2name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm2;    i++;        presortedx86words[i].pname                 = dg_ymm3name;    presortedx86words[i].namelength            = sizeof(dg_ymm3name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm3;    i++;        presortedx86words[i].pname                 = dg_ymm4name;    presortedx86words[i].namelength            = sizeof(dg_ymm4name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm4;    i++;        presortedx86words[i].pname                 = dg_ymm5name;    presortedx86words[i].namelength            = sizeof(dg_ymm5name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm5;    i++;        presortedx86words[i].pname                 = dg_ymm6name;    presortedx86words[i].namelength            = sizeof(dg_ymm6name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm6;    i++;        presortedx86words[i].pname                 = dg_ymm7name;    presortedx86words[i].namelength            = sizeof(dg_ymm7name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm7;    i++;        presortedx86words[i].pname                 = dg_ymm8name;    presortedx86words[i].namelength            = sizeof(dg_ymm8name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm8;    i++;        presortedx86words[i].pname                 = dg_ymm9name;    presortedx86words[i].namelength            = sizeof(dg_ymm9name);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_ymm9;    i++;        presortedx86words[i].pname                 = dg_isymmregname;    presortedx86words[i].namelength            = sizeof(dg_isymmregname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isymmreg;    i++;        presortedx86words[i].pname                 = dg_cczsname;    presortedx86words[i].namelength            = sizeof(dg_cczsname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_cczs;    i++;        presortedx86words[i].pname                 = dg_forthloopnecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthloopnecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthloopnzcomma;    i++;        presortedx86words[i].pname                 = dg_forthzsorloopwhilecommaname;    presortedx86words[i].namelength            = sizeof(dg_forthzsorloopwhilecommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthzsorloopwhilecomma;    i++;        presortedx86words[i].pname                 = dg_forthzsuntilrepcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthzsuntilrepcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthrepnecomma;    i++;        presortedx86words[i].pname                 = dg_usealteastmodmname;    presortedx86words[i].namelength            = sizeof(dg_usealteastmodmname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isbasedisplacement;    i++;    // 210    presortedx86words[i].pname                 = dg_forthbracketdname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketdname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketd;    i++;        presortedx86words[i].pname                 = dg_isbracketccbufferoffsetname;    presortedx86words[i].namelength            = sizeof(dg_isbracketccbufferoffsetname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_iscurrentcompilebufferoffset;    i++;        presortedx86words[i].pname                 = dg_forthbracketopopcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketopopcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketopopcomma;    i++;        presortedx86words[i].pname                 = dg_forthbracketopushcommaname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketopushcommaname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketopushcomma;    i++;        presortedx86words[i].pname                 = dg_forthbracketrplusdname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketrplusdname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketrplusd;    i++;        presortedx86words[i].pname                 = dg_forthbracketrpsxrpdname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketrpsxrpdname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketrpsxrpd;    i++;        presortedx86words[i].pname                 = dg_forthbracketrpsxymmrpnname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketrpsxymmrpnname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketrpsxymmrpn;    i++;        presortedx86words[i].pname                 = dg_forthbracketrbxplusaltoalname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketrbxplusaltoalname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthxlatbcomma;    i++;        presortedx86words[i].pname                 = dg_forthbracketrname;    presortedx86words[i].namelength            = sizeof(dg_forthbracketrname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypesafesubroutine;    presortedx86words[i].databuf               = DG_CORE_BUFFERID;    presortedx86words[i].dataoffset            = (UINT64)&dg_forthbracketr;    i++;        presortedx86words[i].pname                 = dg_usealteastsibname;    presortedx86words[i].namelength            = sizeof(dg_usealteastsibname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isbasescaleindexdisplacement;    i++;        presortedx86words[i].pname                 = dg_isvsibname;    presortedx86words[i].namelength            = sizeof(dg_isvsibname);    presortedx86words[i].compileroutinebuf     = DG_CORE_BUFFERID;    presortedx86words[i].compileroutineoffset  = (UINT64)&dg_forthdocompiletypedpushn;    presortedx86words[i].databuf               = 0;    presortedx86words[i].dataoffset            = (UINT64)dg_isbasescalevindexdisplacement;    i++;            if (i != dg_presortedx86wordlistsize)    {        // if i was > then buffer was overflowed, this leads to all sort of          // strange behavior, like changing environ on freebsd and messing          // up environment variables        Bufferhandle myBHarrayhead;        dg_initpbharrayhead(&myBHarrayhead);        dg_printzerostring(&myBHarrayhead, (unsigned char*)"\nwrong number of premade words in list, expected ");        dg_writestdoutuinttodec(&myBHarrayhead, dg_presortedx86wordlistsize);        dg_printzerostring(&myBHarrayhead, (unsigned char*)" got ");        dg_writestdoutuinttodec(&myBHarrayhead, i);        dg_printzerostring(&myBHarrayhead, (unsigned char*)"\n");        return ((Premadeword*)badbufferhandle);    }        return ((Premadeword*)&(presortedx86words[0]));}const char* dg_initcpux86wordlistname = "dg_initcpux86wordlist";void dg_initcpux86wordlist (Bufferhandle* pBHarrayhead){    UINT64 definition;    UINT64 corewordlistid;        UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        corewordlistid = dg_getbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_corewordlistid);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_initcpux86wordlistname);        return;    }    // compiling words need to be of compile type safe subroutine...    definition = dg_new0stringnamecoreword(        pBHarrayhead,         (UINT64)(&dg_forthdocompiletypesubroutine),        (UINT64)(&dg_forthx86wordlist),        (unsigned char*)dg_forthx86wordlistname);    dg_linkdefinition(pBHarrayhead, corewordlistid, definition);        definition = dg_new0stringnamecoreword(        pBHarrayhead,         (UINT64)(&dg_forthdocompiletypesafesubroutine),        (UINT64)(&dg_forthcompilealignretforn),        (unsigned char*)dg_forthcompilealignretfornname);    dg_linkdefinition(pBHarrayhead, corewordlistid, definition);        definition = dg_new0stringnamecoreword(        pBHarrayhead,         (UINT64)(&dg_forthdocompiletypesafesubroutine),        (UINT64)(&dg_forthcompilealignretfornpf),        (unsigned char*)dg_forthcompilealignretfornpfname);    dg_linkdefinition(pBHarrayhead, corewordlistid, definition);        definition = dg_new0stringnamecoreword(        pBHarrayhead,         (UINT64)(&dg_forthdocompiletypesafesubroutine),        (UINT64)(&dg_forthotormovcomma),        (unsigned char*)dg_forthotormovcommaname);    dg_linkdefinition(pBHarrayhead, corewordlistid, definition);        definition = dg_new0stringnamecoreword(        pBHarrayhead,         (UINT64)(&dg_forthdocompiletypesafesubroutine),        (UINT64)(&dg_forthbracketotormovcomma),        (unsigned char*)dg_forthbracketotormovcommaname);    dg_linkdefinition(pBHarrayhead, corewordlistid, definition);}// MOV  // SR16->M16          8C M/SR  // SR16<-M16          8E M/SR  // M8[seg:off]->AL    A0  // M32[seg:off]->EAX  A1  // M8[seg:off]<-AL    A2  // M32[seg:off]<-EAX  A3    // parameters... would like named parameters.. saved on locals wordlist//  and also local return variables....//  both esp and ebp relative...//  doing esp relative would require automatic tracking of stuff compiled to push//  pop the return stack...//  and what if there are multiple paths with pushes and pops to the return stack?//  be very difficult to track...// to use labels pointing to same buffer...//  need to convert offset bufferid to pc+displacement//  check to make sure target buffer is actually same as current compile buffer//  need target offset, after instruction offset, instruction displacement offset,//   and displacement size (calculated actually but will either be byte or dword)// making displacement always dword would simplify it//  figuring out displacement before compiling instruction would be nice but that//  means you would need to know how long the instruction is ahead of time... and//  with promotions... (for immediate value instructions) the instruction size can//  change... // dealing with two target size....//  n to n ... error so don't care//  n to r ... use size of r//  n to m ... if not specified... set size to dword?//  r to m or m to r... use size of r/////////////////////////////////// ARPL  01100011 modr/m// MOV  // SR16->M16 8C M/SR  // SR16<-M16 8E M/SR  // M8[seg:off]->AL    A0  // M32[seg:off]->EAX  A1  // M8[seg:off]<-AL    A2  // M32[seg:off]<-EAX  A3// SGDT   M48   0F 01 M/0  (target can not be reg)// SIDT   M48   0F 01 M/1  (target can not be reg)// SLDT   M32   0F 00 M/0  // SMSW   M32   0F 01 M/4// STR    M16   0F 00 M/1// IN//  P[nn]->AL   E4 nn//  P[nn]->EAX  E5 nn//  P[DX]->AL   EC//  P[EDX]->EAX ED// OUT//  P[nn]<-AL   E6 nn//  P[nn]<-EAX  E7 nn//  P[DX]<-AL   EE//  P[EDX]<-EAX EF// MOVBE//  M32->R32  0F 38 F0 M/R  ( BSWAPM32->R32 )//  M32<-R32  0F 38 F1 M/R  (M32<-BSWAPR32)// POP//  DS   1F//  ES   07//  SS   17//  FS   0FA1//  GS   0FA9// PUSH//  0E   CS//  16   SS//  1E   DS//  06   ES//  0F A0  FS//  0F A8  GS// CFLUSH  0F AE M/7 (byte)// CMPXCHG8B  0F C7 M/1 nnnnnnnn nnnnnnnn// CRC32 is next// LFENCE 0F AE M/5// MFENCE 0F AE M/6// POPCNT//  M32->R32  F3 0F B8 M/R// NOPM//  0F 1F M32/0 (does not actually access memory)// CALL  //  [EIP+O]  E8 nnnnnnnn       compileon32//  M32orR32 FF M/2 // dg_compilenparam ( n destreg )//  N destreg MOV,  ( destreg is a reg )//  N PUSH,         ( destreg is -1 and N fits in 32 bit signed integer )//  N RAX MOV, RAX PUSH, ( destreg is -1 and N fits in 64 bit signed integer )//   ( can I do two 32 bit pushes? I think you have to keep stack aligned...//      so you'd have to disable interrupts or something )// dg_compilebracketnparam ( n destreg )//   ( since 64 bit absolute addresses are not supported in 64 bit mode )//  N RAX MOV, RAX [R] destreg -> MOV, ( destreg is a reg )//  N RAX MOV, RAX [R] PUSH, ( destreg is -1 )////  n -> destreg//  [destreg] -> destreg//  //  push rax//  n -> rax//  [rax] -> rax//  [rsp] <-> rax//  // dg_compileoparam//  O destreg LEA, ( destreg is reg )//  O PUSH, ( destreg is -1 )//   or O RAX LEA, RAX PUSH, //   or CALL HERE offset RSP [R] ADD,//// dg_compilebracketoparam//  [O] destreg MOV, ( destreg is reg )//  [O] PUSH, ( destreg is -1 )//// dg_compilelparam//   RBP [R+N] destreg LEA, ( destreg is reg )//   RBP [R+N] RAX LEA, RAX PUSH, ( destreg is -1 )//// dg_compilebracketlparam//   RBP [R+N] destreg MOV, ( destreg is reg )//   RBP [R+N] PUSH, ( destreg is -1 )//// dg_compilerparam//  ( make sure source is a reg id )//  destreg MOV, ( destreg is a reg )//  PUSH, ( destreg is -1 )//// dg_compilebracketrparam//  ( make sure source is a reg id )//  [R] destreg MOV, ( destreg is a reg )//  [R] PUSH, ( destreg is -1 )//const char dg_forthccallcommacurlyname[] = "CCALL,<";void dg_forthccallcommacurly (Bufferhandle* pBHarrayhead){    UINT64 olderrorcount = dg_geterrorcount(pBHarrayhead);        if (baderrorcount == olderrorcount)    {        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcparameters,        0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthccallcommacurlyname);        return;    }        dg_putbufferuint64(        pBHarrayhead,        DG_DATASPACE_BUFFERID,        dg_numberofcfparameters,        0);        if (dg_geterrorcount(pBHarrayhead) != olderrorcount)    {        dg_pusherror(pBHarrayhead, dg_forthccallcommacurlyname);        return;    }        // push call,< wordlist to search order stack }// CALL,<  -- not sure on name//  set cintparams to 0//  set cfparams to 0//  push the call< wordlist to the search order// N P F// [P]           same as [PU64]// [PU8]  [PU16] [PU32]  [PU64] [PU128]// [PS8]  [PS16] [PS32]  [PS64] [PS128]// [PF32] [PF64] [PF128]// [L]// ()//// end > for CALL,<//  state before function//   pop value mode pairs to return value stack//  state popping function//   pop address funtionmode to address functionmode temp variable//  state popping params//   pop value floatingpointmode pairs to float param stack//   pop value intmode pairs to int param stack//  state compiling params//   compile loading each float param//   compile loading each int param//   compile function call//   compile storing each return value//