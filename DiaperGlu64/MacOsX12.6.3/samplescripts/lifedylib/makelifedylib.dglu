( //////////////////////////////////////////////////////////////////////////////////////// )
( //                                                                                       )
( //    Copyright 2020 James Patrick Norris                                                )
( //                                                                                       )
( //    This file is part of LifeLib 1.2.                                                  )
( //                                                                                       )
( //    LifeLib 1.2 is free software; you can redistribute it and/or modify                )
( //    it under the terms of the GNU General Public License as published by               )
( //    the Free Software Foundation; either version 2 of the License, or                  )
( //    {at your option} any later version.                                                )
( //                                                                                       )
( //    LifeLib 1.2 is distributed in the hope that it will be useful,                     )
( //    but WITHOUT ANY WARRANTY; without even the implied warranty of                     )
( //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      )
( //    GNU General Public License for more details.                                       )
( //                                                                                       )
( //    You should have received a copy of the GNU General Public License                  )
( //    along with LifeLib 1.2; if not, write to the Free Software                         )
( //    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          )
( //                                                                                       )
( //////////////////////////////////////////////////////////////////////////////////////// )

( /////////////////////////////// )
( // James Patrick Norris      // )
( // www.rainbarrel.com        // )
( // thaine@mail87.pair.com    // )
( // May 15, 2022              // )
( // version 1.2               // )
( /////////////////////////////// )


// for generating add table
HEX 1000 1000 NEWBUFFER GETSBUFFER DROP CONSTANT PTHISNEIGHBORSBUF
HEX 1000 1000 NEWBUFFER GETSBUFFER DROP CONSTANT PNEXTNEIGHBORSBUF
HEX 1000 1000 NEWBUFFER GETSBUFFER DROP CONSTANT PCELLSBUF

PCURRENTCOMPILEBUFFER @ CONSTANT OLDCOMPILEBUFID


// make new empty compile buffer

HEX 10000 -1 NEWBUFFER CONSTANT LIFECOMPILEBUFID 
LIFECOMPILEBUFID PCURRENTCOMPILEBUFFER ! 

// making a new nglu list and making it the current elementid hlistid

NEW-NGLULIST>EH


// adding a symbol list to the current nglu list

$" lifesymbols" NGLU-SYMBOLS >NEW$ EH-NEW-ELEMENT>EH


// adding the assembler to the search order

X86-WORDLIST >SEARCH-ORDER


// ////////////////////////////////////////////
//  Calculating overlap of two line segments //
// ////////////////////////////////////////////


// A ---------
// B    ---------
//
// A ---------
// B    ---
//
// A    ---------
// B --------
// 
// A    ---
// B ---------
// 
// A ----
// B       ------
//
// I think that's all the cases
//
// assuming wraparound past 0 of line segments is ok
( ASX AL BSX BL -- OVERLAPSX OVERLAPL )
// calculate AEX, BEX
//  AEX = ASX + AL
//  BEX = BSX + BL

// calculate distance between start points
//  DL = BSX - ASX ( signed, unsigned does not matter, 
//  same calculation, however DL is unsigned )

// Case 1: B starts in A
//  if DL <= AL, then OVERLAPSX = BSX 
//   and OVERLAPL = smaller of  (AL - DL) or BL

// Case 2: A starts in B
//  if (0 - DL) <= BL, then OVERLAPSX = ASX 
//   and OVERLAP = smaller of  BL - (0 - DL) or AL

// Case 3: They don't overlap
//  if neither of the above, then they don't overlap so...
//  OVERLAPSX = ASX (actually don't care) and OVERLAPL = 0

HEX
OSYMBOL dg_getoverlapsegment
  ( ASX AL BSX BL pOVERLAPSX -ret- )
  ( -regs- EAX=OVERLAPL EDX=OVERLAPSX )

  // BL             RCX  
  // BSX            RDX
  // AL             RSI
  // ASX            RDI
  // ret            [RBP+8]
  // saved RBP      [RBP+0]
  RBP PUSH,
  RSP RBP MOV,

  RDX  RAX  MOV,  
  RDI  RAX  SUB,  // RAX now holds DL = BSX - ASX
  
  // checking case one, 
  // if BSX - ASX <= AL then b starts in a 
  RSI RAX  CMP,  // comparing (BSX - ASX) with AL
  ULE IF,
    // OVERLAPSX = BSX

    // OVERLAPL = smaller of BL or (ASX + AL) - BSX
    //   (ASX + AL) - BSX = (ASX - BSX) + AL = AL - (BSX - ASX)
    RSI RAX  SUB,  // RAX now holds (BSX - ASX) - AL
    RAX NEG, // RAX now holds AL - (BSX - ASX)
    RCX  RAX  CMP,  
    UGT IF,
      RCX  RAX  MOV,
    THEN,
    
    RBP POP,
    RET,
  THEN,

  // checking case two, 
  // if ASX - BSX <= BL then a starts in b
  RAX NEG,
  RCX RAX  CMP,  // ASX - BSX <= BL
  ULE IF,
    // OVERLAPSX = EAX
    RDI RDX  MOV,

    // OVERLAPL = smaller of (ASX - BSX) - BL or AL
    RCX RAX  SUB,  
    RAX NEG,                  
    RSI RAX  CMP,  
    UGT IF,
      RSI RAX  MOV,
    THEN,
    
    RBP POP,
    RET,
  THEN,

  // case 3, no overlap
  // OVERLAPSX = EAX
  RDI RDX  MOV,

  // OVERLAPL = 0
  RAX  RAX  XOR,
  
  RBP POP,
  RET,

HEX

// to align buffer to make CalcNeighborsForRowFast additions faster
//  really only need to align to nearest 8..
LIFECOMPILEBUFID LENGTHBUF DUP 10 ROUNDUP SWAP - LIFECOMPILEBUFID GROWBUFFER
OSYMBOL dg_thisneighborsaddtbl 1000 CODE-ALLOT
OSYMBOL dg_nextneighborsaddtbl 1000 CODE-ALLOT

// assumes little endian
// This isn't not much faster than the other dg_calcNeighbors routine
HEX
OSYMBOL dg_calcNeighborsForRowFast 
  ( prowbits                RDI
    pthisrownneighbors      RSI
    pnextrownneighbors      RDX
    qwordsperrowofneighbors RCX
    pthisrownneighborsend   R8
    pnextrownneighborsend   R9 -ret- )

  RBP PUSH,
  RSP RBP MOV,

  RDI PUSH,  // [RBP - 0x08]
  RSI PUSH,  // [RBP - 0x10]
  RDX PUSH,  // [RBP - 0x18]
  RCX PUSH,  // [RBP - 0x20]
  R8 PUSH,   // [RBP - 0x28]
  R9 PUSH,   // [RBP - 0x30]

  EH-NAMEW>VALUE dg_thisneighborsaddtbl [O] R8 LEA,
  // dg_nextneighborsaddtbl at dg_thisneighborsaddtbl + 0x1000

  RCX R9 MOV,

  BEGIN,
    RDI [R]  RAX  MOV,
    8 N RDI ADD,

    RAX RAX AND,
    NE IF,

      RCX RCX XOR,
      AL CL -> MOV,
      4 N RCX SHL, // RCX now has index into the lookup tables

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI [R] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 8 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX [R] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 8 [R+N] -> ADD,  


      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 8 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 10 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 8 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 10 [R+N] -> ADD,  


      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 10 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 18 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 10 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 18 [R+N] -> ADD,  


      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 18 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 20 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 18 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 20 [R+N] -> ADD,  


      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 20 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 28 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 20 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 28 [R+N] -> ADD,  


      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 28 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 30 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 28 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 30 [R+N] -> ADD,  

    
      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 30 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 38 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 30 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 38 [R+N] -> ADD,  


      8 N  RAX  SHR,
      RCX RCX XOR,
      AL CL MOV,
      4 N RCX SHL, 

      R8 SCALE1* RCX 0 [R+S*R+N] -> R10 MOV,
      R10 RSI 38 [R+N] -> ADD,
      R8 SCALE1* RCX 8 [R+S*R+N] -> R10 MOV,
      R10W RSI 40 [R+N] -> ADD,  

      R8 SCALE1* RCX 1000 [R+S*R+N] -> R10 MOV,
      R10 RDX 38 [R+N] -> ADD,
      R8 SCALE1* RCX 1008 [R+S*R+N] -> R10 MOV,
      R10W RDX 40 [R+N] -> ADD, 

    THEN,

    40 N RSI ADD,
    40 N RDX ADD,

    R9 DEC,

  EQ UNTIL, 

  // wrap around calculation
  RBP -30 [R+N]  RSI  MOV,    // stopaddressnext
  RSI 1 [R+N]  AL  MOV,       //               
  RBP -10 [R+N]  RSI  MOV,    // pThisRowsNeighbors   
  AL  RSI 1 [R+N]  ADD,       //                
  RBP -18 [R+N]  RSI  MOV,    // pNextRowsNeighbors    
  AL  RSI 1 [R+N]  ADD,       // 

  RSI [R]  AL  MOV,           // 
  RBP -28 [R+N]  RSI  MOV,    // stopaddressthis
  AL  RSI [R]  ADD,           // 
  RBP -30 [R+N]  RSI  MOV,    // stopaddressnext
  AL  RSI [R]  ADD,           // 

  RBP RSP MOV,
  RBP POP,
  RET,



// assumes little endian
HEX
OSYMBOL dg_calcNeighborsForRow 
  ( prowbits                 RDI
    pthisrownneighbors       RSI
    pnextrownneighbors       RDX
    dwordsperrowofneighbors  RCX
    pthisrownneighborsend    R8
    pnextrownneighborsend    R9  -ret- )

  RBP PUSH,
  RSP RBP MOV,

  RDI PUSH, 
  RSI PUSH, 
  RDX PUSH, 
  RCX PUSH, 
  R8 PUSH,  
  R9 PUSH,  

  RDI RDX XCHG,  

  BEGIN,                       
    RDX [R]  EAX  MOV,           
    EAX BSWAP,                   
    4 N  RDX  ADD,               
    0 N  EAX  CMP,               

    EQ IF,                       

      20 N  RSI  ADD,              
      20 N  RDI  ADD,              
                 
      ELSE,	                                 				
                                    
        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,

        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

        1 N  EAX  ROL,              
        CS IF,                      
          020102 N  RSI [R]  32BIT  ADD,
          020202 N  RDI [R]  32BIT  ADD,
        THEN,                       
        RSI INC,                    
        RDI INC,                    

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

          1 N  EAX  ROL,              // rol eax,1
          CS IF,                      // jnc then1
            020102 N  RSI [R]  32BIT  ADD,
            020202 N  RDI [R]  32BIT  ADD,
          THEN,                       // then1:
          RSI INC,                    // add rsi,1
          RDI INC,                    // add rdi,1

       THEN,

       RCX DEC,
    ZS UNTIL,

    // wrap around calculation
    RBP -30 [R+N]  RSI  MOV,    // stopaddressnext
    RSI 1 [R+N]  AL  MOV,                    
    RBP -10 [R+N]  RSI  MOV,    // pThisRowsNeighbors   
    AL  RSI 1 [R+N]  ADD,                      
    RBP -18 [R+N]  RSI  MOV,    // pNextRowsNeighbors    
    AL  RSI 1 [R+N]  ADD,      

    RSI [R]  AL  MOV,          
    RBP -28 [R+N]  RSI  MOV,     // stopaddressthis
    AL  RSI [R]  ADD,          
    RBP -30 [R+N]  RSI  MOV,     // stopaddressnext
    AL  RSI [R]  ADD,          
   
  RBP RSP MOV,
  RBP POP,
  RET,



HEX
OSYMBOL dg_updateCellsForRow 
  ( prowbits                //  RDI
    ppreviousrownneighbors  //  RSI
    pnextrownneighbors      //  RDX
    dwordsperrowofcells     //  RCX
    logicfunction           //  R8  -ret- )

  RBX PUSH,
  RBP PUSH,
  RSP RBP MOV,


  RDI  RDX  XCHG,   
  RSI  INC,                 
  RDI  INC,                
  RBX  RBX  XOR,

  R8 RCX XCHG,

  BEGIN,                    

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,         // bl should be < 18...
    RSI INC,                  
    RDI INC,                  
    EBX  ECX  BT,  // could this be BL CL BT, ?
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                  
    RDI INC,                  
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL,

    RSI [R]  BL  MOV,        
    RDI [R]  BL  ADD,        // bl should be < 18...
    RSI INC,                 
    RDI INC,                 
    EBX  ECX  BT,  
    1 N  EAX  RCL, 

    EAX  BSWAP,                 
    EAX  RDX [R]  MOV,          
    4 N  RDX  ADD,             

    R8 DEC,
  ZS UNTIL,
	
  RBP RSP MOV,
  RBP  POP, 
  RBX  POP,
  RET,


OSYMBOL dg_clearNeighbors 
( ppreviousrownneighbors    //  RDI
  pthisneighborsbuffer      //  RSI
  pnextrownneighbors        //  RDX
  qwordsperrowofneighbors   //  RCX
  ptoprowneighbors -ret- )  //  R8

  RBP PUSH,
  RSP RBP MOV,

  PUSHFD,        // -0x08
  CLD,
  RCX PUSH,      // -0x10

  RAX RAX XOR,

  REP, STOSQ,

  RSI  RDI            MOV,
  RBP  -10 [R+N] RCX  MOV,
  REP, STOSQ,

  RDX  RDI  MOV,
  RBP  -10 [R+N] RCX  MOV,
  REP, STOSQ,

  R8   RDI  MOV,
  RBP  -10 [R+N] RCX  MOV,
  REP, STOSQ,
  
  RCX POP,
  POPFD,
  RBP  POP,
  RET,


OSYMBOL dg_copyNeighbors 
( ppreviousrownneighbors    //  RDI
  pthisneighborsbuffer      //  RSI
  pnextrownneighbors        //  RDX
  qwordsperrowofneighbors)  //  RCX
  RBP PUSH,
  RSP RBP MOV,

  PUSHFD,
  CLD,

  RCX PUSH,                 // -0x10
  RSI PUSH,                 // -0x18

  REP, MOVSQ,

  RDX            RSI  MOV,  // src  = pnext
  RBP -18 [R+N]  RDI  MOV,  // dest = pthis
  RBP -10 [R+N]  RCX  MOV,  // cnt = rowsizeinqwords
  REP, MOVSQ,

  RDX             RDI  MOV, // dest = pnext
  RBP -10 [R+N]   RCX  MOV, // cnt  = rowsizeinqwords
  RAX RAX XOR,              // src = 0
  REP, STOSQ,
  
  RBP -8 [R+N]  RSP  LEA,
  POPFD,
  RBP  POP,
  RET,


OSYMBOL dg_moveQwords 
( pdest           RDI       
  psrc            RSI      
  lengthinqwords  RDX  -ret- )  
 
  PUSHFD,
  CLD,

  RDX  RCX  ->  MOV,
  REP, MOVSQ,
  
  POPFD,
  RET,


HEX
OSYMBOL dg_calcNeighborsForRowN 
( rowN                   //  RDI  
  pthisrownneighbors     //  RSI  
  pnextrownneighbors     //  RDX  
  cellsperrow            //  RCX  
  pmypixelbuffer         //  R8  -ret- )

  R8 PUSH,

  
  RDX R9 MOV,  // pnextrownneighbors
  RCX R9 ADD,  // pnextrownneighborsend     

  RSI R8 MOV,  // pthisrownneighbors
  RCX R8 ADD,  // pthisrownneighborsend

  // dwordsperrow        ( RCX already has correct value )
  // pnextrownneighbors  ( RDX already has correct value )
  // pthisrownneighbors  ( RSI already has correct value )

  RDX PUSH,       // pnextrownneighbors
  
  // prowNcells = pmypixelbuffer + (rowN * (cellsperrow / 8))   
  RDI RAX MOV,    // rowN           
  
  RCX RDX MOV,    // cellsperrow
  3 N RDX SHR,    // cellsperrow/8
   
  RDX MUL,        // rowN * (cellsperrow / 8)
  RDX POP,        // pnextrownneighbors
                          
  RDI POP,         // pmypixelbuffer
  RAX RDI ADD,     // prowNcells = pmypixelbuffer + (rowN * (cellsperrow / 8)) 

  // 5 N RCX SHR,  // need uint32sperrowofneighbors for CalcNeighborsForRow
  6 N RCX SHR,     // need uint64sperrowofneighbors for CalcNeighborsForRowFast               

  // EH-NAMEW>VALUE dg_calcNeighborsForRow O CALL,
  EH-NAMEW>VALUE dg_calcNeighborsForRowFast O CALL,
  
  RET,


HEX
OSYMBOL dg_updateCellsForRowN 
( rowN                   RDI
  ppreviousrowneighbors  RSI
  pnextrownneighbors     RDX
  cellsperrow            RCX
  pmypixelbuffer         R8   
  logicfunction          R9 -ret- )

  RBP PUSH,
  RSP RBP MOV,

  RCX PUSH,               // [RBP -8]  cellsperrow
  R9 R8 XCHG,
  5 N RCX SHR,            // dwordsperrowofcells = (cellsperrow/32)
  RDI RAX MOV,            // pmypixelbuffer + (rowN*(cellsperrow/8))
  
  RDX PUSH,               // pnextrownneighbors
  RBP -8 [R+N]  RDX MOV,  // cellsperrow
  3 N RDX SHR,            // (cellsperrow/8)
  RDX MUL,                // (rowN*(cellsperrow/8))
  RDX POP,                // pnextrownneighbors
  
  R9 RAX ADD,             // pmypixelbuffer + (rowN*(cellsperrow/8))
  RAX RDI MOV,            // pmypixelbuffer + (rowN*(cellsperrow/8))
  EH-NAMEW>VALUE dg_updateCellsForRow O CALL,

  RBP RSP MOV,
  RBP POP,
  RET,


HEX
OSYMBOL dg_lifeBitMapOnce ( -ret- )
( ppreviousrowneighbors  //  RDI
  pthisrowneighbors      //  RSI
  pnextrownneighbors     //  RDX
  cellsperrow            //  RCX
  numberofrows           //  R8
  pmypixelbuffer         //  R9
  logicfunction          //  rs0  [RBP + 10]
  ptoprowneighbors       //  rs1  [RBP + 18] -ret- )

                           //  [RBP + 8]  return address
    RBP PUSH,              //  [RBP + 0]  saved RBP
    RSP RBP MOV,

    RDI PUSH,              //  [RBP -  8]  ppreviousrowneighbors
    RSI PUSH,              //  [RBP - 10]  pthisrowneighbors
    RDX PUSH,              //  [RBP - 18]  pnextrownneighbors
    RCX PUSH,              //  [RBP - 20]  cellsperrow
    R8 PUSH,               //  [RBP - 28]  numberofrows
    R9 PUSH,               //  [RBP - 30]  pmypixelbuffer
                           //  [RBP - 38]  qwordsperrowofneighbors = (cellsperrow/8)+1
                           //  [RBP - 40]  rowN


    // RCX already has cellsperrow
 
    3 N  RCX  SHR,  
    RCX INC,  
    RCX PUSH,              //  [RBP - 38]  qwordsperrowofneighbors = (cellsperrow/8)+1

    // RCX now = (cellsperrow/8) + 1
    // RDX already has pnextneighborsbuffer
    // RSI already has pthisneighborsbuffer
    // RDI already has ppreviousneighborsbuffer
    RBP  18 [R+N]   R8  MOV,  // ptoprowneighbursbuffer
  
    EH-NAMEW>VALUE dg_clearNeighbors O CALL,


    // do top row wrap  
    RBP -30 [R+N]  R8   MOV,  // pmypixelbuffer
    RBP -20 [R+N]  RCX  MOV,  // cellsperrow
    RBP -18 [R+N]  RDX  MOV,  // pnextneighborsbuffer
    RBP -10 [R+N]  RSI  MOV,  // pthisneighborsbuffer
    RBP -28 [R+N]  RDI  MOV,  // numberofrows
    RDI DEC,                  // rowN = numberofrows - 1

    EH-NAMEW>VALUE dg_calcNeighborsForRowN O CALL,

     
    RBP -38 [R+N]  RCX  MOV,  // qwordsperrowofneighbors  
    RBP -18 [R+N]  RDX  MOV,  // pnextneighborsbuffer
    RBP -10 [R+N]  RSI  MOV,  // pthisneighborsbuffer
    RBP -8  [R+N]  RDI  MOV,  // ppreviousneighborsbuffer

    EH-NAMEW>VALUE dg_copyNeighbors O CALL,
    
    
    RBP -30 [R+N]  R8  MOV,   // pmypixelbuffer
    RBP -20 [R+N]  RCX  MOV,  // cellsperrow  
    RBP -18 [R+N]  RDX  MOV,  // pnextneighborsbuffer 
    RBP -10 [R+N]  RSI  MOV,  // pthisneighborsbuffer
    RDI  RDI  XOR,            // rowN = 0

    EH-NAMEW>VALUE dg_calcNeighborsForRowN O CALL,


    // save top row     
    RBP -38 [R+N]  RDX  MOV,  // qwordsperrowofneighbors
    RBP  18 [R+N]  RDI  MOV,  // ptoprowneighborssavebuffer
    RBP -18 [R+N]  RSI  MOV,  // pnextneighborsbuffer

    EH-NAMEW>VALUE dg_moveQwords O CALL,


    RCX RCX XOR,  RCX PUSH,   // [RBP - 40]  rowN = 0


    BEGIN,
      
      RBP -38 [R+N]  RCX  MOV,  // qwordsperrowofneighbors 
      RBP -18 [R+N]  RDX  MOV,  // pnextneighborsbuffer
      RBP -10 [R+N]  RSI  MOV,  // pthisneighborsbuffer   
      RBP -8 [R+N]   RDI  MOV,  // ppreviousneighborsbuffer

      EH-NAMEW>VALUE dg_copyNeighbors O CALL, 

   
      RBP -30 [R+N]  R8   MOV,  // pmypixelbuffer 
      RBP -20 [R+N]  RCX  MOV,  // cellsperrow 
      RBP -18 [R+N]  RDX  MOV,  // pnextneighborsbuffer
      RBP -10 [R+N]  RSI  MOV,  // pthisneighborsbuffer
      RBP -40 [R+N]  RDI  MOV,  // rowN
      RDI INC,                  // rowN + 1

      EH-NAMEW>VALUE dg_calcNeighborsForRowN O CALL,

 
      RBP  10 [R+N]  R9  MOV,   // plogicfunction
      RBP -30 [R+N]  R8  MOV,   // pmypixelbuffer
      RBP -20 [R+N]  RCX  MOV,  // cellsperrow
      RBP -18 [R+N]  RDX  MOV,  // pnextneighborsbuffer  
      RBP  -8 [R+N]  RSI  MOV,  // ppreviousneighborsbuffer
      RBP -40 [R+N]  RDI  MOV,  // rowN
 
      EH-NAMEW>VALUE dg_updateCellsForRowN O CALL,


      RBP -40 [R+N]  64BIT  INC, // rowN = rowN + 1

      RBP -28 [R+N]  RAX  MOV,   // numberofrows
      RAX DEC,                   // numberofrows - 1
      RAX  RBP -40 [R+N]  CMP,   // ((numberofrows - 1) - rowN) -> flags

    UGE UNTIL,


    RBP -38 [R+N]  RCX  MOV, 
    RBP -18 [R+N]  RDX  MOV,     // pnextneighborsbuffer  
    RBP -10 [R+N]  RSI  MOV,     // pthisneighborsbuffer
    RBP  -8 [R+N]  RDI  MOV,     // ppreviousneighborsbuffer

    EH-NAMEW>VALUE dg_copyNeighbors O CALL,


    // set up bottom row wrap
    RBP -38 [R+N]  RDX  MOV,     // qwordsperrowofneighbors
    RBP -18 [R+N]  RDI  MOV,     // pnextneighborsbuffer
    RBP  18 [R+N]  RSI  MOV,     // ptoprowneighborssavebuffer

    EH-NAMEW>VALUE dg_moveQwords O CALL,


    RBP  10 [R+N]  R9   MOV,     // plogicfunction
    RBP -30 [R+N]  R8   MOV,     // pmypixelbuffer 
    RBP -20 [R+N]  RCX  MOV,     // cellsperrow
    RBP -18 [R+N]  RDX  MOV,     // pnextneighborsbuffer
    RBP -8  [R+N]  RSI  MOV,     // ppreviousneighborsbuffer
    RBP -28 [R+N]  RDI  MOV,     // numberofrows 
    RDI DEC,                     // numberofrows-1

    EH-NAMEW>VALUE dg_updateCellsForRowN O CALL,
    

    44474C554C494645 N  RAX  MOV, // DGLULIFE

    RBP RSP MOV,
    RBP POP,
    RET,
  

// pdest                  // rdi
// psrc                   // rsi
// srcheightinbits        // rdx
// srcwidthinbits         // rcx
// srcxinbitsdestxinbits  // r8   (low 8 bits = destx, next 8 bits = srcx, 0-63)
// destwidthinbits        // r9
// lastqwordinrowmask     // [RBP + 10]
// srcendofrowbumpinbytes // [RBP + 18]

// R11:RAX shifter
// CL destx
// CH srcx
// R10 desttemp
// RBX srctemp

// to start row
//  clear dest temp
//  src temp = [psrc]
//  bswap src temp
//  psrc = psrc + 8

// to do row
//  shifter hi = src temp
//  if last src row element
//   src temp = 0
//  else
//   src temp = [psrc]
//   psrc = psrc + 8
//   shifter lo = src temp
//  shift shifter ((64 - srcxinbits) mod 64)

//  shifter lo = shifter hi
//  shifter hi = dest temp  
//  dest temp = shifter lo
//  shift sifter ((64 - destxinbits) mod 64)

//  bswap shifter hi
//  [pdest] = [pdest] xor shifter hi

HEX
OSYMBOL dg_areaXor ( -ret- )
  
  // if height = 0 return
  RDX RDX AND,
  EQ IF,
    RET,
  THEN,

  // if width = 0 return
  RCX RCX AND,
  EQ IF,
    RET,
  THEN,

  // if destwidth < srcwidth return
  RCX R9 CMP,
  CS IF,
    RET,
  THEN,

  // if srcwidth to do < srcwidth return
  // RBP 18 [R+N]  RCX  ->  CMP,
  // CS IF,
  //  RET,
  // THEN,

  6 N R9 SHR,     // R9 now has dest width in qwords - assumes destination aligned to uint64

  RBP PUSH,
  RSP RBP MOV,

  RBX PUSH,     // [RBP - 8]   desttemp 
  RCX PUSH,     // [RBP - 10]  srcwidthinbits
  RAX RAX XOR,
  CL AL -> MOV,
  3F N AL AND,
  6 N RCX SHR,
  0 N AL CMP,
  NE IF,
    RCX INC,
  THEN,
  RCX PUSH,     // [RBP - 18]  srcwidthinqwords
  RAX PUSH,     // [RBP - 20]  leftoversrcbits

  RCX R9 -> SUB,  // R9 now has dest bump in uint64s
  3 N  R9  SHL,   // R9 now has dest bump in bytes

  40 N CL MOV,  // convert destx to destshift
  R8L CL SUB,

  8 N  R8  SHR,
  CH CL XCHG,
  R8L CL MOV,
    
  BEGIN,
    
    // starting row
    R10 R10 XOR,              // clear dest temp
    RBP -18 [R+N]  R8  MOV,   // R8 = srcwidthinqwords 
    RSI [R] RBX -> MOV,
    8 N  RSI  ADD,
    RBX BSWAP,

    // doing row
    BEGIN,
      RBX R11 MOV, // shifterhi = srctemp
      RBX RBX XOR, 
      1 N  R8  CMP,
      NE IF,
        RSI [R] RBX -> MOV,
        8 N  RSI  ADD,
        RBX BSWAP,
      THEN,
      RBX RAX MOV,
      CL R11 RAX <- SHLD,

      // last qword mask happens here to R11
      1 N  R8  CMP,
      EQ IF,
        RBP 10 [R+N]  R11  AND,
      THEN,

      40 N CH CMP, // if CH=40, R11 already has src
      NE IF,
        R11 RAX MOV,
        R10 R11 MOV,
        RAX R10 MOV,
        CH CL XCHG,
        CL R11 RAX <- SHLD,
        CH CL XCHG,
      THEN,
      R11 BSWAP,  
      R11  RDI [R] ->  XOR,
      8 N  RDI  ADD,

      R8 DEC,
    EQ UNTIL,

    // 40 - xoffset is what will fit
    // if  40 - xoffset < leftoversrcbits then need to do last word
    // do last part of row
    RBP -20 [R+N] CH -> CMP,  // this shouldn't use REX.. can't use REX with CH
    CC IF,  // CC works, CS doesn't... I'm confused... should be CS...
      CH CL XCHG,
      CL RAX <- SHL,
      CH CL XCHG,
      RAX BSWAP,
      RAX  RDI [R] ->  XOR,
    THEN,

    R9  RDI  ADD,

    RBP 18 [R+N]  RSI  ADD,

    RDX DEC,
  EQ UNTIL,
  
  RBP -8 [R+N]  RSP  LEA,
  RBX POP,
  RBP POP,
  RET,

// pdest                  // rdi
// psrc                   // rsi
// srcheightinbits        // rdx
// srcwidthinqwordstodo   // rcx
// srcxinbitsdestxinbits  // r8   (low 8 bits = destx, next 8 bits = srcx, 0-63)
// destwidthinqwords      // r9
// lastqwordinrowmask     // [RBP + 10]
// srcendofrowbumpinbytes // [RBP + 18]

// R11:RAX shifter
// CL destx
// CH srcx
// R10 desttemp
// RBX srctemp

// to start row
//  clear dest temp
//  src temp = [psrc]
//  bswap src temp
//  psrc = psrc + 8

// to do row
//  shifter hi = src temp
//  if last src row element
//   src temp = 0
//  else
//   src temp = [psrc]
//   psrc = psrc + 8
//   shifter lo = src temp
//  shift shifter ((64 - srcxinbits) mod 64)

//  shifter lo = shifter hi
//  shifter hi = dest temp  
//  dest temp = shifter lo
//  shift sifter ((64 - destxinbits) mod 64)

//  bswap shifter hi
//  [pdest] = [pdest] xor shifter hi

HEX
OSYMBOL dg_areaOr ( -ret- )
  
  // if height = 0 return
  RDX RDX AND,
  EQ IF,
    RET,
  THEN,

  // if width = 0 return
  RCX RCX AND,
  EQ IF,
    RET,
  THEN,

  // if destwidth < srcwidth return
  RCX R9 CMP,
  CS IF,
    RET,
  THEN,

  // if srcwidth to do < srcwidth return
  // RBP 18 [R+N]  RCX  ->  CMP,
  // CS IF,
  //  RET,
  // THEN,

  6 N R9 SHR,     // R9 now has dest width in qwords - assumes destination aligned to uint64

  RBP PUSH,
  RSP RBP MOV,

  RBX PUSH,     // [RBP - 8]   desttemp 
  RCX PUSH,     // [RBP - 10]  srcwidthinbits
  RAX RAX XOR,
  CL AL -> MOV,
  3F N AL AND,
  6 N RCX SHR,
  0 N AL CMP,
  NE IF,
    RCX INC,
  THEN,
  RCX PUSH,     // [RBP - 18]  srcwidthinqwords
  RAX PUSH,     // [RBP - 20]  leftoversrcbits

  RCX R9 -> SUB,  // R9 now has dest bump in uint64s
  3 N  R9  SHL,   // R9 now has dest bump in bytes

  40 N CL MOV,  // convert destx to destshift
  R8L CL SUB,

  8 N  R8  SHR,
  CH CL XCHG,
  R8L CL MOV,
    
  BEGIN,
    
    // starting row
    R10 R10 XOR,              // clear dest temp
    RBP -18 [R+N]  R8  MOV,   // R8 = srcwidthinqwords 
    RSI [R] RBX -> MOV,
    8 N  RSI  ADD,
    RBX BSWAP,

    // doing row
    BEGIN,
      RBX R11 MOV, // shifterhi = srctemp
      RBX RBX XOR, 
      1 N  R8  CMP,
      NE IF,
        RSI [R] RBX -> MOV,
        8 N  RSI  ADD,
        RBX BSWAP,
      THEN,
      RBX RAX MOV,
      CL R11 RAX <- SHLD,

      // last qword mask happens here to R11
      1 N  R8  CMP,
      EQ IF,
        RBP 10 [R+N]  R11  AND,
      THEN,

      40 N CH CMP, // if CH=40, R11 already has src
      NE IF,
        R11 RAX MOV,
        R10 R11 MOV,
        RAX R10 MOV,
        CH CL XCHG,
        CL R11 RAX <- SHLD,
        CH CL XCHG,
      THEN,
      R11 BSWAP,  
      R11  RDI [R] ->  OR,
      8 N  RDI  ADD,

      R8 DEC,
    EQ UNTIL,

    // 40 - xoffset is what will fit
    // if  40 - xoffset < leftoversrcbits then need to do last word
    // do last part of row
    RBP -20 [R+N] CH -> CMP,  // this shouldn't use REX.. can't use REX with CH
    CC IF,  // CC works, CS doesn't... I'm confused... should be CS...
      CH CL XCHG,
      CL RAX <- SHL,
      CH CL XCHG,
      RAX BSWAP,
      RAX  RDI [R] ->  OR,
    THEN,

    R9  RDI  ADD,

    RBP 18 [R+N]  RSI  ADD,

    RDX DEC,
  EQ UNTIL,
  
  RBP -8 [R+N]  RSP  LEA,
  RBX POP,
  RBP POP,
  RET,



// pdest                  // rdi
// psrc                   // rsi
// srcheightinbits        // rdx
// srcwidthinqwordstodo   // rcx
// srcxinbitsdestxinbits  // r8   (low 8 bits = destx, next 8 bits = srcx, 0-63)
// destwidthinqwords      // r9
// lastqwordinrowmask     // [RBP + 10]
// srcendofrowbumpinbytes // [RBP + 18]

// R11:RAX shifter
// CL destx
// CH srcx
// R10 desttemp
// RBX srctemp

// to start row
//  clear dest temp
//  src temp = [psrc]
//  bswap src temp
//  psrc = psrc + 8

// to do row
//  shifter hi = src temp
//  if last src row element
//   src temp = 0
//  else
//   src temp = [psrc]
//   psrc = psrc + 8
//   shifter lo = src temp
//  shift shifter ((64 - srcxinbits) mod 64)

//  shifter lo = shifter hi
//  shifter hi = dest temp  
//  dest temp = shifter lo
//  shift sifter ((64 - destxinbits) mod 64)

//  bswap shifter hi
//  [pdest] = [pdest] xor shifter hi

HEX
OSYMBOL dg_areaAnd ( -ret- )
  
  // if height = 0 return
  RDX RDX AND,
  EQ IF,
    RET,
  THEN,

  // if width = 0 return
  RCX RCX AND,
  EQ IF,
    RET,
  THEN,

  // if destwidth < srcwidth return
  RCX R9 CMP,
  CS IF,
    RET,
  THEN,

  // if srcwidth to do < srcwidth return
  // RBP 18 [R+N]  RCX  ->  CMP,
  // CS IF,
  //  RET,
  // THEN,

  6 N R9 SHR,     // R9 now has dest width in qwords - assumes destination aligned to uint64

  RBP PUSH,
  RSP RBP MOV,

  RBX PUSH,     // [RBP - 8]   desttemp 
  RCX PUSH,     // [RBP - 10]  srcwidthinbits
  RAX RAX XOR,
  CL AL -> MOV,
  3F N AL AND,
  6 N RCX SHR,
  0 N AL CMP,
  NE IF,
    RCX INC,
  THEN,
  RCX PUSH,     // [RBP - 18]  srcwidthinqwords
  RAX PUSH,     // [RBP - 20]  leftoversrcbits

  RCX R9 -> SUB,  // R9 now has dest bump in uint64s
  3 N  R9  SHL,   // R9 now has dest bump in bytes

  40 N CL MOV,  // convert destx to destshift
  R8L CL SUB,

  8 N  R8  SHR,
  CH CL XCHG,
  R8L CL MOV,
    
  BEGIN,
    
    // starting row
    R10 R10 XOR,              // clear dest temp
    RBP -18 [R+N]  R8  MOV,   // R8 = srcwidthinqwords 
    RSI [R] RBX -> MOV,
    8 N  RSI  ADD,
    RBX BSWAP,

    // doing row
    BEGIN,
      RBX R11 MOV, // shifterhi = srctemp
      RBX RBX XOR, 
      1 N  R8  CMP,
      NE IF,
        RSI [R] RBX -> MOV,
        8 N  RSI  ADD,
        RBX BSWAP,
      THEN,
      RBX RAX MOV,
      CL R11 RAX <- SHLD,

      // last qword mask happens here to R11
      1 N  R8  CMP,
      EQ IF,
        RBP 10 [R+N]  R11  AND,
      THEN,

      40 N CH CMP, // if CH=40, R11 already has src
      NE IF,
        R11 RAX MOV,
        R10 R11 MOV,
        RAX R10 MOV,
        CH CL XCHG,
        CL R11 RAX <- SHLD,
        CH CL XCHG,
      THEN,
      R11 BSWAP,  
      R11  RDI [R] ->  AND,
      8 N  RDI  ADD,

      R8 DEC,
    EQ UNTIL,

    // 40 - xoffset is what will fit
    // if  40 - xoffset < leftoversrcbits then need to do last word
    // do last part of row
    RBP -20 [R+N] CH -> CMP,  // this shouldn't use REX.. can't use REX with CH
    CC IF,  // CC works, CS doesn't... I'm confused... should be CS...
      CH CL XCHG,
      CL RAX <- SHL,
      CH CL XCHG,
      RAX BSWAP,
      RAX  RDI [R] ->  AND,
    THEN,

    R9  RDI  ADD,

    RBP 18 [R+N]  RSI  ADD,

    RDX DEC,
  EQ UNTIL,
  
  RBP -8 [R+N]  RSP  LEA,
  RBX POP,
  RBP POP,
  RET,



// pdest                  // rdi
// psrc                   // rsi
// srcheightinbits        // rdx
// srcwidthinqwordstodo   // rcx
// srcxinbitsdestxinbits  // r8   (low 8 bits = destx, next 8 bits = srcx, 0-63)
// destwidthinqwords      // r9
// lastqwordinrowmask     // [RBP + 10]
// srcendofrowbumpinbytes // [RBP + 18]

// R11:RAX shifter
// CL destx
// CH srcx
// R10 desttemp
// RBX srctemp

// to start row
//  clear dest temp
//  src temp = [psrc]
//  bswap src temp
//  psrc = psrc + 8

// to do row
//  shifter hi = src temp
//  if last src row element
//   src temp = 0
//  else
//   src temp = [psrc]
//   psrc = psrc + 8
//   shifter lo = src temp
//  shift shifter ((64 - srcxinbits) mod 64)

//  shifter lo = shifter hi
//  shifter hi = dest temp  
//  dest temp = shifter lo
//  shift sifter ((64 - destxinbits) mod 64)

//  bswap shifter hi
//  [pdest] = [pdest] xor shifter hi

HEX
OSYMBOL dg_areaNotSourceAnd ( -ret- )  // this uses a mask to clear where bit = 1 means clear
  
  // if height = 0 return
  RDX RDX AND,
  EQ IF,
    RET,
  THEN,

  // if width = 0 return
  RCX RCX AND,
  EQ IF,
    RET,
  THEN,

  // if destwidth < srcwidth return
  RCX R9 CMP,
  CS IF,
    RET,
  THEN,

  // if srcwidth to do < srcwidth return
  // RBP 18 [R+N]  RCX  ->  CMP,
  // CS IF,
  //  RET,
  // THEN,

  6 N R9 SHR,     // R9 now has dest width in qwords - assumes destination aligned to uint64

  RBP PUSH,
  RSP RBP MOV,

  RBX PUSH,     // [RBP - 8]   desttemp 
  RCX PUSH,     // [RBP - 10]  srcwidthinbits
  RAX RAX XOR,
  CL AL -> MOV,
  3F N AL AND,
  6 N RCX SHR,
  0 N AL CMP,
  NE IF,
    RCX INC,
  THEN,
  RCX PUSH,     // [RBP - 18]  srcwidthinqwords
  RAX PUSH,     // [RBP - 20]  leftoversrcbits

  RCX R9 -> SUB,  // R9 now has dest bump in uint64s
  3 N  R9  SHL,   // R9 now has dest bump in bytes

  40 N CL MOV,  // convert destx to destshift
  R8L CL SUB,

  8 N  R8  SHR,
  CH CL XCHG,
  R8L CL MOV,
    
  BEGIN,
    
    // starting row
    R10 R10 XOR,              // clear dest temp
    RBP -18 [R+N]  R8  MOV,   // R8 = srcwidthinqwords 
    RSI [R] RBX -> MOV,
    8 N  RSI  ADD,
    RBX BSWAP,

    // doing row
    BEGIN,
      RBX R11 MOV, // shifterhi = srctemp
      RBX RBX XOR, 
      1 N  R8  CMP,
      NE IF,
        RSI [R] RBX -> MOV,
        8 N  RSI  ADD,
        RBX BSWAP,
      THEN,
      RBX RAX MOV,
      CL R11 RAX <- SHLD,

      // last qword mask happens here to R11
      1 N  R8  CMP,
      EQ IF,
        RBP 10 [R+N]  R11  AND,
      THEN,

      40 N CH CMP, // if CH=40, R11 already has src
      NE IF,
        R11 RAX MOV,
        R10 R11 MOV,
        RAX R10 MOV,
        CH CL XCHG,
        CL R11 RAX <- SHLD,
        CH CL XCHG,
      THEN,
      R11 BSWAP,  
      R11 NOT,
      R11  RDI [R] ->  AND,
      8 N  RDI  ADD,

      R8 DEC,
    EQ UNTIL,

    // 40 - xoffset is what will fit
    // if  40 - xoffset < leftoversrcbits then need to do last word
    // do last part of row
    RBP -20 [R+N] CH -> CMP,  // this shouldn't use REX.. can't use REX with CH
    CC IF,  // CC works, CS doesn't... I'm confused... should be CS...
      CH CL XCHG,
      CL RAX <- SHL,
      CH CL XCHG,
      RAX BSWAP,
      RAX NOT,
      RAX  RDI [R] ->  AND,
    THEN,

    R9  RDI  ADD,

    RBP 18 [R+N]  RSI  ADD,

    RDX DEC,
  EQ UNTIL,
  
  RBP -8 [R+N]  RSP  LEA,
  RBX POP,
  RBP POP,
  RET,


// returns an offset 0 to srcwidth of where in the source the overlap occurs
//  and a length which = srcwidth - returnoffset
// return = 0 means the source is completely beyond the destination
// return = srcwidth means the entire source fits in the destination

// srcwidth               // rdi
// destwidth              // rsi
// destx                  // rdx

// distancetoend = (destwidth - destx) (and amount that will fit)
// if srcwidth <= distancetoend, return srcwidth
// else return distancetoend

OSYMBOL dg_getOverlapOffset

  RAX RAX XOR, // if destx >= destwidth, ret 0
  RSI RDX -> CMP,
  NC IF,
    RET,
  THEN,

  RDX RSI -> SUB,  // RSI = distance to end
  RSI RDI -> CMP,
  NC IF,
    RSI RAX -> MOV,
  ELSE,
    RDI RAX -> MOV,
  THEN,
  RET,


OLDCOMPILEBUFID PCURRENTCOMPILEBUFFER !

// gettings addresses because EH-NAMEW>VALUE is not an immediate word 
EH-NAMEW>VALUE dg_calcNeighborsForRow LIFECOMPILEBUFID GETSBUFFER DROP + 
  CONSTANT dg_calcNeighborsForRowAddr

EH-NAMEW>VALUE dg_thisneighborsaddtbl LIFECOMPILEBUFID GETSBUFFER DROP +
  CONSTANT dg_thisneighborsaddtblAddr

EH-NAMEW>VALUE dg_nextneighborsaddtbl LIFECOMPILEBUFID GETSBUFFER DROP +
  CONSTANT dg_nextneighborsaddtblAddr

HEX
PCELLSBUF 1000 0 FILL
dg_thisneighborsaddtblAddr 1000 0 FILL
dg_nextneighborsaddtblAddr 1000 0 FILL

HEX
: MakeAddTables ( -- )
  100 0 DO

    I PCELLSBUF 1+ C!
    PTHISNEIGHBORSBUF 100 0 FILL
    PNEXTNEIGHBORSBUF 100 0 FILL
    
    PNEXTNEIGHBORSBUF 100 + // don't really care about this one, just something unused
    PTHISNEIGHBORSBUF 100 + // don't really care about this one, just something unused
    1
    PNEXTNEIGHBORSBUF
    PTHISNEIGHBORSBUF
    PCELLSBUF
    6
    dg_calcNeighborsForRowAddr 
    CALLPROC
    DROP

    0A 0 DO

      PTHISNEIGHBORSBUF 8 + I + C@
      dg_thisneighborsaddtblAddr J 10 * + I + C!
      PNEXTNEIGHBORSBUF 8 + I + C@
      dg_nextneighborsaddtblAddr J 10 * + I + C!
  
    LOOP
   
  LOOP
;

MakeAddTables


// saving the compiled buffer

// LIFECOMPILEBUFID $" life.dglib" SAVEFILE$

// DROPEH ( dropping symbol list elementid hlistid )


// saving the nglu list

// EH> PACK-HLIST $" life.glulist" SAVEFILE$

// DROP ( dropping nglu list element id )


// saving the compiled buffer in the mach-o .o format

LIFECOMPILEBUFID EH> $" lifelib.o" BUF>.OFILE$


// usind ld to turn the .o file into a dylib
//  Added -lSystem for Monterey 2022 May 15
RUNFILEANDWAITNOENV" ld -demangle -dynamic -dylib -arch x86_64 -platform_version macos 11.0.0 11.1 -syslibroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -o liblife.dylib -L/usr/local/lib lifelib.o -lSystem"


// removing the .o file

RUNFILEANDWAITNOENV" rm lifelib.o"
