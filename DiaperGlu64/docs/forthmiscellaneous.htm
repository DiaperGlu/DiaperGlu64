<!--
// //////////////////////////////////////////////////////////////////////////////////////
//
//    Copyright 2023 James Patrick Norris
//
//    This file is part of DiaperGlu v5.13.
//
//    DiaperGlu v5.13 is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    DiaperGlu v5.13 is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with DiaperGlu v5.13; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// //////////////////////////////////////////////////////////////////////////////////////

// /////////////////////////////
// James Patrick Norris       //
// www.rainbarrel.com         //
// February 2, 2025           //
// version 5.13               //
// /////////////////////////////
-->

<html>

  <head>
    <link rel='stylesheet' type='text/css' href='diaperglu.css'>
  </head>

  <body><div id=content>

    <div id=pageheader>
      forthmiscellaneous.cpp functions
    </div>
    
    <div id=sitedirectory>
      <a href=index.htm>Home</a>
      <a href=building.htm>Building</a>
      <a href=usingcgi.htm>DHTML Scripting</a>
      <a href=usingdiaperglu.htm>Using Diaperglu</a>
      <a href=documentationkey.htm>Documention Key</a>
      <a href=diapergluwords.htm>Script Commands Reference</a>
      <a href=cfunctions.htm>C Library API Reference</a>
      <a href=reference.htm>Handy References</a>
      <a href=about.htm>About</a>
      <a href=license.htm>License</a>
      <a href=contact.htm>Contact</a>
      <a href=forthdraftstandard.htm>Forth Draft Standard</a>
    </div>

    <div id=pagedirectory>
      
      <a href=index.htm                                          >Directory</a>
      <a href=documentationkey.htm                               >Documentation key</a>
      <a                                                         >&nbsp;</a>

      <a                                                         >C Functions</a>
      <a href=forthmiscellaneous.htm#dg_evaluatebuffer           >dg_evaluatebuffer</a>
      <a href=forthmiscellaneous.htm#dg_forthocall               >dg_forthocall</a>
      <a href=forthmiscellaneous.htm#dg_forthqueryendevaluate    >dg_forthqueryendevaluate</a>
      <a href=forthmiscellaneous.htm#dg_forthtype0string         >dg_forthtype0string</a>
      <a href=forthmiscellaneous.htm#dg_forthshowlicense         >dg_forthshowlicense</a>
      <a href=forthmiscellaneous.htm#dg_forthcrlf                >dg_forthcrlf</a>
      <a href=forthmiscellaneous.htm#dg_forthgethstdin           >dg_forthgethstdin</a>
      <a href=forthmiscellaneous.htm#dg_forthgethstdout          >dg_forthgethstdout</a>
      <a href=forthmiscellaneous.htm#dg_forthgethstderror        >dg_forthgethstderror</a>
      <a href=forthmiscellaneous.htm#dg_forthgetfilelength       >dg_forthgetfilelength</a>
      <a href=forthmiscellaneous.htm#dg_forthreadavailabletobuffer >dg_forthreadavailabletobuffer</a>
      <a href=forthmiscellaneous.htm#dg_forthreadwaitforntobuffer  >dg_forthreadwaitforntobuffer</a>
      <a href=forthmiscellaneous.htm#dg_forthcompilecallcore       >dg_forthcompilecallcore</a>
      <a href=forthmiscellaneous.htm#dg_forthcompilecallsamebuffer >dg_forthcompilecallsamebuffer</a>
      <a href=forthmiscellaneous.htm#dg_forthcompilecallbuffer     >dg_forthcompilecallbuffer</a>
      <a href=forthmiscellaneous.htm#dg_forthcompilesafecallbuffer >dg_forthcompilesafecallbuffer</a>
      <a href=forthmiscellaneous.htm#dg_forthcompiletoxtp        >dg_forthcompiletoxtp</a>
      <a href=forthmiscellaneous.htm#dg_forthcscan               >dg_forthcscan</a>
      <a href=forthmiscellaneous.htm#dg_forthscan                >dg_forthscan</a>
      <a href=forthmiscellaneous.htm#dg_forthdoprompt            >dg_forthdoprompt</a>
      <a href=forthmiscellaneous.htm#dg_forthbswap               >dg_forthbswap</a>
      <a href=forthmiscellaneous.htm#dg_forthcompilebranch       >dg_forthcompilebranch</a>
      <a href=forthmiscellaneous.htm#dg_forthresolvecompiledbranch>dg_forthresolvecompiledbranch</a>
      <a href=forthmiscellaneous.htm#dg_forthosquotes            >dg_forthosquotes</a>
      <a href=forthmiscellaneous.htm#dg_fortho0quotes            >dg_fortho0quotes</a>
      <a href=forthmiscellaneous.htm#dg_forthpagesize            >dg_forthpagesize</a>
      <a href=forthmiscellaneous.htm#dg_forthroundup             >dg_forthroundup</a>
      <a href=forthmiscellaneous.htm#dg_forthcallprocaddress     >dg_forthcallprocaddress</a>
      <a href=forthmiscellaneous.htm#dg_forthcalldfpprocaddress  >dg_forthcalldfpprocaddress</a>
      <a href=forthmiscellaneous.htm#dg_forthcallprocaddressretuint128 >dg_forthcallprocaddressretuint128</a>
      <a href=forthmiscellaneous.htm#dg_forthcallcppmemberfunction >dg_forthcallcppmemberfunction</a>
      <a href=forthmiscellaneous.htm#dg_forthudmslashmod         >dg_forthudmslashmod</a>
      <a href=forthmiscellaneous.htm#dg_forthodoes               >dg_forthodoes</a>
      <a href=forthmiscellaneous.htm#dg_forthpackdf              >dg_forthpackdf</a>
      <a href=forthmiscellaneous.htm#dg_forthunpackdf            >dg_forthunpackdf</a>
      <a href=forthmiscellaneous.htm#dg_forthcodescomma          >dg_forthcodescomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodeu8comma         >dg_forthcodeu8comma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodeu16comma        >dg_forthcodeu16comma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodeu32comma        >dg_forthcodeu32comma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodeu64comma        >dg_forthcodeu64comma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodeallot           >dg_forthcodeallot</a>
      <a href=forthmiscellaneous.htm#dg_forthdoterrorline        >dg_forthdoterrorline</a>
      <a href=forthmiscellaneous.htm#dg_forthohere               >dg_forthohere</a>
      <a href=forthmiscellaneous.htm#dg_forthdglibstring         >dg_forthdglibstring</a>
      <a href=forthmiscellaneous.htm#dg_forthlobit               >dg_forthlobit</a>
      <a href=forthmiscellaneous.htm#dg_forthhibit               >dg_forthhibit</a>
      <a href=forthmiscellaneous.htm#dg_forthcountbits           >dg_forthcountbits</a>
      <a href=forthmiscellaneous.htm#dg_forthulo1bits            >dg_forthulo1bits</a>
      <a href=forthmiscellaneous.htm#dg_forthulobits             >dg_forthulobits</a>
      <a href=forthmiscellaneous.htm#dg_forthulomask             >dg_forthulomask</a>
      <a href=forthmiscellaneous.htm#dg_forthtwototheu           >dg_forthtwototheu</a>
      <a href=forthmiscellaneous.htm#dg_forthbitset              >dg_forthbitset</a>
      <a href=forthmiscellaneous.htm#dg_forthbitclr              >dg_forthbitclr</a>
      <a href=forthmiscellaneous.htm#dg_forthbitnot              >dg_forthbitnot</a>
      <a href=forthmiscellaneous.htm#dg_forthumax                >dg_forthumax</a>
      <a href=forthmiscellaneous.htm#dg_forthumin                >dg_forthumin</a>
      <a href=forthmiscellaneous.htm#dg_forthulessthanequals     >dg_forthulessthanequals</a>
      <a href=forthmiscellaneous.htm#dg_forthugreaterthanequals  >dg_forthugreaterthanequals</a>
      <a href=forthmiscellaneous.htm#dg_forthtouleb128           >dg_forthtouleb128</a>
      <a href=forthmiscellaneous.htm#dg_forthhctwostore          >dg_forthhctwostore</a>
      <a href=forthmiscellaneous.htm#dg_forthdrshift             >dg_forthdrshift</a>
      <a href=forthmiscellaneous.htm#dg_forthdlshift             >dg_forthdlshift</a>
      <a href=forthmiscellaneous.htm#dg_forthdarshift            >dg_forthdarshift</a>
      <a href=forthmiscellaneous.htm#dg_forthbuftodotobuf        >dg_forthbuftodotobuf</a>
      <a href=forthmiscellaneous.htm#dg_forthbuftodotofilestring >dg_forthbuftodotofilestring</a>
      <a href=forthmiscellaneous.htm#dg_forthbuftomachodotobuf   >dg_forthbuftomachodotobuf</a>
      <a href=forthmiscellaneous.htm#dg_forthpi                  >dg_forthpi</a>
      <a href=forthmiscellaneous.htm#dg_forthe                   >dg_forthe</a>
      <a href=forthmiscellaneous.htm#dg_forthinfinity            >dg_forthinfinity</a>
      <a href=forthmiscellaneous.htm#dg_forthminusinfinity       >dg_forthminusinfinity</a>
      <a href=forthmiscellaneous.htm#dg_forthdenormal            >dg_forthdenormal</a>
      <a href=forthmiscellaneous.htm#dg_forthminusdenormal       >dg_forthminusdenormal</a>
      <a href=forthmiscellaneous.htm#dg_forthnan                 >dg_forthnan</a>
      <a href=forthmiscellaneous.htm#dg_forthminusnan            >dg_forthminusnan</a>
      <a href=forthmiscellaneous.htm#dg_forthminusrot            >dg_forthminusrot</a>
      <a href=forthmiscellaneous.htm#dg_forthrandom              >dg_forthrandom</a>
      <a href=forthmiscellaneous.htm#dg_forthcompileu8s          >dg_forthcompileu8s</a>
      <a href=forthmiscellaneous.htm#dg_forthcompileu8scurly     >dg_forthcompileu8scurly</a>
      <a href=forthmiscellaneous.htm#dg_forthconstants           >dg_forthconstants</a>
      <a href=forthmiscellaneous.htm#dg_forthconstantscurly      >dg_forthconstantscurly</a>
      <a href=forthmiscellaneous.htm#dg_forthlocalconstants      >LOCAL-CONSTANTS</a>
      <a href=forthmiscellaneous.htm#dg_forthlocalconstantscurly >LOCAL-CONSTANTS&gt;</a>
      <a href=forthmiscellaneous.htm#dg_forthbracketlocalconstants      >[LOCAL-CONSTANTS]</a>
      <a href=forthmiscellaneous.htm#dg_forthbracketlocalconstantscurly >[LOCAL-CONSTANTS]&gt;</a>
      <a href=forthmiscellaneous.htm#dg_forthfconstants          >dg_forthfconstants</a>
      <a href=forthmiscellaneous.htm#dg_forthfconstantscurly     >dg_forthfconstantscurly</a>
      <a href=forthmiscellaneous.htm#dg_forthvariables           >dg_forthvariables</a>
      <a href=forthmiscellaneous.htm#dg_forthvariablescurly      >dg_forthvariablescurly</a>
      <a href=forthmiscellaneous.htm#dg_forthmicrosecondssince1970jan01>dg_forthmicrosecondssince1970jan01</a>
      <a href=forthmiscellaneous.htm#dg_forthbrackettoorderconstant    >dg_forthbrackettoorderconstant</a>
      <a href=forthmiscellaneous.htm#dg_forthsizedconstantscurly       >dg_forthsizedconstantscurly</a>
      <a href=forthmiscellaneous.htm#dg_forthenumcurly           >ENUM&gt;</a>
      <a href=forthmiscellaneous.htm#dg_forthlocalenumcurly      >LOCAL-ENUM&gt;</a>
      <a href=forthmiscellaneous.htm#dg_forthbracketlocalenumcurly>[LOCAL-ENUM]&gt;</a>
      <a href=forthmiscellaneous.htm#dg_forthtypedenumcurly      >dg_forthtypedenumcurly</a>
      <a href=forthmiscellaneous.htm#dg_forthtypedlocalenumcurly >dg_forthtypedlocalenumcurly</a>
      <a href=forthmiscellaneous.htm#dg_forthn8tocell            >dg_forthn8tocell</a>
      <a href=forthmiscellaneous.htm#dg_forthn16tocell           >dg_forthn16tocell</a>
      <a href=forthmiscellaneous.htm#dg_forthn32tocell           >dg_forthn32tocell</a>
      <a href=forthmiscellaneous.htm#dg_forthtoxtpcomma          >dg_forthtoxtpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthbeginsystopcomma    >dg_forthbeginsystopcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemescomma        >dg_forthcodemescomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemecomma         >dg_forthcodemecomma</a>
      <a href=forthmiscellaneous.htm#dg_forthendcodemescomma     >dg_forthendcodemescomma</a>
      <a href=forthmiscellaneous.htm#dg_forthnumbercodemes       >dg_forthnumbercodemes</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemescurrent      >dg_forthcodemescurrent</a>
      <a href=forthmiscellaneous.htm#dg_forthquerycodemescurrent >dg_forthquerycodemescurrent</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesuifsys       >dg_forthcodemesuifsys</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesubeginsys    >dg_forthcodemesubeginsys</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesdrop         >dg_forthcodemesdrop</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesresolvestart >dg_forthcodemesresolvestart</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesresolveends  >dg_forthcodemesresolveends</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemescasecomma    >dg_forthcodemescasecomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesofcomma       >dg_forthcodemesofcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesendcasecomma >dg_forthcodemesendcasecomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemescasescomma   >dg_forthcodemescasescomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesjumpscomma   >dg_forthcodemesjumpscomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemealwaysjumpcomma>dg_forthcodemealwaysjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemeequaljumpcomma>dg_forthxcodemeequaljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemenotequaljumpcomma>dg_forthxcodemenotequaljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemeulessthanjumpcomma>dg_forthxcodemeulessthanjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemeulessthanequaljumpcomma>dg_forthxcodemeulessthanequaljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemeugreaterthanjumpcomma>dg_forthxcodemeugreaterthanjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemeugreaterthanequaljumpcomma>dg_forthxcodemeugreaterthanequaljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemelessthanjumpcomma>dg_forthxcodemelessthanjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemelessthanequaljumpcomma>dg_forthxcodemelessthanequaljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemegreaterthanjumpcomma>dg_forthxcodemegreaterthanjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemegreaterthanequaljumpcomma>dg_forthxcodemegreaterthanequaljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodememijumpcomma>dg_forthxcodememijumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemepljumpcomma>dg_forthxcodemepljumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemevsjumpcomma>dg_forthxcodemevsjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemenvjumpcomma>dg_forthxcodemenvjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemepsjumpcomma>dg_forthxcodemepsjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxcodemenpjumpcomma>dg_forthxcodemenpjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthxycodemewithinjumpcomma>dg_forthxycodemewithinjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthdefaultjumpcomma>dg_forthdefaultjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthdefaultdropjumpcomma>dg_forthdefaultdropjumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesendjumpscomma>dg_forthcodemesendjumpscomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesjumptablecomma>dg_forthcodemesjumptablecomma</a>
      <a href=forthmiscellaneous.htm#dg_forthjumptableujumpcomma>dg_forthjumptableujumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthcodemesujumpcomma>dg_forthcodemesujumpcomma</a>
      <a href=forthmiscellaneous.htm#dg_forthquerynotequals>dg_forthquerynotequals</a>
      <a href=forthmiscellaneous.htm#dg_forthquerylessthan>dg_forthquerylessthan</a>
      <a href=forthmiscellaneous.htm#dg_forthquerylessthanequal>dg_forthquerylessthanequal</a>
      <a href=forthmiscellaneous.htm#dg_forthqueryulessthan>dg_forthqueryulessthan</a>
      <a href=forthmiscellaneous.htm#dg_forthqueryulessthanequal>dg_forthqueryulessthanequal</a>
      <a href=forthmiscellaneous.htm#dg_forthquerygreaterthan>dg_forthquerygreaterthan</a>
      <a href=forthmiscellaneous.htm#dg_forthquerygreaterthanequal>dg_forthquerygreaterthanequal</a>
      <a href=forthmiscellaneous.htm#dg_forthqueryugreaterthan>dg_forthqueryugreaterthan</a>
      <a href=forthmiscellaneous.htm#dg_forthqueryugreaterthanequal>dg_forthqueryugreaterthanequal</a>
      <a href=forthmiscellaneous.htm#dg_forthcleftbracket>dg_forthcleftbracket</a>
      <a href=forthmiscellaneous.htm#dg_forthcrightbracket>dg_forthcrightbracket</a>
      <a href=forthmiscellaneous.htm#dg_forthci>dg_forthci</a>
      <a href=forthmiscellaneous.htm#dg_forthcp>dg_forthcp</a>
      <a href=forthmiscellaneous.htm#dg_forthcleftparen>dg_forthcleftparen</a>

    </div>

    <div id=pagestuff>


      <div class=word id=dg_evaluatebuffer>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_evaluatebuffer ( EVALUATEBUFFER )
//
// C prototype:
//  void dg_forthevaluatebuffer (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the 
//                                    other bufferhandles are stored
//
// Stack action shorthand:
//  ( bufferid -- )
//
// Data stack in:
//  bufferid                         buffer containing text to evaluate          
//
// Action:
//  Removes buffer id from the data stack.
//  Starts at the beginning of the buffer then gets each word in the buffer, looks it up
//   in the current search order, then does the action for the word based on the current 
//   script processing state  
//  If it runs across a word it can't find, it stops.
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow error
//  error evaluating the buffer (subroutine returns an error)
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthocall>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthocall ( OCALL )
//
// C prototype:
//  void dg_forthocall ( Bufferhandle* pBHarrayhead ) 
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( compileroutineoffset compileroutinebufid -- )
//
// Data stack in:
//  offset                        offset of routine to call in buffer bufferid
//  bufferid                      routine to call is in this buffer
//                                                       
// Action:
//  Calls the routine at the offset in the buffer.
//  
// Note:
//  If the buffer id is DG_CORE_BUFFERID, this routine will use the offset as the 
//   address.
//
// Failure cases:
//  error popping bufferid or offset from the data stack
//  error calling the routine
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthqueryendevaluate>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthqueryendevaluate ( ?ENDEVALUATE )
//
// C prototype:
//  void dg_forthqueryendevaluate (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 other used as the bufferhandle for the array where the  
//
// Stack action shorthand:
//  (  flag -- )
//                                 bufferhandles are stored.
// Data stack in:
//  flag                          TRUE or FALSE flag
//                                                              
// Action:
//  if the flag is TRUE, this routine moves the current input buffer's current offset
//   to the end of the buffer which will cause the interpreter to skip the rest of the
//   buffer and end the evaluation of this buffer
//
// Failure cases:
//  error in a subroutine
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
        

      <div class=word id=dg_forthtype0string>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthtype0string ( TYPE0$ )
//
// C prototype:
//  void dg_forthtype0string (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( c-addr -- )
// 
// Data stack in:
//  c-addr                        start address of a string
//                                                              
// Action:
//  this displays the c style null terminated character string specified by c-addr
//
// Failure cases:
//  error getting pointer to the data stack
//  c-addr missing from the data stack
//  process doesn't own all the memory in the string
//  error sending character to the display
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
  

      <div class=word id=dg_forthshowlicense>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthshowlicense ( SHOW-LICENSE )  
//
// C prototype:
//  void dg_forthshowlicense (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- )
//                                                            
// Action:
//  Shows the license for this program contained in the file gpl.doc
//  (This function displays the contents of the file gpl.doc)
//
// Failure cases:
//  Can't open gpl.doc.
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthcrlf>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcrlf ( CRLF )  
//
// C prototype:
//  void dg_forthcrlf (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- )
//                                                            
// Action:
//  Writes a CRLF pair to stdout.
//
// Failure cases:
//  not checked
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthgethstdin>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthgethstdin ( GETHSTDIN )  
//
// C prototype:
//  void dg_forthgethstdin (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- hstdin )
//                                                            
// Action:
//  Pushes the file handle for stdin onto the data stack.
//
// Failure cases:
//  not checked
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthgethstdout>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthgethstdout ( GETHSTDOUT )  
//
// C prototype:
//  void dg_forthgethstdout (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- hstdout )
//                                                            
// Action:
//  Pushes the file handle for stdout onto the data stack.
//
// Failure cases:
//  not checked
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthgethstderror>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthgethstderror ( GETHSTDERR )  
//
// C prototype:
//  void dg_forthgethstderror (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- hstderr )
//                                                            
// Action:
//  Pushes the file handle for stderr onto the data stack.
//
// Failure cases:
//  not checked
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthgetfilelength>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthgetfilelength ( GETFILELENGTH )  
//
// C prototype:
//  void dg_forthgetfilelength (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( filehandle -- filelength )
//                                                            
// Action:
//  Pops a file handle off of the data stack, then
//  Pushes the file length of the file onto the data stack.
//
// Failure cases:
//  not checked
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthreadavailabletobuffer>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthreadavailabletobuffer ( FILE&gt;BUF )
//
// C prototype:
//  void dg_forthreadavailabletobuffer (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( filehandle bufferid -- )
//  ( -bufferid- availabledata )
//                                                              
// Action:
//  Pops filehandle and bufferid off the data stack, then
//  reads whatever bytes are currently available from the file and pushes them
//   onto the end of the buffer.
//
// Failure cases:
//  error getting current vocabulary id
//  error getting latest definition execute token
//  error getting pointer to the latest definition 
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthreadwaitforntobuffer>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthreadwaitforntobuffer ( WAITREADN&gt;BUF )
//
// C prototype:
//  void dg_forthreadwaitforntobuffer(Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//     ( filehandle n timeout bufferid -- )
//     ( -bufferid- uptondata )
//                                                              
// Action:
//  pops filehandle, n, timeout, and bufferid off of the data stack then,
//  waits and reads x bytes from the file and push it onto the end of the buffer 
//
// Note:
//  timeout may be ignored on some operating systems
//  (I don't like the idea waiting forever for the OS but that is how the standard
//    CGI file transfer routines work.)
//
// Failure cases:
//  error getting current vocabulary id
//  error getting latest definition execute token
//  error getting pointer to the latest definition 
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthcompilecallcore>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompilecallcore ( COMPILE-CALLCORE )
//
// C prototype:
//  void dg_forthcompilecallcore (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( addr -- )
// 
// Data stack in:
//  addr                          target address not in a buffer
//                                                            
// Action:
//  Compiles a call to the address. 
//
// Failure cases:
//  error popping the offset from the data stack
//  error getting the current compile buffer id
//  error growing the current compile buffer
//  error getting the pointer to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthcompilecallsamebuffer>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompilecallsamebuffer ( COMPILE-CALLSAMEBUFFER )
//
// C prototype:
//  void dg_forthcompilecallsamebuffer (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( offset -- )
// 
// Data stack in:
//  offset                        target 0 based offset in bytes from beginning of 
//                                 buffer
//                                                            
// Action:
//  Compiles a call to the subroutine at an offset in the same buffer as the caller
//
// Failure cases:
//  error popping the offset from the data stack
//  error getting the current compile buffer id
//  error growing the current compile buffer
//  error getting the pointer to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthcompilecallbuffer>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompilecallbuffer ( COMPILE-CALLBUFFER )
//
// C prototype:
//  void dg_forthcompilecallbuffer (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( offset bufferid -- )
// 
// Data stack in:
//  offset                        target 0 based offset in bytes from beginning of 
//                                 buffer
//  bufferid                      target buffer's id
//                                                            
// Action:
//  Compiles a call to the subroutine at an offset in the target buffer which may not 
//   be the same as the caller's buffer.
//
// Note:
//  Do not use this to compile calls to compiling routines that compile to the same
//   buffer. 
//   Use COMPILE-SAFECALLBUFFER instead.
//   This is because the buffer may move while the compiling routine is compiling 
//   to the buffer, invalidating the return address.
//
// Failure cases:
//  error popping the offset from the data stack
//  error getting the current compile buffer id
//  error growing the current compile buffer
//  error getting the pointer to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
        <div class=word id=dg_forthcompilesafecallbuffer>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompilesafecallbuffer ( COMPILE-SAFECALLBUFFER ) 
//
// C prototype:
//  void dg_forthcompilesafecallbuffer (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
// 
// Data stack in:
//  bufferid                      buffer the target routine is in
//  bufferoffset                  offset of the target routine in the buffer
//                                                            
// Action:
//  Compiles a safe call to a subroutine at an offset in a target buffer 
//   onto the end of the current compile buffer. 
//  If the buffer the call was made from moves, this call will return to the correct 
//   place.
//
//  Notes:
//   Compiles:
//     (need to add compile align stack for 3 parameter subroutine)
//    push offset in buffer of return
//    push id of buffer of return
//    push address of jump to offset in buffer code which is after the bufferhandle at 
//     pBHarrayhead
//      (this is the address for the subroutine return)
//      (address calculated when this code compiled)
//
//     (the above is the return stack parameters and return address passed to the 
//      called routine)
//
//  Because address of the jump to buffer routine is calculated when this code is run,
//   the address of the jump to buffer code can change. However, if you change the size 
//   of a bufferhandle, then any precompiled code with safe calls will become invalid 
//   because the offset of the jump buffer code will change. (The jump buffer code is 
//   after the head bufferhandle at pBHarrayhead.)
//
// What happens during a safe call:
//  safe call occurs from a standard dglu subroutine frame
//  the return stack is aligned for a 3 parameter call
//  then 3 parameters are pushed to the return stack for a call to dg_getpbufferoffset 
//  which will calculate the true return address then the address of the jump to buffer 
//  code is pushed to the return stack, when the called routine returns, the return 
//  will go to the jump to buffer code which will calculate the true return address and 
//  jump to it then the control flow jumps to the target routine at its offset in its 
//  buffer
//  
//  return stack looks like this:
//    align space
//    return offset
//    return bufferid
//    addr of jumptobuffer code
//
// Possibility:
//  Another way to do this is to compile code that calculates the address of the jump 
//   to buffer routine when the compiled code runs. Then the compiled safe call could 
//   be used in a shared library without run time linking or binding. Of course this 
//   still assumes the buffer ids and offsets of the called routines do not change.
// 
// Failure cases:
//  error popping the bufferoffset and bufferid from the data stack
//  error getting the current compile buffer id
//  error growing the current compile buffer
//  error getting the pointer to the current compile buffer
//  offset is off the end of the buffer
//  subroutine is too far away to call, > 0x80000000 away in the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcompiletoxtp>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompiletoxtp ( COMPILE->XTP )
//
// C prototype:
//  void dg_forthcompiletoxtp(Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- )
//                                                            
// Action:
//  Compiles a pop from the datastack. Then compiles a jump to the address that was
//    popped from the data stack 
//
// Failure cases:
//  error compiling a pop from the data stack
//  error compiling a jump to the address popped from the data stack
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcscan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcscan ( CSCAN ) 
//
// C prototype:
//  void dg_forthcscan (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand: 
//  ( caddr1 u1 value -- index )
//
// Data stack in:
//  caddr1                        pointer to string to search
//  u1                            length of string at caddr1 in characters (bytes)
//  value                         value of byte to scan for in string
//
// Data stack out:
//  index                         index in range of 0 to u1 - 1 of first match in 
//                                 string or -1 if no match is found
//                                                            
// Action:
//  Searches the memory at caddr1 for u1 characters for the first occurence of the 
//   value 
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow
//  process doesn't own the memory in the string
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthscan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthscan ( SCAN ) 
//
// C prototype:
//  void dg_forthscan (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( caddr1 u1 value -- index )
// 
// Data stack in:
//  caddr1                        pointer to string to search
//  u1                            length of string at caddr1 in characters (bytes)
//  value                         value of uint64 to scan for in string
//
// Data stack out:
//  index                         index in range of 0 to u1 - 1 of first match in 
//                                 string or -1 if no match is found
//                                                            
// Action:
//  Searches the memory at caddr1 for u1 characters for the first occurence of the 
//   value 
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow
//  process doesn't own the memory in the string
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
    

      <div class=word id=dg_forthdoprompt>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdoprompt ( DOPROMPT )
//
// C prototype:
//  void dg_forthdoprompt (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the 
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( -- )
//
// Action:
//  checks the script processing state, the number of errors, and displays a prompt
//
// Failure cases:
//  error getting script processing state
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthbswap>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbswap ( BSWAP )
//
// C prototype:
//  void dg_forthbswap (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( u -- u' )
//
// Data stack in:
//  u              UINT64            64 bit value
//
// Data stack out:
//  u'             UINT64            64 bit value with bytes reversed
//
// Action:
//  reverses the byte order of the bytes in u
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthcompilebranch>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompilebranch ( COMPILE-BRANCH )
//
// C prototype:
//  void dg_forthcompilebranch (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the  
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( branchtype -- afterbranchoffset )
// 
// Data stack in:
//  branchtype                    branch type which is one of:
//                                  DG_BRANCHTYPE_OVERFLOW = 0,
//                                  DG_BRANCHTYPE_NOOVERFLOW = 1,
//                                  DG_BRANCHTYPE_ULESSTHAN = 2,
//                                  DG_BRANCHTYPE_UGREATERTHANOREQUAL = 3,
//                                  DG_BRANCHTYPE_EQUAL = 4,
//                                  DG_BRANCHTYPE_NOTEQUAL = 5,
//                                  DG_BRANCHTYPE_ULESSTHANOREQUAL = 6,
//                                  DG_BRANCHTYPE_UGREATERTHAN = 7,
//                                  DG_BRANCHTYPE_MINUS = 8,
//                                  DG_BRANCHTYPE_PLUS = 9,
//                                  DG_BRANCHTYPE_PARITYEVEN = 10,
//                                  DG_BRANCHTYPE_PARITYODD = 11,
//                                  DG_BRANCHTYPE_LESSTHAN = 12,
//                                  DG_BRANCHTYPE_GREATERTHANOREQUAL = 13,
//                                  DG_BRANCHTYPE_LESSTHANOREQUAL = 14,
//                                  DG_BRANCHTYPE_GREATERTHAN = 15,
//                                  DG_BRANCHTYPE_ALWAYS = 16,
//                                  DG_BRANCHTYPE_NEVER = 17 or greater,
//                                  DG_BRANCHTYPE_CARRYSET = 2,
//                                  DG_BRANCHTYPE_CARRYCLEAR = 3,
//                                  DG_BRANCHTYPE_ZERO = 4,
//                                  DG_BRANCHTYPE_NOTZERO = 5
//
// Data stack out:
//  afterbranchoffset             current offset in bytes in current compile buffer 
//                                 just after branch has been compiled
//
// Action:
//  Compiles an unresolved branch, which is branch to instruction after branch.
//  ( branch displacement is 0)
//
// Note:
//  The branch type constants are defined in the X86-WORDLIST as condition
//   codes. For example, CS = 2.
//
// Failure cases:
//  data stack underflow
//  can't get the current compile buffer id
//  can't push the branch code to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthresolvecompiledbranch>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthresolvecompiledbranch ( RESOLVE-BRANCH )
//
// C prototype:
//  void dg_forthresolvebranch (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( targetoffset afterbranchoffset -- )
// 
// Data stack in:
//  targetoffset                  target offset in bytes from beginning of current
//                                 compile buffer
//  afterbranchoffset             current offset in bytes in current compile buffer 
//                                 just after target branch was compiled
//
// Action:
//  Resolves target branch to branch to target offset in current compile buffer
//
// Note: 
//
// Failure cases:
//  data stack underflow
//  can't get the current compile buffer id
//  can't push the branch code to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthosquotes>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthosquotes ( OS" )
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//            
// Current input buffer's current offset in:
//  "somestuff&lt;quotes&gt;morestuff"
//
// Current input buffer's current offset out:
//  "morestuff"
//                                                              
// Action:
//  Moves the current input buffers' current offset pointer to the next character 
//   after the next &quot;, the next line terminator delimiter, or the end of the 
//   buffer, whichever comes first. The target string is the characters skipped except 
//   for the &quot; or line terminator delimiter.
//  Then copies the target string except for the leading delimiter to the current 
//   compile buffer and compiles code to push its run time address and length to the 
//   data stack.
//
// Note:
//  A line terminator delimiter is one of:
//   c shorthand      ascii code    name  
//   '\n'             0x0a          &lt;line feed&gt;
//   '\v'             0x0b          &lt;vertical tab&gt;
//   '\b'             0x08          &lt;back space&gt;
//   '\r'             0x0c          &lt;carriage return&gt;
//   '\f'             0x0f          &lt;form feed&gt;
//
// Failure cases:
//  error getting the current input buffer id
//  error getting the pointer to the current input buffer
//  error getting the current compile buffer id
//  error growing the current compile buffer
//  error getting the pointer to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////
     
</pre>
      </div>
      
      <div class=word id=dg_fortho0quotes>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_fortho0quotes ( O0" )
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//            
// Current input buffer's current offset in:
//  "somestuff&lt;quotes&gt;morestuff"
//
// Current input buffer's current offset out:
//  "morestuff"
//                                                              
// Action:
//  Moves the current input buffers' current offset pointer to the next character after 
//   the next &quot;, the next line terminator delimiter, or the end of the buffer,
//   whichever comes first. The target string is the characters skipped except for the
//   &quot; or line terminator delimiter.
//  Then copies the target string except for the leading delimiter to the current 
//   compile buffer, puts a 0 byte after the copied string, and then compiles code to 
//   push its run time address and length to the data stack.
//
// Note:
//  A line terminator delimiter is one of:
//   c shorthand      ascii code    name  
//   '\n'             0x0a          &lt;line feed&gt;
//   '\v'             0x0b          &lt;vertical tab&gt;
//   '\b'             0x08          &lt;back space&gt;
//   '\r'             0x0c          &lt;carriage return&gt;
//   '\f'             0x0f          &lt;form feed&gt;
//
// Failure cases:
//  error getting the current input buffer id
//  error getting the pointer to the current input buffer
//  error getting the current compile buffer id
//  error growing the current compile buffer
//  error getting the pointer to the current compile buffer
//  
// //////////////////////////////////////////////////////////////////////////////////////     
</pre>
      </div>
            
      
      <div class=word id=dg_forthpagesize>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthpagesize ( PAGESIZE )
//
// C prototype:
//  void dg_forthpagesize (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
// Stack action shorthand:
//  ( -- systempagesize )
//
// Action:
//  Gets the operating system memory allocation page size. 
// 
// Note:
//  On some operating systems, memory allocation sizes must be a
//   multiple of the system page size. When Diaperglu allocates memory for buffers,
//   it automatically rounds the requested growby and maxsize to the nearest highest
//   system page size.
//
// Failure cases:
//  data stack is full
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthroundup>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthroundup ( ROUNDUP )
//
// C prototype:
//  void dg_forthroundup (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
// Stack action shorthand:
//  ( n unitsize -- nearesthighestmultiple )
//
// Action:
//  Gets the nearest highest multiple of unitsize closest to n.
//   If unitsize is 0, this returns n.
//   If n is 0, this returns unitsize.
//   If round up calculation would overflow a UINT64, this rounds down, using the 
//    closest multiple of unitsize &lt;= n instead;
//   Otherwise this returns the closest multiple of unitsize &gt;= n
// 
// Note:
//  On some operating systems, memory allocation sizes must be a
//   multiple of the system page size. When Diaperglu allocates memory for buffers,
//   it automatically rounds the requested growby and maxsize to the nearest highest
//   system page size using this calculation.
//
// Failure cases:
//  data stack underflow
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcallprocaddress>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
//  dg_forthcallprocaddress ( CALLPROC CALLCDECL CALLSTDCALL CALLC++MEMBER )
//
// C prototype:
//  void dg_forthcallprocaddress (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.                          
//
// Stack action shorthand:
//  ( paramn paramn-1 paramn-2 ... param1 n procaddress -- returnvalue )
//
// Data stack in:
//  paramn paramn-1 paramn-2 ... param1      integer parameters for the proceedure
//  n                                        number of parameters for the proceedure
//  procaddress                              address to call
//              
// Data stack out:
//  returnvalue                              return value from the proceedure
//                                            (whatever was in rax for x86 64bit AMD-V)
//                                              
// Action:
//  Removes n, procaddress, and all the parameters from the datastack and sets up a
//   c style call. In 32 bit address mode the parameters are set up on the return 
//   stack.
//  In 64 bit address mode, the first 6 integer parameters are passed in registers  
//   and the rest are passed on the return stack. 
//  Calls the procedure in a way which does not care how the procedure leaves the 
//   return stack
//  Pushes the return value from the procedure to the data stack
//
// Note:
//  Even void procedures return a value, just ignore it. It will be whatever was in 
//   EAX/RAX.
//  If you are calling a C++ member function, push the object handle onto the data 
//   stack after the parameters and treat the object handle as an additional parameter 
//   when determining the parameter count. In other words n is the number of regular 
//   parameters + 1. Unless, (according to a rumor on some message boards) you have
//   a non trivial copy thing (passing out more than UINT128?), then a pointer to 
//   the return value or copy constructor destructor thing is passed in the
//   first parameter followed by the object handle in the second parameter.
//  According to AMD64 ABI Draft 0.3 – July 17, 2013 – 15:26:
//   integer parameters can be one of:
//    _Bool, char, short, int, long and long long
//   (basically any integer parameters 64 bits and less)
//   (you can probably pass a 128 bit integer input parameter by using 2 data stack
//    parameters where the high 64 bits get pushed to the data stack first)
// 
// Failure cases:
//  error getting a pointer to the data stack
//  n or procaddress is missing from the data stack
//  there aren't n parameters on the data stack
//  exception calling the proceedure, address or parameters may be incorrect
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthcalldfpprocaddress>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
//  dg_forthcalldfpprocaddress ( CALLDFPPROC )
//
// C prototype:
//  void dg_forthcalldfpprocaddress (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.                          
//
// Stack action shorthand:
//  ( dfpparamm dfpparamm-1 ... dfpparam1
//    paramn paramn-1 ... param1
//    m n procaddress -- dfpreturnvalue )
//
// Data stack in:
//  dfpparamm dfpparamm-1 ... dfpparam1      floating point parameters for the 
//                                            procedure
//  paramn paramn-1 ... param1               parameters for the procedure
//  m                                        number of floating point parameters for
//                                            the procedure
//  n                                        number of integer parameters for the 
//                                            procedure
//  procaddress                              address to call
//              
// Data stack out:
//  dfpreturnvalue                           floating point return value from the 
//                                            procedure (whatever was in xmm0 for 
//                                            x86 64 bit AMD-V)
//                                              
// Action:
//  Removes procaddress, n, m, and all the parameters from the datastack and sets up 
//   a c style call to the proceedure
//  Calls the proceedure in a way which does not care how the proceedure leaves the 
//   return stack
//  Pushes the double float return value from the procedure to the data stack
//
// Note:
//  Even void procedures return a value, just ignore it, (which means DROP it).
//  If you are calling a C++ member function, push the object handle onto the data 
//   stack after the parameters and treat the object handle as an additional 
//   parameter when determining the parameter count. In other words n is the 
//   number of regular parameters + 1.
//  If you are calling a c function with both floating point and integer input
//   parameters, push the floating point parameters to the data stack in reverse
//   order first followed by the integer parameters in reverse order.
//  The Win64 calling convention allows for having floating point and integer
//   parameters in any order. This function does not support doing this at this
//   time. You can use the assembler if you need this. - August 1, 2022
//  According to AMD64 ABI Draft 0.3 – July 17, 2013 – 15:26:
//   floating point parameters can be one of:
//    float, double, _Decimal32, _Decimal64 and __m64
//   and integer parameters can be one of:
//    _Bool, char, short, int, long and long long
//    (basically any integer parameter 64 bits or less)
//   (you can probably pass a 128 bit integer input parameter by using 2 data stack
//    parameters where the high 64 bits get pushed to the data stack first)
//
// Failure cases:
//  error getting a pointer to the data stack
//  n or procaddress is missing from the data stack
//  there aren't n parameters on the data stack
//  exception calling the proceedure, address or parameters may be incorrect
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcallprocaddressretuint128>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcallprocaddressretuint128
//  ( CALLPROCRETUINT128 CALLCDECLRETUINT128 CALLSTDCALLRETUINT128
//    CALLC++MEMBERRETUINT128 )
//
// C prototype:
//  void dg_forthcallprocaddressretuint128 (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where 
//                                 the other bufferhandles are stored.                          
//
// Stack action shorthand:
//  ( paramn paramn-1 paramn-2 ... param1 n procaddress
//     -- returnvaluelo returnvaluehi )
//
// Data stack in:
//  paramn paramn-1 paramn-2 ... param1      parameters for the proceedure
//  n                                        number of parameters for the proceedure
//  procaddress                              address to call
//              
// Data stack out:
//  returnvalue                              return value from the proceedure
//                                             64 bits low from RAX 2nd from top
//                                             64 bits high from RDX on top
//                                              
// Action:
//  removes n, procaddress, and all the parameters from the datastack and sets up a
//  call on the return stack to the proceedure
//  calls the proceedure in a way which does not care how the proceedure leaves the
//   return stack
//  pushes the 128 bit return value from the proceedure to the data stack
// 
// Note:
//  If you are calling a C++ member function, push the object handle onto the data
//   stack after the parameters and treat the object handle as an additional parameter
//   when determining the parameter count. In other words n is the number of regular
//   parameters + 1. Unless, (according to a rumor on some message boards) you have
//   a non trivial copy thing (passing out more than UINT128?), then a pointer
//   to the return value or copy constructor destructor thing is passed in the
//   first parameter followed by the object handle in the second parameter.
//  According to AMD64 ABI Draft 0.3 – July 17, 2013 – 15:26:
//   integer input parameters can be one of:
//    _Bool, char, short, int, long and long long
//   (basically any integer parameters 64 bits and less)
//   (you can probably pass a 128 bit integer input parameter by using 2 data stack
//    parameters where the high 64 bits get pushed to the data stack first)
//
// Failure cases:
//  error getting a pointer to the data stack
//  n or procaddress is missing from the data stack
//  there aren't n parameters on the data stack
//  exception calling the proceedure, address or parameters may be incorrect
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthcallcppmemberfunction>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcallcppmemberfunction ( CALLWIN32C++MEMBER )
//
// C prototype:
//  void dg_forthcallcppmemberfunction (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.                          
// 
// Stack action shorthand:
//  ( paramn paramn-1 paramn-2 ... param1 n procaddress -- returnvalue )
//  ( param1 is the object handle )
// 
// Data stack in:
//  paramn paramn-1 paramn-2 ... param1      parameters for the proceedure
//                                             param1 is the object handle
//  n                                        number of parameters for the proceedure
//                                            the object handle is included in the 
//                                            parameter count
//  procaddress                              address to call
//              
// Data stack out:
//  returnvalue                              return value from the proceedure 
//                                            (whatever was in eax)
//                                              
// Action:
//  ( this does a call using the win32 c++ member function calling convention )
//  removes n, procaddress, and all the parameters from the datastack and sets up a
//  call with all parameters except the object handle on the return stack
//    and the object handle in register ECX
//  calls the proceedure 
//  pushes the return value from the proceedure to the data stack
//
// Note:
//  Even void proceedures return a value, just ignore it. It will be whatever was in 
//   eax.
//  Treat the object handle as an additional parameter when determining the 
//   parameter count. In other words n is the number of regular parameters + 1.
// 
// Failure cases:
//  error getting a pointer to the data stack
//  n or procaddress is missing from the data stack
//  there aren't n parameters on the data stack
//  exception calling the proceedure, address or parameters may be incorrect
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthudmslashmod>
<pre>     
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthudmslashmod ( UDM/MOD )
//
// C prototype:
//  void dg_forthudmslashmod (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( ud u1 -- ud2 rem ) 
//
// Datastack in:
//  ud              double UINT64 to be divided (top number) (64 bits lo, 64 bits hi)
//  u1              single UINT64 used to divide (bottom number)
//
// Datastack out:
//  u2              double UINT64 quotient (64 bits lo, 64 bits hi)
//  u3              single UINT64 remainder
//                                                              
// Action:
//  divides ud by u1 giving ud2 remainder u3
//
// Failure cases:
//  error getting pointer to the datastack
//  ud or u1 is missing from the data stack
//  u1 is 0  - no error is reported and -1 -1 is returned
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>

      
      <div class=word id=dg_forthodoes>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthodoes ( ODOES&gt; )
//
// C prototype:
//  void dg_forthodoes (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- )
//
// Action:
//  compiles code to change the compile routine of the latest definition to call the 
//   code compiled immediately after what this ODOES&gt; compiles
//  compiles a return
//  ( leaves the offset and bufferid from CREATE alone! )
//
// NOTE:
//  ODOES&gt; is used after a CREATE in a colon definition to change the compile 
//   routine from pushaddressorcompilepushaddress to the user defined code following 
//   ODOES&gt; up until the semicolon.
//  
//  The offset bufferid from the CREATE is passed in to the user routine so to the 
//   code following ODOES&gt; it looks like this:
//
//  void namelessusercompileroutine (Bufferhandle* pBHarrayhead)
//                                  ( offset bufferid -- )
//  
//  The code between CREATE and ODOES&gt; is usually used to allocate and initialize 
//   data field memory for the new definitions.
//  Unlike DOES&gt;, this routine passes the offset and bufferid instead of an address.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>

      <div class=word id=dg_forthpackdf>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthpackdf ( PACKDF )
//
// C prototype:
//  void dg_forthpackdf (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the  
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( mantissa exponent-n sign-f -- df )
//
//   mantissa              UINT64  52 bit mantissa of fractional part of df.
//                                 Bits are left aligned and only the lower 52 bits 
//                                 are used.
//
//   exponent-n            INT64   Normal exponents go from -1022 to +1023
//                                 Exponents -1023 and +1024 have special meaning.
//
//   sign-f                INT64   0 means the number is positve, -1 means the number 
//                                  is negative
//
//   df                    double  64 bit floating point number in the standard IEEE
//                                  floating point format. The bits are in the same 
//                                  order in memory as the standard on an x86, 
//                                  which is:
//                                   The 8 bytes are ordered low byte to high byte.
//                                   Highest bit is a sign bit (which is highest bit 
//                                    of high byte)
//                                   Next highest 11 bits are the the exponent, where 
//                                    a value of 1023 is 0. 
//                                   The rest is the mantissa.
//
// Action:
//  Packs the parts of an IEEE 64 bit floating point number into it's standard 
//   format.
//
// NOTE:
//   Each double float on the data stack is 64 bits and occupies one 64 bit data cell.
//
//   The true absolute value of an IEEE double using a normal exponent is 
//    (1 + (mantissa/ (2 ^ 52))) * (2 ^ exponent)
//    or you can think of it in binary using 1.mantissa shifted left or right by the 
//    exponent.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthunpackdf>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthunpackdf ( UNPACKDF )
//
// C prototype:
//  void dg_forthpackdf (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the 
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( df -- mantissa exponent-n sign-f )
//
//   mantissa              UINT64  52 bit mantissa of fractional part of df.
//                                 Bits are left aligned and only the lower 52 bits 
//                                 are used.
//
//   exponent-n            INT64   Normal exponents go from -1022 to +1023
//                                 Exponents -1023 and +1024 have special meaning.
//
//   sign-f                INT64   0 means the number is positve, -1 means the number 
//                                  is negative
//
//   df                    double  64 bit floating point number in the standard IEEE
//                                  floating point format. The bits are in the same  
//                                  order in memory as the standard on an x86, 
//                                  which is:
//                                   The 8 bytes are ordered low byte to high byte.
//                                   Highest bit is a sign bit (which is highest bit 
//                                    of high byte)
//                                   Next highest 11 bits are the the exponent, where 
//                                    a value of 1023 is 0. 
//                                   The rest is the mantissa.
//
// Action:
//  Unpacks the parts of an IEEE 64 bit floating point number in standard format into 
//   it's parts.
//
// NOTE:
//   Each double float on the data stack is 64 bits and occupies one 64 bit data cell.
//
//    The true absolute value of an IEEE double using a normal exponent is 
//     (1 + (mantissa/ (2 ^ 52))) * (2 ^ exponent)
//    or you can think of it in binary using 1.mantissa shifted left or right by the 
//    exponent.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
    
      <div class=word id=dg_forthcodescomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodescomma ( CODE-S, )
//
// C prototype:
//  void dg_forthcodescomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the 
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( addr length -- )
//
//   caddr                 UINT64  start address of an unsigned character string 
//
//   length                INT64   length of an unsigned character string
//
//
// Action:
//  Pushes a copy of the unsigned character string onto the end of the current compile 
//   buffer.
//
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodeu8comma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodeu8comma ( CODE-U8, )
//
// C prototype:
//  void dg_forthcodeu8comma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the  
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( addr length -- )
//
//   u                     UINT64  UINT64 representation of an 8 bit integer
//
//
// Action:
//   Pushes the unsigned character onto the end of the current compile buffer.
//
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodeu16comma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodeu16comma ( CODE-U16, )
//
// C prototype:
//  void dg_forthcodeu16comma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the 
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( addr length -- )
//
//   u                     UINT64  UINT64 representation of a 16 bit integer 
//
//
// Action:
//   Pushes the unsigned 16 bit integer onto the end of the current compile buffer.
//
//
// Note:
//  Stores the number in the corrent endianness format of the machine Diaperglu is 
//   running on.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodeu32comma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodeu32comma ( CODE-U32, )
//
// C prototype:
//  void dg_forthcodeu32comma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the 
//                                  other  bufferhandles are stored.
//
// Stack action shorthand:
//   ( addr length -- )
//
//   u                     UINT64  UINT64 representation of a 32 bit integer
//
//
// Action:
//   Pushes the unsigned 32 bit integer onto the end of the current compile buffer.
//
//
// Note:
//  Stores the number in the corrent endianness format of the machine Diaperglu is 
//   running on.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthcodeu64comma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodeu64comma ( CODE-U64, )
//
// C prototype:
//  void dg_forthcodeu64comma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the 
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( addr length -- )
//
//   ud                    UINT64  64 bit integer
//
//
// Action:
//   Pushes the unsigned 64 bit integer onto the end of the current compile buffer.
//
//
// Note:
//  Stores the number in the corrent endianness format of the machine Diaperglu is 
//   running on.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthcodeallot>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodeallot ( CODE-ALLOT, )
//
// C prototype:
//  void dg_forthcodeallot (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead     pointer to a Bufferhandle structure which is 
//                                  used as the bufferhandle for the array where the 
//                                  other bufferhandles are stored.
//
// Stack action shorthand:
//   ( n -- )
//   ( -currentcompilebuffer- +nbytes )
//
//   n                             signed 64 bit integer
//
//
// Action:
//   If n &gt; 0 then grows the current compile buffer n bytes.
//   If n &lt; 0 then shrinks the current compile buffer |n| bytes.
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
     
     
      <div class=word id=dg_forthdoterrorline>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdoterrorline ( .ERRORLINE )
//
// C prototype:
//  void dg_forthdoterrorline (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- )
//
// Action:
//   Sends a new line character to stdout.
//   Sends the data in the DG_ERRORLINE_BUFFERID buffer to stdout.
//   Sends a new line character to stdout.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthohere>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthohere ( OHERE )
//
// C prototype:
//  void dg_forthohere (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where
//                                 the other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- currentoffset )
//
// Action:
//   Pushes the in use length of the current compile buffer to the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthdglibstring>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdglibstring ( DGLIB$ )
//
// C prototype:
//  void dg_forthdglibstring (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where
//                                 the other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -$- dglibfilename$ )
//
// Action:
//   Pushes the file name of the diaperglu shared library to the string stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthlobit>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthlobit ( LOBIT )
//
// C prototype:
//  void dg_forthlobit (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u -- lowestbitpos )
//
//   u                            unsigned 64 bit integer
//   lowestbitpos                 0 based index of lowest set bit
//                                 -1 if u is 0
//
// Action:
//   Replaces the unsigned 64 bit integer on the top of the data stack with the index
//    of the lowest bit set in the integer. If u is 0, u is replaced with -1.
//   For example, if u is 0x0A (...1010), the result is 1.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthulo1bitpos>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthulo1bitpos ( ULO1BITPOS )
//
// C prototype:
//  void dg_forthulo1bitpos (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( uvaluein uth -- bitposition )
//
//   uvaluein                     unsigned 64 bit integer
//   uth                          which set bit to look for
//   bitposition                  index of uth set bit from 0 to 63 in uvaluein
//
// Action:
//   Scans uvaluein from bit position 0 to bit position 63 for the uth set bit.
//   The 0 based index of the uth set bit in uvaluein is returned. 
//   If uth is greater than 63, or if uth is 0, or if there are not enough set bits
//    then DECIMAL 64 ( HEX 40 ) is returned.
//
//   For example:
//    HEX 9 2 ULO1BITPOS returns 3
//    HEX 5 2 ULO1BITPOS returns 2
//    HEX A 2 ULO1BITPOS returns 3
//    HEX A 1 ULO1BITPOS returns 1
//    HEX 5 1 ULO1BITPOS returns 0
//    HEX 5 0 ULO1BITPOS returns 40
//    HEX 5 3 ULO1BITPOS returns 40
// 
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthulo1bits>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthulo1bits ( ULO1BITS )
//
// C prototype:
//  void dg_forthulo1bits (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( uvaluein usetbitstoget -- uvalueout )
//
//   uvaluein                     unsigned 64 bit integer
//   usetbitstoget                number of set bits to get
//   uvalueout                    uvaluein containing lowest usetbitstoget set bits
//
// Action:
//   Clears all bits of uvaluein except for the lowest usetbitstoget set bits.
//   For example, if you do HEX F51 3 ULOBITS, you will get the 3 lowest set bits back
//    which gives 51
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthulobits>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthulobits ( ULOBITS )
//
// C prototype:
//  void dg_forthulobits (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( uvaluein ubitstoget -- uvalueout )
//
//   uvaluein                     unsigned 64 bit integer
//   ubitstoget                   number of set bits to get
//   uvalueout                    uvaluein containing lowest usetbitstoget set bits
//
// Action:
//   Clears all bits of uvaluein except for the lowest ubitstoget bits.
//   For example, if you do HEX F51 5 ULOBITS, you will get the 5 lowest bits back
//    which gives 11
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthulomask>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthulomask ( ULOMASK )
//
// C prototype:
//  void dg_forthulomask (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( ubits -- mask )
//
//   ubits                        number of bits in mask
//   mask                         a value with the lowest ubits bits set
//
// Action:
//   Returns a value with the number of chosen bits set. Bit positions 0 through 
//    ubits-1 are set, all other bit positions are clear.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthtwototheu>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthtwototheu ( 2^U )
//
// C prototype:
//  void dg_forthtwototheu (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u -- 2^u )
//
//   u                            64 bit unsigned integer
//   2^u                          2 raised to the u power 
//
// Action:
//   Returns 2 multiplied by itself u times. If u is 0, 1 is returned. If u is greater
//    than 63, the largest unsigned integer possible is returned. 
//
// Note:
//   Largest unsigned integer possible has all bits set. This is also -1.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>

      
      <div class=word id=dg_forthhibit>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthhibit ( HIBIT )
//
// C prototype:
//  void dg_forthhibit (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u -- highestbitpos )
//
//   u                            unsigned 64 bit integer
//   highestbitpos                0 based index of highest set bit
//                                 -1 if u is 0
//
// Action:
//   Replaces the unsigned 64 bit integer on the top of the data stack with the index
//    of the highest bit set in the integer. If u is 0, u is replaced with -1.
//   For example, if u is 0x0A (...1010), the result is 3.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthcountbits>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcountbits ( COUNTBITS )
//
// C prototype:
//  void dg_forthcountbits (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u -- bitcount )
//
//   u                            unsigned 64 bit integer
//   bitcount                     number of 1s in u
//
// Action:
//   Replaces the unsigned 64 bit integer on the top of the data stack with the
//    number of bits set to 1 in the integer. For example: HEX A001000200030004
//    becomes 7.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbitset>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbitset ( BITSET )
//
// C prototype:
//  void dg_forthbitset (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u bitpos -- u' )
//
// Data stack in:
//   u                            unsigned 64 bit integer
//   bitpos                       0 based index of bit in u
//
// Data stack out:
//   u'                           u with bit at index bitpos set
//
// Action:
//   Pops u and bitpos off the stack, then changes the bit at index bitpos to 1 if
//     it isn't 1 already, then pushes the result back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbitclr>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbitclr ( BITCLR )
//
// C prototype:
//  void dg_forthbitclr (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u bitpos -- u' )
//
// Data stack in:
//   u                            unsigned 64 bit integer
//   bitpos                       0 based index of bit in u
//
// Data stack out:
//   u'                           u with bit at index bitpos cleared
//
// Action:
//   Pops u and bitpos off the stack, then changes the bit at index bitpos to 0 if it
//     isn't 0 already, then pushes the result back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbitnot>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbitnot ( BITNOT )
//
// C prototype:
//  void dg_forthbitnot (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u bitpos -- u' )
//
// Data stack in:
//   u                            unsigned 64 bit integer
//   bitpos                       0 based index of bit in u
//
// Data stack out:
//   u'                           u with bit at index bitpos toggled
//
// Action:
//   Pops u and bitpos off the stack, then if the bit at index bitpos is 0, the bit
//     is changed to 1, otherwise the bit is changed to 0. Then the result is pushed
//     back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthumax>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthumax ( UMAX )
//
// C prototype:
//  void dg_forthumax (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u1 u2 -- u1oru2 )
//
// Data stack in:
//   u1                           unsigned 64 bit integer
//   u2                           unsigned 64 bit integer
//
// Data stack out:
//   u1oru2                       greater of u1 or u2
//
// Action:
//   Pops u1 and u2 off the stack, then pushes whichever of u1 or u2 has the greater
//     unsigned value back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthumin>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthumin ( UMIN )
//
// C prototype:
//  void dg_forthumin (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u1 u2 -- u1oru2 )
//
// Data stack in:
//   u1                           unsigned 64 bit integer
//   u2                           unsigned 64 bit integer
//
// Data stack out:
//   u1oru2                       lesser of u1 or u2
//
// Action:
//   Pops u1 and u2 off the stack, then pushes whichever of u1 or u2 has the lesser
//     unsigned value back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthulessthanequals>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthulessthanequals ( U&lt;= )
//
// C prototype:
//  void dg_forthulessthanequals (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u1 u2 -- flag )
//
// Data stack in:
//   u1                           unsigned 64 bit integer
//   u2                           unsigned 64 bit integer
//
// Data stack out:
//   flag                         TRUE if u1 <= u2, otherwise FALSE
//
// Action:
//   Pops u1 and u2 off the stack, then pushes TRUE if unsigned u1 is less than or
//     equal to u2, otherwise pushes FALSE back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthugreaterthanequals>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthugreaterthanequals ( U&gt;= )
//
// C prototype:
//  void dg_forthugreaterthanequals (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u1 u2 -- flag )
//
// Data stack in:
//   u1                           unsigned 64 bit integer
//   u2                           unsigned 64 bit integer
//
// Data stack out:
//   flag                         TRUE if u1 >= u2, otherwise FALSE
//
// Action:
//   Pops u1 and u2 off the stack, then pushes TRUE if unsigned u1 is greater than or
//     equal to u2, otherwise pushes FALSE back onto the data stack.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthtouleb128>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthtouleb128 ( &gt;ULEB128 )
//
// C prototype:
//  void dg_forthtouleb128 (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u -- uleb128lo uleb128hiandcount )
//
//   u                            unsigned 64 bit integer
//   uleb128lo                    first 8 low order bytes of the uleb128
//   uleb128hiandcount            last 7 high order bytes of the uleb128 and the count
//
// Action:
//   Replaces the unsigned 64 bit integer on the top of the data stack with a 128 bit
//    unsigned integer that holds the uleb128 representation of the integer as a high
//    counted byte string. In other words, every 7 bits of u starting with the 7 low
//    order bits are put into the bytes of the result from low to high. The highest bit
//    of the result bytes are set except for the last result byte converted. After the
//    first 7 bits of u are converted, the conversion only continues if there are higher
//    bits in u with 1 set.
//   For example, if u is 0x40, the count byte of uleb128hiandcount is 1 and the
//    first byte of uleb128lo is 0x40. If u is 0x80, then the count byte of
//    uleb128hiandcount is 2 and the lowest byte is uleb128lo is 0x80 and the second
//    lowest byte uleb128lo is 0x01. If u is 0x81, then the count byte is of
//    uleb128hiandcount is 2 and the lowest byte of uleb128lo is 0x81 and the second
//    lowest byte of uleb128lo is 0x01.
//
// Failure cases:
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthhctwostore>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthhctwostore ( HC2! )
//
// C prototype:
//  void dg_forthhctwostore (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( uleb128lo uleb128hiandcount pdestination -- )
//
//   uleb128lo                   first 8 low order bytes of the uleb128
//   uleb128hiandcount           last 7 high order bytes of the uleb128 and the count
//   pdestination                pointer to the destination
//
// Action:
//   Stores the uleb128 hi counted string to the destination. Only the count
//    number of bytes are written.
//
// Note:
//  The 128 bit high counted string format stores byte strings in a 128 bit unsigned
//   integer with the first byte of the string in the lowest 8 bits of the unsigned
//   integer. The number of bytes in the string is stored in the highest 8 bits of the
//   unsigned integer.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      
      
      <div class=word id=dg_forthdrshift>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdrshift ( DRSHIFT )
//
// C prototype:
//  void dg_forthdrshift (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u128lo u128hi shiftcount -- u128lo' u128hi' )
//
//   u128lo                      low 64 bits of a 128 bit value
//   u128hi                      high 64 bits of a 128 bit value
//   shiftcount                  number of bits to shift
//
// Action:
//  Logically shifts the 128 bit value to the right shiftcount bits. Zeros are shifted
//   in from the left. This means the bits are shifted from high to low.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthdlshift>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdlshift ( DLSHIFT )
//
// C prototype:
//  void dg_forthdlshift (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( u128lo u128hi shiftcount -- u128lo' u128hi' )
//
//   u128lo                      low 64 bits of a 128 bit value
//   u128hi                      high 64 bits of a 128 bit value
//   shiftcount                  number of bits to shift
//
// Action:
//  Logically shifts the 128 bit value to the left shiftcount bits. Zeros are shifted
//   in from the right. This means the bits are shifted from low to high.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthdarshift>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdarshift ( DARSHIFT )
//
// C prototype:
//  void dg_forthdarshift (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( n128lo n128hi shiftcount -- n128lo' n128hi' )
//
//   n128lo                      low 64 bits of a 128 bit value
//   n128hi                      high 64 bits of a 128 bit value
//   shiftcount                  number of bits to shift
//
// Action:
//  Arithmetically shifts the signed 128 bit value to the right shiftcount bits.
//   The sign bit is copied and shifted in from the left. The sign bit is the highest
//   bit. This means the bits are shifted from high to low.
//   (This lets you divide signed 128 bit numbers by powers of 2.)
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthbuftodotobuf>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbuftodotobuf ( BUF&gt;NEW.OBUF )
//
// C prototype:
//  void dg_forthbuftodotobuf (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( rawcodebufid exportsymbollisthlistid, exportsymbollistelementid -- dotobufid )
//
//   rawcodebufid                buffer id of buffer containing raw code
//   exportsymbollisthlistid     hlist id of hlist containing export symbol list
//   exportsymbollistelementid   parent element id of export symbol list
//   dotobufid                   buffer id of buffer containing the .o file image
//
// Action:
//  Takes the raw code buffer and an export symbol list and generates a .o file image.
//  The symbol list is a list of name value pairs where the name is the symbol name,
//   and the value is an 8 byte integer representing an offset from the start of the
//   rawcodebufid buffer.
//  The function of this word will probably change, like doing more than just
//   export offset symbols... so it might change. Also Mac OS keeps changing how
//   they do stuff at this level. 4/6/2020 J.N.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthbuftodotofilestring>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbuftodotofilestring ( BUF&gt;.OFILE$ )
//
// C prototype:
//  void dg_forthbuftodotofilestring (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( rawcodebufid exportsymbollisthlistid, exportsymbollistelementid -- )
//  ( filename$ -$- )
//
//   rawcodebufid                buffer id of buffer containing raw code
//   exportsymbollisthlistid     hlist id of hlist containing export symbol list
//   exportsymbollistelementid   parent element id of export symbol list
//   filename$                   file name of the .o file to generate
//
// Action:
//  Takes the raw code buffer and an export symbol list and generates a .o file.
//  The symbol list is a list of name value pairs where the name is the symbol name,
//   and the value is an 8 byte integer representing an offset from pcode.
//
// Note:
//  The function of this word will probably change, like doing more than just
//   export offset symbols... so it might change. Also Mac OS keeps changing
//   how they do stuff at this level. 4/6/2020 J.N.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>

      
      <div class=word id=dg_forthbuftomachodotobuf>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbuftomachodotobuf ( BUF&gt;NEWMACH-O.OBUF BUF&gt;NEWEXPORTIMPORT.OBUF )
//
// C prototype:
//  void dg_forthbuftomachodotobuf (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is
//                                 used as the bufferhandle for the array where the
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( rawcodebufid exportsymbollisthlistid, exportsymbollistelementid
//     importsymbollisthlistid importsymbollistelementid -- dotobufid )
//
//   rawcodebufid                buffer id of buffer containing raw code
//   exportsymbollisthlistid     hlist id of hlist containing export symbol list
//   exportsymbollistelementid   parent element id of export symbol list
//   importsymbollisthlistid     hlist id of hlist containing import symbol list
//   importsymbollistelementid   parent element id of import symbol list
//   dotobufid                   buffer id of buffer containing the .o file image
//
// Action:
//  Takes the raw code buffer, an export symbol list, and an import symbol list
//   and generates a .o file image.
//  The symbol list are lists of name value pairs where the name is the symbol name,
//   and the value is an 8 byte integer representing an offset from the start of the
//   rawcodebufid buffer.
//   Mac OS X supports different kinds of import linking and exports but this
//   routine only supports one type of export and import. Later I'll probably
//   change it.
//   The import offset represents the offset where ld should put a four byte
//   offset to the real link pointer. What this means is ld will create an array
//   of 8 byte link addresses for you and you are supposed to access them with pc
//   relative instructions.
// 
//   Windows supports the same kind linking as Mac, but when I tried it, some
//    weird stuff was going on. The links were linking to themselves instead of
//    a compiler generated import table. So I'm guessing I was missing something.
//    So instead I went with importing absolute addresses. This means you'll
//    have to generate your own import link table on Windows. The offset that
//    goes into the import symbol list is the offset of the memory used to
//    hold the 8 byte imported address.
//
// Import link example of calling a Mac OS X imported function in 64 bit mode:
//  RIP 0 [R+N] CALL,              // compile a call to address stored in pc relative
//                                 //  link table
//                                 //  when RIP is base reg, displacement size
//                                 //  is always 4
//  OHERE 4 - >NEW$   $" myimport" // import function name is myimport, offset is of
//                                 //  CALL instruction's 4 byte displacement
//  1 EH[ND]  NEW-ELEMENT          // this adds a name value pair to the 2nd from
//                                 //  top current hierarchical list parent element
//                                 //  pair on the EH stack
//
//
// Import link example of getting address on Mac of imported function or 8 bit data:
//  RIP 0 [R+N]  RAX  MOV,         // when RIP is base reg, displacement size
//                                 //  is always 4
//
//  OHERE 4 - >NEW$   $" mydimp"   // import function name is mydimp, offset is of
//                                 //  MOV instruction's 4 byte displacement
//  1 EH[ND]  NEW-ELEMENT          // this adds a name value pair to the 2nd from
//                                 //  top current hierarchical list parent element
//                                 //  pair on the EH stack
//
// Making an import link on Win64
//  OHERE CONSTANT omyimportlink   // CONSTANT does not compile anything
//                                 //  it's only an entry in the new word wordlist
//  OHERE 0 CODE-U64, >NEW$ $" myimport"
//  1 EH[ND]  NEW-ELEMENT          // this adds a name value pair to the 2nd from
//                                 //  top current hierarchical list parent element
//                                 //  pair on the EH stack
//
// Example of calling the Win64 imported function in 64 bit mode:
//  HEX 20 N  RSP  SUB,            // for the 4 shadow parameters
//                                 //  this assumes you are already 16 byte aligned
//  omyimportlink [O] CALL,        // compile a call to address stored in pc relative
//                                 //  link table
//  20 N  RSP  ADD,                // drop the shadow parameters
//
// Example of getting address on Win64 of imported function or 8 bit data:
//  RIP omyimportlink [R+N]  RAX  MOV,   
//
// Note:
//  The function of this word will probably change, like doing more than just
//   one type of import and export symbols... so it might change. Also, Mac OS keeps
//   changing how they do stuff at this level. Windows seems pretty stable, but
//   if I figure out how to do the relative offset to a compiler generated 
//   table, I may switch to that or add it. 10/2/2020 J.N.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthpi>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthpi ( PI )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value pi
//
// Action:
//  Pushes the IEEE 64 bit double precision floating point value for pi to the
//   floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthe>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthe ( e )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value e
//
// Action:
//  Pushes the 64 bit double precision floating point value for e to the
//   floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>
      

      <div class=word id=dg_forthinfinity>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthinfinity ( INFINITY )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value
//                                 infinity
//
// Action:
//  Pushes the 64 bit double precision floating point value for infinity to the
//   floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthminusinfinity>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthminusinfinity ( -INFINITY )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value
//                                 -infinity
//
// Action:
//  Pushes the 64 bit double precision floating point value for negative infinity to 
//   the floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthdenormal>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdenormal ( DENORMAL )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value
//                                 denormal (too close to 0)
//
// Action:
//  Pushes the 64 bit double precision floating point value for denormal to the
//   floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthminusdenormal>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthminusdenormal ( -DENORMAL )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value
//                                 -denormal (too close to -0)
//
// Action:
//  Pushes the 64 bit double precision floating point value for negative denormal to 
//   the floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthnan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthnan ( NAN )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value
//                                 NaN (not a number)
//
// Action:
//  Pushes the 64 bit double precision floating point value for NaN to the
//   floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthminusnan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthminusnan ( -NAN )
//
// C prototype:
//  none (it's a FLOAT64 constant)
//
// Stack action shorthand:
//  ( -f64- df1 )
//
//  df1                           64 bit double precision floating point value
//                                 -NaN (not a number)
//
// Action:
//  Pushes the 64 bit double precision floating point value for negative NaN to the
//   floating point stack.
//
// Failure cases:
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthminusrot>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthminusrot ( -ROT )
//
// C prototype:
//  void dg_forthminusrot (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( n1 n2 n3 -- n3 n1 n2 )
//  
// Data Stack In: 
//  x1 x2 x3                      integers (64 bit)
// 
// Data Stack Out:
//  x3 x1 x2                      integers (64 bit)
// 
// Action:
//  Rearranges the top 3 integers on the data stack.
//
// Failure cases:
//  Error getting pointer to the data stack
//  there aren't 3 items on the data stack
//
// //////////////////////////////////////////////////////////////////////////////////////        
</pre>
      </div>


      <div class=word id=dg_forthrandom>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthrandom ( RANDOM )
//
// C prototype:
//  void dg_forthrandom (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- x1 )
// 
// Data Stack Out:
//  x1                            random 64 bit integer
// 
// Action:
//  Pushes a random 64 bit integer onto the data stack.
//
// //////////////////////////////////////////////////////////////////////////////////////           
</pre>
      </div>


      <div class=word id=dg_forthcompileu8s>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompileu8s ( COMPILE-U8S )
//
// C prototype:
//  void dg_forthcompileu8s (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next ; or to the end of the line if ; is not found.
//  For each word found before the ; or end of the line, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, the lowest byte of the number is
//    pushed onto the end of the current compile buffer.
//   If the word can not be converted to a number, then this function pushes errors
//    to the error stack and returns.
//
// Examples:
//  HEX COMPILE-U8S A5 22 C4 96 C3 
//  HEX COMPILE-U8S A5 22 C4 96 C3 ;
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcompileu8scurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcompileu8scurly ( COMPILE-U8S&lt; )
//
// C prototype:
//  void dg_forthcompileu8scurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, the lowest byte of the number is
//    pushed onto the end of the current compile buffer.
//   If the word can not be converted to a number, then this function pushes errors
//    to the error stack and returns.
//
// Example:
//  HEX COMPILE-U8S&lt; 
//   A5 22 
//   C4 
//   96 C3 &gt; 
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthconstants>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthconstants ( CONSTANTS )
//
// C prototype:
//  void dg_forthconstants (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next ; or to the end of the line if ; is not found.
//  For each word found before the ; or end of the line, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, it is pushed to the data stack.
/    If the word can not be converted to a number, then this function pops a number
//    from the data stack and then creates a new definition in the current new word
//    wordlist that:
//     In execute mode pushes the number onto the data stack
//     In compile mode compiles code that pushes the number onto the data stack
//
// Examples:
//  CONSTANTS 0 x  1 y  2 z  
//  CONSTANTS 0 x  1 y  2 z  ;
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthconstantscurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthconstantscurly ( CONSTANTS&lt; )
//
// C prototype:
//  void dg_forthconstantscurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, it is pushed to the data stack.
/    If the word can not be converted to a number, then this function pops a number
//    from the data stack and then creates a new definition in the current new word
//    wordlist that:
//     In execute mode pushes the number onto the data stack
//     In compile mode compiles code that pushes the number onto the data stack
//
// Example:
//  CONSTANTS&lt; 
//   0 x  
//   1 y  2 z &gt; 
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthlocalconstants>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthlocalconstants ( LOCAL-CONSTANTS )
//
// C prototype:
//  void dg_forthlocalconstants (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next ; or to the end of the line if ; is not found.
//  For each word found before the ; or end of the line, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, it is pushed to the data stack.
/    If the word can not be converted to a number, then this function pops a number
//    from the data stack and then creates a new definition in the local wordlist that:
//     In execute mode pushes the number onto the data stack
//     In compile mode compiles code that pushes the number onto the data stack
//
// Examples:
//   LOCAL-CONSTANTS 0 x  1 y  2 z  
//   LOCAL-CONSTANTS 0 x2  1 y2  2 z2  ;
//    
//   x y z
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbracketlocalconstants>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbracketlocalconstants ( [LOCAL-CONSTANTS] )
//
// C prototype:
//  void dg_forthbracketlocalconstants (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next ; or to the end of the line if ; is not found.
//  For each word found before the ; or end of the line, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, it is pushed to the data stack.
/    If the word can not be converted to a number, then this function pops a number
//    from the data stack and then creates a new definition in the local wordlist that:
//     In execute mode pushes the number onto the data stack
//     In compile mode compiles code that pushes the number onto the data stack
//
//  This is an immediate word. In both execute and compile mode, the action for this
//   word is done. Also, the local word list is emptied at the end of a : definition.
//
// Examples:
//  : myword
//    [LOCAL-CONSTANTS] 0 x  1 y  2 z  
//    [LOCAL-CONSTANTS] 0 x2  1 y2  2 z2  ;
//    
//    x y z ;
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthlocalconstantscurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthlocalconstantscurly ( LOCAL-CONSTANTS&lt; )
//
// C prototype:
//  void dg_forthlocalconstantscurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, it is pushed to the data stack.
/    If the word can not be converted to a number, then this function pops a number
//    from the data stack and then creates a new definition in the local wordlist that:
//     In execute mode pushes the number onto the data stack
//     In compile mode compiles code that pushes the number onto the data stack
//
// Example:
//    LOCAL-CONSTANTS&lt; 
//     0 x  
//     1 y  2 z &gt; 
//
//    x y z
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbracketlocalconstantscurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbracketlocalconstantscurly ( [LOCAL-CONSTANTS]&lt; )
//
// C prototype:
//  void dg_forthbracketlocalconstantscurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   If the word can be converted to a number, it is pushed to the data stack.
/    If the word can not be converted to a number, then this function pops a number
//    from the data stack and then creates a new definition in the local wordlist that:
//     In execute mode pushes the number onto the data stack
//     In compile mode compiles code that pushes the number onto the data stack
//
// Note:
//  This is an immediate word. In both execute and compile mode, the action for this
//   word is done. Also, the local word list is emptied at the end of a : definition.
//
// Example:
//  : myword
//    [LOCAL-CONSTANTS]&lt; 
//     0 x  
//     1 y  2 z &gt; 
//
//    x y z ;
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>



      <div class=word id=dg_forthfconstants>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthfconstants ( FCONSTANTS )
//
// C prototype:
//  void dg_forthfconstants (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next ; or to the end of the line if ; is not found.
//  For each word found before the ; or end of line, whichever come first:
//   This function tries to convert the word to a floating point number. 
//   If the word can be converted to a floating point number, it is pushed to the
//    floating point stack.
/    If the word can not be converted to a floating point number, then this function 
//    pops a floating point number from the floating point stack and then creates a 
//    new definition in the current new word wordlist that:
//     In execute mode pushes the floating point number onto the floating point stack
//     In compile mode compiles code that pushes the floating point number onto the
//      floating point stack
//
// Note:
//  BASE is ignored for this function. Decimal is used for the floating point
//   conversion under the assumption that if you used this function, the words
//   up to ; are either floating point numbers in base 10 or
//   the names of new constants.
//
// Example:
//  FCONSTANTS 2.0E x  3.1415E pie  10.9876E35 z
//  FCONSTANTS 2.0E x  3.1415E pie  10.9876E35 z ; 
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthfconstantscurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthfconstantscurly ( FCONSTANTS&lt; )
//
// C prototype:
//  void dg_forthfconstantscurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   This function tries to convert the word to a floating point number. 
//   If the word can be converted to a floating point number, it is pushed to the
//    floating point stack.
/    If the word can not be converted to a floating point number, then this function 
//    pops a floating point number from the floating point stack and then creates a 
//    new definition in the current new word wordlist that:
//     In execute mode pushes the floating point number onto the floating point stack
//     In compile mode compiles code that pushes the floating point number onto the
//      floating point stack
//
// Note:
//  BASE is ignored for this function. Decimal is used for the floating point
//   conversion under the assumption that if you used this function, the words
//   up to &gt; are either floating point numbers in base 10 or
//   the names of new constants.
//
// Example:
//  FCONSTANTS&lt; 
//    2.0E x  
//    3.1415E pie  
//    10.9876E35 z &gt; 
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthvariables>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthvariables ( VARIABLES FVARIABLES )
//
// C prototype:
//  void dg_forthvariables (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  ( -currentnewvariablebuffer- +(u*sizeofUINT64) )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
// 
// Current data space buffer in:
//  previously allocated variables
// 
// Current data space buffer out:
//  previously allocated variables + u new variables of one address cell size 
//   (one address cell size = size of UINT64 in this implementation)
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next ; or to the end of the line if ; is not found.
//  For each word name found before the ; or end of the line whichever come first:
//   If the word name can be converted to a number using the current BASE, it is
//    pushed to the data stack,
//   Otherwise this function creates a new definition in the current vocabulary that:
//    In execute mode pushes the address of a variable onto the data stack
//    In compile mode compiles code that calculates the address from the variable's 
//     bufferid and offset and pushes the address onto the data stack. The address 
//     of the variable used is the address of the next unused byte in the current 
//     data space buffer at the time this new definition was created.
//   Then if the depth of the data stack is greater than when this function started,
//    the initial value of the variable is popped from the data stack, otherwise 0
//    is used as the initial value of the variable.
//   Then this routine pushes the initial value of the variable onto the end of the
//    current data space buffer (current new variable buffer). 
//
// Example:
//  VARIABLES x y z 
//  VARIABLES p q r ; 
//
//  VARIABLES 5 x 6 y z
//  VARIABLES p 7 q 8 r ;
//
// Note:
//  Please see CREATE for a discussion on the life of the pointer to the VARIABLE.
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthvariablescurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthvariablescurly ( VARIABLES&lt; FVARIABLES&lt; )
//
// C prototype:
//  void dg_forthvariablescurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  ( -currentnewvariablebuffer- +(u*sizeofUINT64) )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
// 
// Current data space buffer in:
//  previously allocated variables
// 
// Current data space buffer out:
//  previously allocated variables + u new variables of one address cell size 
//   (one address cell size = size of UINT64 in this implementation)
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word name found before the &gt; or end of buffer, whichever come first:
//   If the word name can be converted to a number using the current BASE, it is
//    pushed to the data stack,
//   Otherwise this function creates a new definition in the current vocabulary that:
//    In execute mode pushes the address of a variable onto the data stack
//    In compile mode compiles code that calculates the address from the variable's 
//     bufferid and offset and pushes the address onto the data stack. The address 
//     of the variable used is the address of the next unused byte in the current 
//     data space buffer at the time this new definition was created.
//   Then if the depth of the data stack is greater than when this function started,
//    the initial value of the variable is popped from the data stack, otherwise 0
//    is used as the initial value of the variable.
//   Then this routine pushes the initial value of the variable onto the end of the
//    current data space buffer (current new variable buffer). 
//
// Example:
//  VARIABLES&lt; 
//   x y z 
//   p q r &gt;
//
//  VARIABLES&lt;
//   5 x 6 y z
//   p 7 q 8 r &gt;
//
// Note:
//  Please see CREATE for a discussion on the life of the pointer to the VARIABLE.
//  When loading from a file or using EVALUATE, the words parsed can be over multiple
//   lines. If you are using this function from the command line, the line entry system 
//   treats everything you entered as one buffer, so you are limited by that.
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthmicrosecondssince1970jan01>
<pre>
// ////////////////////////////////////////////////////////////////////////////////////// 
//
// dg_forthmicrosecondssince1970jan01 ( MICROSECONDSSINCE1970JAN01 )
//
// C prototype:
//  void dg_forthmicrosecondssince1970jan01 (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( -- x )
// 
// Data Stack Out:
//  x                            microseconds elapsed since Jan 1, 1970
// 
// Action:
//  Pushes the current number of microseconds that have passed since the start of
//   January 1, 1970 in UTC time. 
//
// //////////////////////////////////////////////////////////////////////////////////////          
</pre>
      </div>


      <div class=word id=dg_forthbrackettoorderconstant>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbrackettoorderconstant ( [&gt;ORDER]CONSTANT )
//
// C prototype:
//  void dg_forthbrackettoorderconstant (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( wordlistid -- )
//  ( &lt;delimiters&gt;word&lt;delimiters&gt;morestuff -currentinputbuffer- 
//     delimiters&gt;morestuff )
//
// Forth standard:
//  none
//                                                          
// Action:
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next word or to the end of the buffer if the next word is not found.
//  Then pops the top value off the data stack, then creates a new word which has
//   the word name of the word parsed from the current input buffer, a compile type
//   of OCR[&gt;ORDER], and a data type of wordlistid.
//  In both script execute and compile mode, this new word pushes wordlistid to the
//   search order stack.
//
// Example of making a rectangle structure:
//  HEX
//  WORDLIST DUP [&gt;ORDER]CONSTANT [rectangle] &gt;CURRENT
//   : +x 0 + ;
//   : +y 8 + ;
//   : +w 10 + ;
//   : +h 18 + ;
//   : .size 20 ;
//  CURRENT&gt; DROP
//
//  At this point you have created a new wordlist that has
//   +x +y +w +h and .size in it that is not in the search order.
//   This means +x +y +w +h and .size can exist in other word lists and
//   not mess anything up.
//
//  : rectangle.y@ ( prectangle -- prectangle->y )
//     [rectangle] +y [SEARCH-ORDER-DROP] @ ;
//
// Note:
//  This word can help you make name spaces such as declaring a structure.
//  Also, if you push something to the search order stack that is not a word list id, 
//   the script parsing will error out and the script engine will get stuck. This 
//   behavior may change in the future. I'm thinking of having the find word name
//   in wordlist continue looking in the event a bad word list id is on the search
//   order stack instead of just stopping. 1/8/2021 J.N.
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthsizedconstantscurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthsizedconstantscurly ( SIZED-CONSTANTS&lt; )
//
// C prototype:
//  void dg_forthsizedconstantscurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  The default value for each new two constant is set to 0 and the default size
//   is set to 1.
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   For the first word of each group words that can be converted to a number, the
//    default size is set to this number.
//   For the second and all following words of the group that can be converted to
//    a number, the default value is set to the current default size, and the
//    default size is set to this number. 
/    If the word can not be converted to a number, then this function creates a 
//    new definition in the current new word wordlist that:
//     In execute mode pushes the current default value and default size onto the 
//      data stack
//     In compile mode compiles code that pushes the default value and default size
//      onto the data stack
//    Then a new group of words is started.
//
// Example:
//  SIZED-CONSTANTS&lt; 
//   20 2 x  
//   3 y  z 
//   1 w
//   v&gt; 
//
//  x will push 20 2 onto the data stack
//  y will push 22 3 onto the data stack
//  z will push 25 3 onto the data stack
//  w will push 28 1 onto the data stack
//  v will push 29 1 onto the data stack
//
// Example making a structure:
//  WORDLIST DUP [>ORDER]CONSTANT [rectangle] >CURRENT 
//   SIZED-CONSTANTS&lt; 8 x y w h size&gt;
//  CURRENT> DROP
//
// Example making a function to access a member of the structure:
//  : rectangle->w@ ( prectangle -- data )
//     [rectangle] w [SEARCH-ORDER-DROP] 
//     DROP ( drop the size of w )
//     + @ ;
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthenumcurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthenumcurly ( ENUM&lt; )
//
// C prototype:
//  void dg_forthenumcurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( stepsize startvalue -- valueafterend )
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Pops the start value off the data stack. 
//  Pops the step size off the data stack.
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   For the first word of each group words that can be converted to a number, the
//    step size is set to this number.
//   For the second and all following words of the group that can be converted to
//    a number, the value is set to this number. 
//   If the word can not be converted to a number, then 
//    if it's not the first value or if the value wasn't just set,
//     the step size is added to the value. Then, this function 
//     creates a new definition in the current new word wordlist that:
//      In execute mode pushes the current value onto the data stack
//      In compile mode compiles code that pushes the default value 
//       onto the data stack
//   Then a new group of words is started. 
//
// Example:
//  1 6 ENUM&lt; 
//   x  
//   y  z 
//   2 w
//   3 1
//   v u&gt;
//
//  7 is on the data stack after
//
//  x will push 6 onto the data stack
//  y will push 7 onto the data stack
//  z will push 8 onto the data stack
//  w will push 10 onto the data stack
//  v will push 1 onto the data stack
//  u will push 4 onto the data stack
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthlocalenumcurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthlocalenumcurly ( LOCAL-ENUM&lt; )
//
// C prototype:
//  void dg_forthlocalenumcurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( stepsize startvalue -- valueafterend )
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Pops the start value off the data stack. 
//  Pops the step size off the data stack.
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   For the first word of each group words that can be converted to a number, the
//    step size is set to this number.
//   For the second and all following words of the group that can be converted to
//    a number, the value is set to this number. 
//   If the word can not be converted to a number, then 
//    if it's not the first value or if the value wasn't just set,
//     the step size is added to the value. Then, this function 
//     creates a new definition in the locals wordlist that:
//      In execute mode pushes the current value onto the data stack
//      In compile mode compiles code that pushes the default value 
//       onto the data stack
//   Then a new group of words is started.
//   At the end, the value that would be next is pushed onto the data stack.
//
// Example:
//  1 6 ENUM&lt; 
//   x  
//   y  z 
//   2 w
//   3 1
//   v u&gt;
//
//  7 is on the data stack after
//
//  x will push 6 onto the data stack
//  y will push 7 onto the data stack
//  z will push 8 onto the data stack
//  w will push 10 onto the data stack
//  v will push 1 onto the data stack
//  u will push 4 onto the data stack
//
// Note:
//  Use ?CLEAR-LOCALS to clear the local words from the local word list.
//  This happens automatically at certain times, like when ; is compiled in a
//   : definition.
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbracketlocalenumcurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbracketlocalenumcurly ( [LOCAL-ENUM]&lt; )
//
// C prototype:
//  void dg_forthbracketlocalenumcurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( stepsize startvalue -- valueafterend )
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Sets the start value to 0. 
//  Sets the step size to 1.
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   For the first word of each group words that can be converted to a number, the
//    step size is set to this number.
//   For the second and all following words of the group that can be converted to
//    a number, the value is set to this number. 
//   If the word can not be converted to a number, then 
//    if it's not the first value or if the value wasn't just set,
//     the step size is added to the value. Then, this function 
//     creates a new definition in the locals wordlist that:
//      In execute mode pushes the current value onto the data stack
//      In compile mode compiles code that pushes the default value 
//       onto the data stack
//   Then a new group of words is started.
//
// Example:
//  1 6 ENUM&lt; 
//   x  
//   y  z 
//   2 w
//   3 1
//   v u&gt;
//
//  x will push 6 onto the data stack
//  y will push 7 onto the data stack
//  z will push 8 onto the data stack
//  w will push 10 onto the data stack
//  v will push 1 onto the data stack
//  u will push 4 onto the data stack
//
// Note:
//  Use ?CLEAR-LOCALS to clear the local words from the local word list.
//  This happens automatically at certain times, like when ; is compiled in a
//   : definition.
//
//  This function does not take parameters on the stack before, or put a value onto
//   the stack after like LOCAL-ENUM&gt;
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthtypedenumcurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthtypedenumcurly ( TYPED-ENUM&lt; )
//
// C prototype:
//  void dg_forthtypedenumcurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( stepsize startvalue type -- valueafterend )
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Pops the type off the data stack.
//  Pops the start value off the data stack. 
//  Pops the step size off the data stack.
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   For the first word of each group words that can be converted to a number, the
//    step size is set to this number.
//   For the second and all following words of the group that can be converted to
//    a number, the value is set to this number. 
//   If the word can not be converted to a number, then 
//    if it's not the first value or if the value wasn't just set,
//     the step size is added to the value. Then, this function 
//     creates a new definition in the current new word wordlist that:
//      In execute mode pushes the current value onto the data stack
//      In compile mode compiles code that pushes the default value 
//       onto the data stack
//   Then a new group of words is started.
//
// Example:
//  1 6 33 ENUM&lt; 
//   x  
//   y  z 
//   2 w
//   3 1 66
//   v u&gt;
//
//  7 is on the data stack after
//
//  x will push 6 then 33 onto the data stack
//  y will push 7 then 33 onto the data stack
//  z will push 8 then 33 onto the data stack
//  w will push 10 then 33 onto the data stack
//  v will push 1 then 66 onto the data stack
//  u will push 4 then 66 onto the data stack
//  
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthtypedlocalenumcurly>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthtypedlocalenumcurly ( TYPED-LOCAL-ENUM&lt; )
//
// C prototype:
//  void dg_forthtypedlocalenumcurly (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle* pBHarrayhead    pointer to a Bufferhandle structure which is 
//                                 used as the bufferhandle for the array where the 
//                                 other bufferhandles are stored.
//
// Stack action shorthand:
//  ( stepsize startvalue -- valueafterend )
//  ( &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot; -currentinputbuffer- 
//     &quot;morestuff&quot; )
//  
// Current input buffer's current offset in:
//  &quot;&lt;delimiters&gt;word1&lt;delimiters&gt;word2&quot;...
//    &lt;delimiters&gt;wordu&lt;delimiters&gt;}morestuff&quot;
//
// Current input buffer's current offset out:
//  &quot;morestuff&quot;          
//
// Forth standard:
//  none
//                                                          
// Action:
//  Pops the type off the data stack.
//  Pops the start value off the data stack. 
//  Pops the step size off the data stack.
//  Moves the current offset pointer for the current input buffer to the character 
//   after the next &gt; or to the end of the buffer if &gt; is not found.
//  For each word found before the &gt; or end of buffer, whichever come first:
//   Tries to convert the word to a number using the current BASE. 
//   For the first word of each group words that can be converted to a number, the
//    step size is set to this number.
//   For the second and all following words of the group that can be converted to
//    a number, the value is set to this number. 
//   If the word can not be converted to a number, then 
//    if it's not the first value or if the value wasn't just set,
//     the step size is added to the value. Then, this function 
//     creates a new definition in the locals wordlist that:
//      In execute mode pushes the current value onto the data stack
//      In compile mode compiles code that pushes the default value 
//       onto the data stack
//   Then a new group of words is started.
//
// Example:
//  1 6 33 ENUM&lt; 
//   x  
//   y  z 
//   2 w
//   3 1 66
//   v u&gt;
//
//  7 is on the data stack after
//
//  x will push 6 then 33 onto the data stack
//  y will push 7 then 33 onto the data stack
//  z will push 8 then 33 onto the data stack
//  w will push 10 then 33 onto the data stack
//  v will push 1 then 66 onto the data stack
//  u will push 4 then 66 onto the data stack
//
// Note:
//  Use ?CLEAR-LOCALS to clear the local words from the local word list.
//  This happens automatically at certain times, like when ; is compiled in a
//   : definition.
//
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthn8tocell>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthn8tocell ( N8&gt;CELL )
//
// C prototype:
//  void dg_forthn8tocell (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n8 -- n64 )
//
// Data stack in:
//  n8             INT8              signed 8 bit value
//
// Data stack out:
//  n64            INT64             signed 64 bit value
//
// Action:
//  Sign extends the lowest 8 bits of the 64 bit number on top of the data stack
//   to 64 bits. (The upper 56 bits are changed to the value of bit 7.) 
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthn16tocell>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthn16tocell ( N16&gt;CELL )
//
// C prototype:
//  void dg_forthn16tocell (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n16 -- n64 )
//
// Data stack in:
//  n16            INT16             signed 16 bit value
//
// Data stack out:
//  n64            INT64             signed 64 bit value
//
// Action:
//  Sign extends the lowest 16 bits of the 64 bit number on top of the data stack
//   to 64 bits. (The upper 48 bits are changed to the value of bit 15.) 
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthn32tocell>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthn32tocell ( N32&gt;CELL )
//
// C prototype:
//  void dg_forthn32tocell (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n32 -- n64 )
//
// Data stack in:
//  n32            INT32             signed 32 bit value
//
// Data stack out:
//  n64            INT64             signed 64 bit value
//
// Action:
//  Sign extends the lowest 32 bits of the 64 bit number on top of the data stack
//   to 64 bits. (The upper 32 bits are changed to the value of bit 31.) 
//
// Failure cases:
//  error getting pointer to the data stack
//  data stack underflow
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthtoxtpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthtoxtpcomma ( &gt;XTP, )
//
// C prototype:
//  void dg_forthtoxtpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( address -- )
//
// Data stack in:
//  address         UINT64           address to jump to
//
// Action:
//  Pops address off the data stack, then compiles a jump to this address.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthbeginsystopcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthbeginsystopcomma ( BEGINSYS&gt;P, )
//
// C prototype:
//  void dg_forthbeginsystopcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( compile: -- )
//  ( run: beginsys -- paddr )
//
// Runtime data stack in:
//  beginsys       UINT64           buffer offset from a BEGIN
//
// Runtime data stack out:
//  paddr          UINT64           run time address of beginsys
//
//
// Action:
//  Compiles code to convert a beginsys on the top of the data stack to an address.
//   In DiaperGlu a beginsys is an offset in the current compile buffer. The compiled
//   code uses the current compile buffer at compile time.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemescomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemescomma ( CODEMES, EMES, )
//
// C prototype:
//  void dg_forthcodemescomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( compile: -- AHEAD-SYS-START 1 CODEMES-SYS )
//  ( run: -- )
//
// Compiletime data stack out:
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the code sections and also the BEGINSYS 
//                                     marker for section 0
//   1                UINT64         initial number of sections in codeme table
//   CODEMES-SYS      UINT64         initial state marker for codeme table
//
//
// Action:
//  Compiles an unresolved forward jump which will skip over the code sections in the
//    codeme table. Then generates the intial codeme table.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemecomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemecomma ( CODEME, EME, )
//
// C prototype:
//  void dg_forthcodemecomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( compile: AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-U-1 U CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-U-1 AHEAD-SYS-U U+1 CODEMES-SYS )
//  ( run: -- )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the code sections and also the BEGINSYS 
//                                     marker for section 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends code
//                                     section 0 and also the BEGINSYS marker for
//                                     for section 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends code
//                                     section 1 and also the BEGINSYS marker for
//                                     for section 2
//   AHEAD-SYS-U-1    UINT64         IFSYS marker for the jump that ends code
//                                     section U-1 and also will be the BEGINSYS 
//                                     marker for for section U
//   U                UINT64         number of sections in codeme table
//   CODEMES-SYS      UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the code sections and also the BEGINSYS 
//                                     marker for section 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends code
//                                     section 0 and also the BEGINSYS marker for
//                                     for section 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends code
//                                     section 1 and also the BEGINSYS marker for
//                                     for section 2
//   AHEAD-SYS-U-1    UINT64         IFSYS marker for the jump that ends code
//                                     section U-1 and also the BEGINSYS 
//                                     marker for for section U
//   AHEAD-SYS-U      UINT64         IFSYS marker for the jump that ends code
//                                     section U 
//   U+1              UINT64         number of sections in codeme table
//   CODEMES-SYS      UINT64         state marker for codeme table
//
//
// Action:
//  Compiles an unresolved forward jump to end code section U. Then adds an
//    AGAIN-SYS marker for code section U to the codemes table. Then increments the
//    number of sections in the codeme table.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthendcodemescomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthendcodemescomma ( END-CODEMES, ENDEMES, )
//
// C prototype:
//  void dg_forthendcodemescomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( compile: AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-U-1 U CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-U-1 AHEAD-SYS-U U+1 0 END-CODEMES-SYS )
//  ( run: -- )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   U                UINT64         number of sections in codeme table
//   CODEMES-SYS      UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   AHEAD-SYS-U      UINT64         IFSYS marker for the jump that ends code
//                                     section U 
//   U+1              UINT64         number of sections in codeme table
//   0                UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Action:
//  Compiles an unresolved forward jump that will end code section U. Then adds an
//    AGAIN-SYS marker for code section U to the codemes table. Then increments the
//    number of sections in the codeme table. After this it puts a 0 under the
//    state marker to serve as the current codem index. Then it changes the state
//    marker to END-CODEMES-SYS
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthnumbercodemes>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthnumbercodemes ( #CODEMES )
//
// C prototype:
//  void dg_forthnumbercodemes (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS UMAX )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   UMAX             UINT64         number of sections in codeme table
//
// Action:
//  Pushes a copy of UMAX onto the top of the data stack. UMAX represents the 
//    number of code sections in a codeme table onto the top of the data stack.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemescurrent>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemescurrent ( CODEMES-CURRENT )
//
// C prototype:
//  void dg_forthcodemescurrent (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS current )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   current          UINT64         number of sections in codeme table
//
// Action:
//  Pushes a copy of current onto the top of the data stack. current represents 
//    the current codeme in a codeme table.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthquerycodemescurrent>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthquerycodemescurrent ( ?CODEMES-CURRENT )
//
// C prototype:
//  void dg_forthquerycodemescurrent (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Action:
//  If current >= UMAX then this pushes errors to the error stack.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesuifsys>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesuifsys ( CODEMESU-IFSYS )
//
// C prototype:
//  void dg_forthcodemesuifsys (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS U --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS 
//      AHEAD-SYS-U )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   U                UINT64         index of IFSYS marker to pick
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   AHEAD-SYS-U      UINT64         IFSYS marker for the jump that either
//                                     (U = -1) skips over all the code sections or
//                                     (U >= 0) ends code section U
//                                     
//
// Action:
//  Pops U from the data stack
//  Picks IFSYS marker U from the codeme table and pushes it onto the top of the
//    data stack.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesubeginsys>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesubeginsys ( CODEMESU-BEGINSYS )
//
// C prototype:
//  void dg_forthcodemesubeginsys (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS U --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS 
//      BEGINSYS-U )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   U                UINT64         index of BEGINSYS marker to pick
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   BEGINSYS-U       UINT64         BEGINSYS marker code section U
//                                     this is the same as AHEAD-SYS-U-1
//                                     
//
// Action:
//  Pops U from the data stack
//  Picks BEGINSYS marker U from the codeme table and pushes it onto the top of the
//    data stack. BEGINSYS-U = AHEAD-SYS-U-1.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesdrop>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesdrop ( CODEMES-DROP )
//
// C prototype:
//  void dg_forthcodemesdrop (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS -- )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//                                     
//
// Action:
//  Drops the codemes table from the data stack.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesresolvestart>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesresolvestart ( CODEMES-RESOLVE-START )
//
// C prototype:
//  void dg_forthcodemesresolvestart (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//                                     
//
// Action:
//  Resolves the forward jump for AHEAD-SYS-START to jump to the current end of 
//   the current compile buffer.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesresolveends>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesresolveends ( CODEMES-RESOLVE-ENDS )
//
// C prototype:
//  void dg_forthcodemesresolveends (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//                                     
//
// Action:
//  Resolves the forward jumps for all AHEAD-SYS except for AHEAD-SYS-START.
//    The jumps are resolved to jump to the current end of the current compile buffer.
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemescasecomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemescasecomma ( CODEMES-CASE, )
//
// C prototype:
//  void dg_forthcodemescasecomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current END-CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   CODEMES-CASE-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//
//  First, checks to make sure the END-CODEMES-SYS state marker is on top of the
//   data stack.
//  Then resolves AHEAD-SYS-START to jump to the current end of the current 
//   compile buffer. 
//  Then changes the codeme state marker to be CODEMES-CASE-SYS.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ CODEMES-CASE,
//         9 CODEMES-OF,   // if tos = 9 then goto codeme 0
//         5 CODEMES-OF, ] // if tos = 5 then goto codeme 1
//         DROP ." default"
//     [ CODEMES-ENDCASE, ]
// ; 
//
// Note:
//
//  The code in each codeme case has access to the local variables and sees 
//   the same data stack. Like the Dr. Eaker CASE, the default case has the
//   switch value on top of the data stack. Unlike the Dr. Eaker CASE, 
//   CODEMES-END-CASE, does not compile a drop, so you have to do a DROP
//   during the default case.
//
//  CODEMES-CASES, compiles more efficient code than CODEMES-CASE, 
//   The reason why is CODEMES-OF, gets the top of data stack each time whereas
//   CODEMES-CASES, copies the top of data stack to a register. If you only need
//   to compare for equality, I recommend using CODEMES-CASES, instead of 
//   CODEMES-CASE, or CASE
//
//  CODEMES-CASE, compiles more efficient code than CASE, because CASE, is compiling
//   a call to a word that repeatedly gets values from the data stack to compare the
//   switch value with the number on top of the data stack.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesofcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesofcomma ( CODEMES-OF, )
//
// C prototype:
//  void dg_forthcodemesofcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-CASE-SYS 
//      switchvalue --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   switchvalue      UINT64         value to compare with top of stack at runtime
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   CODEMES-CASE-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-CASE-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to do a drop and branch to the current codeme's beginsys 
//   if the switch value matches the top of the data stack.
//  Then increments the current codeme in the codemes table.
//  Then drops the switch value from the data stack.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ CODEMES-CASE,
//         9 CODEMES-OF,   // if tos = 9 then goto codeme 0
//         5 CODEMES-OF, ] // if tos = 5 then goto codeme 1
//         DROP ." default"
//     [ CODEMES-ENDCASE, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesendcasecomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesendcasecomma ( CODEMES-ENDCASE, ENDCASES, )
//
// C prototype:
//  void dg_forthcodemesendcasecomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-CASE-SYS -- )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//                                     
//
// Example:
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ CODEMES-CASE,
//         9 CODEMES-OF,   // if tos = 9 then goto codeme 0
//         5 CODEMES-OF, ] // if tos = 5 then goto codeme 1
//         DROP ." default"
//     [ CODEMES-ENDCASE, ]
// ; 
//
// Action:
//
//  First, checks to see if the CODEMES-CASE-SYS state marker is on top of the 
//   data stack.
//
//  Then resolves all the jumps for each AHEAD-SYS in the codemes table except
//   AHEAD-SYS-START to jump to the current end of the current compile buffer.
//
//  Then drops the codeme table from the data stack.
//
// Note:
//
//  Unlike Dr. Eaker's END-CASE , CODEMES-END-CASE, does not compile a DROP. You will
//    need to do a DROP during the default case. I did this to simplify things.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemescasescomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemescasescomma ( CODEMES-CASES, CASES, )
//
// C prototype:
//  void dg_forthcodemescasescomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 ... AHEAD-SYS-UMAX-1 UMAX current END-CODEMES-SYS 
//      switchvalue0 switchvalue1 ... switchvalueu-1 UMAX --  
//      AHEAD-SYS-START AHEAD-SYS-0 ... AHEAD-SYS-UMAX-1 UMAX current CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current           UINT64        current codeme index 
//   END-CODEMES-SYS   UINT64        state marker for codeme table
//   switchvalue0      UINT64        switch value for codeme 0
//   switchvalue1      UINT64        switch value for codeme 1
//   switchvalueumax-1 UINT64        switch value for codeme umax-1
//   UMAX              UINT64        number of switchvalues, must match number of
//                                     sections in codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   current          UINT64         current codeme index 
//   CODEMES-CASE-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//
//  First, checks to make sure the END-CODEMES-SYS state marker is underneath
//    the switch values on the data stack.
//  Then, makes sure the number of switch values is the same as the number of
//    sections in the codemes table.
//  Then resolves AHEAD-SYS-START to jump to the current end of the current 
//   compile buffer. 
//  Then changes the codeme state marker to be CODEMES-CASE-SYS.
//  Then compiles code to pop the switch value off the data stack to a register.
//  Then for each switchvalue, compiles code to branch to the matching codeme 
//   beginsys if the switch value matches the top of the data stack.
//  Then compiles code to push the switch value back onto the data stack.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ 9 5 2 CODEMES-CASES, ]
//         DROP ." default"
//     [ CODEMES-ENDCASE, ]
// ; 
//
// Note:
//
//  The code in each codeme case has access to the local variables and sees 
//   the same data stack. Like the Dr. Eaker CASE, the default case has the
//   switch value on top of the data stack. Unlike the Dr. Eaker CASE, 
//   CODEMES-END-CASE, does not compile a drop, so you have to do a DROP
//   during the default case.
//
//  CODEMES-CASES, compiles way more efficient code than CODEMES-CASE, 
//   The reason why is CODEMES-OF, gets the top of data stack each time whereas
//   CODEMES-CASES, copies the top of data stack to a register. If you only need
//   to compare for equality, I recommend using CODEMES-CASES, instead of 
//   CODEMES-CASE, or CASE. Except for the part where CODEMES-CASES pushes the
//   switch value back onto the data stack for the default case, the compiled
//   code is about as efficient as you can get.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesjumpscomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesjumpscomma ( CODEMES-JUMPS, JUMPS, )
//
// C prototype:
//  void dg_forthcodemesjumpscomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         0
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//
//  First, checks to make sure the END-CODEMES-SYS state marker is on top of the
//   data stack.
//  Then resolves AHEAD-SYS-START to jump to the current end of the current 
//   compile buffer. 
//  Then compiles code to allocate a new local variable, pop the switch value
//   off the data stack, and copy the switch value to the new local variable.
//  Then changes switch offset in the codeme table to the new local variable's
//   frame offset.
//  Then changes the codeme state marker to be CODEMES-JUMP-SYS.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,    // if switch value = 9 then goto codeme 0
//         5 1 =JUMP,    // if switch value = 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//
//  The code in each codeme case has access to the local variables and sees 
//   the same data stack. Like the Dr. Eaker CASE, the default case has the
//   switch value on top of the data stack. Unlike the Dr. Eaker CASE, 
//   CODEMES-JUMPS, removes the switch value from the data stack and moves
//   it to a hidden local variable. This means the switch value is not
//   on the data stack in the default code after the jumps.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient branches using labels.
//
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemealwaysjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemealwaysjumpcomma ( CODEME-ALWAYSJUMP, ALWAYSJUMP, )
//
// C prototype:
//  void dg_forthcodemealwaysjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is top on the 
//   data stack.
//  Then compiles code to always branch to the destination codeme's beginsys.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 JUMP,        // if switch value = 9 then goto codeme 0
//         1 ALWAYSJUMP, ]  // goto codeme 1
//         // will never get here
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemeequaljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemeequaljumpcomma ( X-CODEME-=JUMP, =JUMP, )
//
// C prototype:
//  void dg_forthxcodemeequaljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   casevalue matches the switch value saved in a local variable.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,    // if switch value = 9 then goto codeme 0
//         5 1 =JUMP,    // if switch value = 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemenotequaljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemenotequaljumpcomma ( X-CODEME-&lt;&gt;JUMP, &lt;&gt;JUMP, )
//
// C prototype:
//  void dg_forthxcodemenotequaljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   casevalue does not match the switch value saved in a local variable.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,          // if switch value = 9 then goto codeme 0
//         5 1 &lt;&gt;JUMP,   // if switch value &lt;&gt; 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"         // can only get here if switch value is 5
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemeulessthanjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemeulessthanjumpcomma 
//    ( X-CODEME-U&lt;JUMP, X-CODEME-CSJUMP, U&lt;JUMP, CSJUMP, )
//
// C prototype:
//  void dg_forthxcodemeulessthanjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is U< the casevalue .
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,        // if switch value = 9 then goto codeme 0
//         5 1 U&lt;JUMP,    // if switch value U&lt; 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemeulessthanequaljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemeulessthanequaljumpcomma ( X-CODEME-U&lt;=JUMP, U&lt;=JUMP, )
//
// C prototype:
//  void dg_forthxcodemeulessthanequaljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is U<= the casevalue .
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,        // if switch value = 9 then goto codeme 0
//         5 1 U&lt;=JUMP,   // if switch value U&lt; 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>



      <div class=word id=dg_forthxcodemeugreaterthanjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemeugreaterthanjumpcomma ( X-CODEME-U&gt;JUMP, U&gt;JUMP, )
//
// C prototype:
//  void dg_forthxcodemeugreaterthanjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is U> the casevalue .
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,        // if switch value = 9 then goto codeme 0
//         5 1 U&gt;JUMP,    // if switch value U&gt; 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemeugreaterthanequaljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemeugreaterthanequaljumpcomma 
//   ( X-CODEME-U&gt;=JUMP, X-CODEME-NCJUMP, U&gt;=JUMP, NCJUMP, )
//
// C prototype:
//  void dg_forthxcodemeugreaterthanequaljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is U>= the casevalue.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         =JUMP,        // if switch value = 9 then goto codeme 0
//         U&gt;=JUMP,   // if switch value U&gt;= 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemelessthanjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemelessthanjumpcomma 
//    ( X-CODEME-&lt;JUMP, &lt;JUMP, )
//
// C prototype:
//  void dg_forthxcodemelessthanjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is &lt; the casevalue .
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,       // if switch value = 9 then goto codeme 0
//         5 1 &lt;JUMP,    // if switch value &lt; 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemelessthanequaljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemelessthanequaljumpcomma ( X-CODEME-&lt;=JUMP, &lt;=JUMP, )
//
// C prototype:
//  void dg_forthxcodemelessthanequaljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is U<= the casevalue .
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,       // if switch value = 9 then goto codeme 0
//         5 1 &lt;=JUMP,   // if switch value &lt;= 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>



      <div class=word id=dg_forthxcodemegreaterthanjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemegreaterthanjumpcomma ( X-CODEME-&gt;JUMP, &gt;JUMP, )
//
// C prototype:
//  void dg_forthxcodemegreaterthanjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is &gt; the casevalue .
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,       // if switch value = 9 then goto codeme 0
//         5 1 &gt;JUMP,    // if switch value &gt; 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodemegreaterthanequaljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemegreaterthanequaljumpcomma 
//   ( X-CODEME-&gt;=JUMP, &gt;=JUMP, )
//
// C prototype:
//  void dg_forthxcodemegreaterthanequaljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is &gt;= the casevalue.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         =JUMP,       // if switch value = 9 then goto codeme 0
//         &gt;=JUMP,   // if switch value &gt;= 5 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthxcodememijumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodememijumpcomma ( X-CODEME-MIJUMP, MIJUMP, )
//
// C prototype:
//  void dg_forthxcodememijumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable minus the casevalue is negative.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,     // if switch value = 9 then goto codeme 0
//         5 1 MIJUMP,    // if switch value - 5 &lt; 0 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthxcodemepljumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemepljumpcomma ( X-CODEME-PLJUMP, PLJUMP, )
//
// C prototype:
//  void dg_forthxcodemepljumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable minus the casevalue is negative.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,     // if switch value = 9 then goto codeme 0
//         5 1 PLJUMP,    // if switch value - 5 &gt;= 0 then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthxcodemevsjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemevsjumpcomma ( X-CODEME-VSJUMP, VSJUMP, VSJUMP, )
//
// C prototype:
//  void dg_forthxcodemevsjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable minus the casevalue overflows.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,     // if switch value = 9 then goto codeme 0
//         5 1 VSJUMP,    // if switch value - 5 overflows then goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthxcodemenvjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemenvjumpcomma ( X-CODEME-NVJUMP, NVJUMP, )
//
// C prototype:
//  void dg_forthxcodemenvjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable minus the casevalue does not overflow.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,     // if switch value = 9 then goto codeme 0
//         5 1 VSJUMP,    // if switch value - 5 does not overflow then 
//                        //  goto codeme 1
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthxcodemepsjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemepsjumpcomma ( X-CODEME-PSJUMP, PSJUMP, )
//
// C prototype:
//  void dg_forthxcodemepsjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable minus the casevalue has an even
//   number of bits set.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,     // if switch value = 9 then goto codeme 0
//         5 1 PSJUMP,    // if switch value - 5 has even parity
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthxcodemenpjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemenpjumpcomma ( X-CODEME-NPJUMP, NPJUMP, )
//
// C prototype:
//  void dg_forthxcodemenpjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS switchvalue destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevalue        UINT64         value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 2nd on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable minus the casevalue has an even
//   number of bits set.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,     // if switch value = 9 then goto codeme 0
//         5 1 NPJUMP,    // if switch value - 5 has odd parity
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthxycodemewithinjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthxcodemenpjumpcomma ( X-Y-CODEME-WITHINJUMP, WITHINJUMP, )
//
// C prototype:
//  void dg_forthxcodemenpjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS casevaluelo casevaluehi destcodeme --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-CASE-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   casevaluelo      UINT64         low value to compare with switch value at runtime
//   casevaluehi      UINT64         high value to compare with switch value at runtime
//   destcodeme       UINT64         0 based codeme table index of codeme to jump to
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is 4th on the 
//   data stack.
//  Then compiles code to branch to the destination codeme's beginsys if the
//   switch value saved in a local variable is between casevaluelo and
//   casevaluehi or equal to casevaluelo. The branch is not taken if the
//   switch value equals casevaluehi.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." within 3 to 7" 
//       [ EME, ] 
//         ( 1 ) ." 9" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         3 7 0 WITHINJUMP,  // if switch value is 3 4 5 or 6
//         9 1   =JUMP,       // if switch value is 9
//         DEFAULTDROPJUMP, ]
//         ." default"             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthdefaultjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdefaultjumpcomma ( DEFAULTJUMP, )
//
// C prototype:
//  void dg_forthdefaultjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( compiletime: )
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS )
//
//  ( runtime: )
//  ( -- switchvalue )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Runtime data stack out:
//
//   switchvalue      UINT64         0 based switch value that was too high
//
// Action:
//  First, checks to see if the CODEMES-JUMP-SYS state marker is top on the 
//   data stack.
//  Then compiles code to push a copy of the switch value to the data stack.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." within 3 to 7" 
//       [ EME, ] 
//         ( 1 ) ." 9" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         3 7 0 WITHINJUMP,  // if switch value is 3 4 5 or 6
//         9 1 =JUMP,         // if switch value is 9
//         DEFAULTJUMP, ]
//         ." default for swich value = " .  // if switch value is not 3 4 5 6 or 9             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  I added this word to make portability easier in case it ever gets adopted into
//    common use. This way other implementations can keep the switch value on the
//    data stack, and if they do then in their implementations then this word 
//    does nothing. So if you want your code to be portable, you may want to use 
//    DEFAULTJUMP, or DEFAULTDROPJUMP.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


     <div class=word id=dg_forthdefaultdropjumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthdefaultdropjumpcomma ( DEFAULTDROPJUMP, )
//
// C prototype:
//  void dg_forthdefaultdropjumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( compiletime: )
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS 
//    -- AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS )
//
//  ( runtime: )
//  ( -- )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//
//
// Action:
//   Does nothing. The switchvalue was dropped during JUMPS,
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." within 3 to 7" 
//       [ EME, ] 
//         ( 1 ) ." 9" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         3 7 0 WITHINJUMP,  // if switch value is 3 4 5 or 6
//         9 1 =JUMP,         // if switch value is 9
//         DEFAULTDROPJUMP, ]
//         ." default"        // if switch value is not 3 4 5 6 or 9             
//     [ ENDJUMPS, ]
// ; 
//
// Note:
//  I added this word to make portability easier in case it ever gets adopted into
//    common use. This way other implementations can keep the switch value on the
//    data stack, and if they do then in their implementations this word 
//    compiles a drop. So if you want your code to be portable, you may want to use 
//    DEFAULTJUMP, or DEFAULTDROPJUMP.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesendjumpscomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesendjumpscomma ( CODEMES-ENDJUMPS, ENDJUMPS, ENDUJUMP, )
//
// C prototype:
//  void dg_forthcodemesendjumpscomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//      CODEMES-JUMP-SYS -- )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//                                     
//
// Example:
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 9" 
//       [ EME, ] 
//         ( 1 ) ." 5" 
//     [ ENDEMES, ]
//
//     [ JUMPS,
//         9 0 =JUMP,    // if tos = 9 then goto eme 0
//         5 1 =JUMP, ]  // if tos = 5 then goto eme 1
//         ." default"
//     [ ENDJUMPS, ]
// ; 
//
// Action:
//
//  First, checks to see if the CODEMES-JUMP-SYS state marker is on top of the 
//   data stack.
//
//  Then resolves all the jumps for each AHEAD-SYS in the codemes table except
//   AHEAD-SYS-START to jump to the current end of the current compile buffer.
//
//  Then drops the codeme table from the data stack.
//
// Note:
//
//  Unlike Dr. Eaker's END-CASE , CODEMES-END-JUMPS, does not compile a DROP. THe
//   switch value is popped from the data stack during CODEMES-JUMPS, and copied
//   to a local variable. This means you don't need to do a drop during the
//   after jumps default code.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient CASE statements without
//    using labels.
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesjumptablecomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesjumptablecomma ( CODEMES-JUMPTABLE, )
//
// C prototype:
//  void dg_forthcodemesjumptablecomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset END-CODEMES-SYS 
//    --  AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX switchoffset 
//        END-CODEMES-SYS ojumptable )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         0
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//   ojumptable       UINT64         offset of jump table
//                                     
//
// Action:
//
//  First, checks to make sure the END-CODEMES-SYS state marker is on top of the
//   data stack.
//  Then, compiles a jumptable which holds the start offsets for each codeme.
//  Then pushes the start offset of the jump table to the data stack.
//
// : test CRLF ." got " 
//     [ CODEMES, ]  
//         ( codeme 0 ) ." 0" 
//       [ CODEME, ] 
//         ( codeme 1 ) ." 1" 
//     [ END-CODEMES, ]
//
//     [ CODEMES-JUMPTABLE, ]
//     [ >R CODEMES-JUMPS, R> ]
//     [ JUMPTABLE-UJUMP, 
//         DEFAULTDROPJUMP, ]
//         ." default"
//     [ CODEMES-END-JUMPS, ]
// ; 
//
// Note:
//
//  DiaperGlu's R stack is not on the return stack and is instead a separate
//   stack. This allows >R and R> to work in the execute state, but also
//   means this example code is not portable if these words are implemented
//   in another forth. I recommend using CODEMES-UJUMP, instead of this word.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthjumptableujumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthjumptableujumpcomma ( JUMPTABLE-UJUMP, )
//
// C prototype:
//  void dg_forthjumptableujumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-JUMP-SYS 
//    ojumptable --  
//    AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-JUMP-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         0
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//   ojumptable       UINT64         offset of jump table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//
//  First, checks to make sure the END-CODEMES-SYS state marker is on top of the
//   data stack.
//  Then, compiles a jumptable which holds the start offsets for each codeme.
//  Then pushes the start offset of the jump table to the data stack.
//
// : test CRLF ." got " 
//     [ CODEMES, ]  
//         ( 0 ) ." 0" 
//       [ CODEME, ] 
//         ( 1 ) ." 1" 
//     [ END-CODEMES, ]
//
//     [ CODEMES-JUMPTABLE, ]
//     [ >R CODEMES-JUMPS, R> ]
//     [ JUMPTABLE-UJUMP, 
//         DEFAULTDROPJUMP, ]
//         ." default"
//     [ CODEMES-END-JUMPS, ]
// ; 
//
// Note:
//
//  DiaperGlu's R stack is not on the return stack and is instead a separate
//   stack. This allows >R and R> to work in the execute state, but also
//   means this example code is not portable if these words are implemented
//   in another forth. I recommend using CODEMES-UJUMP, instead of this word.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcodemesujumpcomma>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcodemesujumpcomma ( CODEMES-UJUMP, UJUMP, )
//
// C prototype:
//  void dg_forthcodemesujumpcomma (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current END-CODEMES-SYS --  
//      AHEAD-SYS-START AHEAD-SYS-0 .. AHEAD-SYS-UMAX-1 UMAX current CODEMES-JUMP-SYS )
//
// Compiletime data stack in:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         0
//   END-CODEMES-SYS  UINT64         state marker for codeme table
//
// Compiletime data stack out:
//
//   AHEAD-SYS-START  UINT64         IFSYS marker for the jump that skips over all
//                                     the codemes and also the BEGINSYS 
//                                     marker for codeme 0
//   AHEAD-SYS-0      UINT64         IFSYS marker for the jump that ends codeme 0
//                                     and also the BEGINSYS marker for codeme 1
//   AHEAD-SYS-1      UINT64         IFSYS marker for the jump that ends codeme 1
//                                     and also the BEGINSYS marker for codeme 2
//   ..               UINT64s        markers 2 through U-2
//   AHEAD-SYS-UMAX-1 UINT64         IFSYS marker for the jump that ends codeme U-1
//                                     and also will be the BEGINSYS marker for
//                                     codeme U
//   UMAX             UINT64         number of codemes in codeme table
//   switchoffset     UINT64         local variable offset of switch value
//   CODEMES-JUMP-SYS UINT64         state marker for codeme table
//                                     
//
// Action:
//
//  First, checks to make sure the END-CODEMES-SYS state marker is on top of the
//   data stack.
//  Then, compiles a jumptable which holds the start offsets for each codeme.
//  Then resolves AHEAD-SYS-START to jump to the current end of the current 
//   compile buffer. 
//  Then compiles code to allocate a new local variable, pop the switch value
//   off the data stack, and copy the switch value to the new local variable.
//  Then changes switch offset in the codeme table to the new local variable's
//   return stack frame offset.
//  Then changes the codeme state marker to be CODEMES-JUMP-SYS.
//  Then compiles an unresolved forward branch that is taken if the switch
//   value is greater or equal to the number of codemes.
//  Then compiles code to use the jumptable to jump the codeme matching the
//   0 based switch value. 
//  Then resolves the forward branch to branch to the current offset.
//
// : test CRLF ." got " 
//     [ EMES, ]  
//         ( 0 ) ." 0" 
//       [ EME, ] 
//         ( 1 ) ." 1" 
//     [ ENDEMES, ]
//
//     [ UJUMP, 
//         DEFAULTDROPJUMP, ]
//         ." default"
//     [ ENDUJUMP, ]
// ; 
//
// Note:
//
//  The code in each codeme case has access to the local variables and sees 
//   the same data stack. Unlike the Dr. Eaker CASE, 
//   UJUMP, removes the switch value from the data stack and moves
//   it to a hidden local variable. This means the switch value is not
//   on the data stack in the default code after the jumps. But doing this
//   allows you to use the other compare and jump words immediately after 
//   UJUMP,
//
//  If you need the switch value during the default case, you can use
//   DEFAULTJUMP, to push a copy onto the data stack.
//
//  Also, to make it easier to come up with a standard that is portable, I
//   have included DEFAULTDROPJUMP, which does nothing, but may do something
//   in another Forth that implements codemes. This way other Forths are
//   free to leave the switch value on the data stack and users can use
//   DEFAULTJUMP, and DEFAULTDROPJUMP, to get the default case data stack
//   into a known state.
//
//  Codemes are an array of code parts in a word. Each code part is separate from the
//    main code in the word and from each other. An initial jump skips over all the
//    code parts, and each code part ends with a jump. The code parts have access to
//    the word's local variables and data stack. Using a table like this lets the
//    compiler do things like compile extremely efficient code and eliminates the
//    the need for labels.
//
//  If codemes get adopted into standard use, I recommend removing the codeme from
//   the data stack before switching to the codeme code. The main reason for
//   this is to simplify things and because that's how Dr. Eaker's CASE works.
//   This practice does add to the code complexity of some implementation methods.
//   I also recommend moving away from Dr Eaker's CASE when it comes to the default
//   case and adding the use of DEFAULTJUMP, and DEFAULTDROPJUMP, to get the default
//   case data stack into a known state.
//
//  P.S. Codeme is short for code eme not code me.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthquerynotequals>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthquerynotequals ( ?&lt;&gt; )
//
// C prototype:
//  void dg_forthquerynotequals (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( u1 u2 -- u1 TRUE | FALSE )
//
// Data stack in:
//
//  u1               UINT64          64 bit number to compare
//  u2               UINT64          64 bit number to compare
//
// Data stack out:
//
//  u1               UINT64          64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares u1 and u2. If not equal, replaces u2 with TRUE.
//    If equal, replaces u1 and u2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthquerylessthan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthquerylessthan ( ?&lt; )
//
// C prototype:
//  void dg_forthquerylessthan (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n1 n2 -- n1 TRUE | FALSE )
//
// Data stack in:
//
//  n1               INT64           64 bit number to compare
//  n2               INT64           64 bit number to compare
//
// Data stack out:
//
//  n1               INT64           64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares n1 and n2. If n1 &lt; n2, replaces n2 with TRUE.
//    If n1 is not less than n2, replaces n1 and n2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthquerylessthanequal>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthquerylessthanequal ( ?&lt;= )
//
// C prototype:
//  void dg_forthquerylessthanequal (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n1 n2 -- n1 TRUE | FALSE )
//
// Data stack in:
//
//  n1               INT64           64 bit number to compare
//  n2               INT64           64 bit number to compare
//
// Data stack out:
//
//  n1               INT64           64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares n1 and n2. If n1 &lt;= n2, replaces n2 with TRUE.
//    If n1 is not less than or equal n2, replaces n1 and n2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthqueryulessthan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthqueryulessthan ( ?U&lt; )
//
// C prototype:
//  void dg_forthqueryulessthan (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( u1 u2 -- u1 TRUE | FALSE )
//
// Data stack in:
//
//  u1               UINT64          64 bit number to compare
//  u2               UINT64          64 bit number to compare
//
// Data stack out:
//
//  u1               UINT64          64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares u1 and u2. If u1 U&lt; u2, replaces u2 with TRUE.
//    If u1 is not (unsigned) less than u2, replaces u1 and u2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthqueryulessthanequal>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthqueryulessthanequal ( ?U&lt;= )
//
// C prototype:
//  void dg_forthqueryulessthanequal (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( u1 u2 -- u1 TRUE | FALSE )
//
// Data stack in:
//
//  u1               UINT64          64 bit number to compare
//  u2               UINT64          64 bit number to compare
//
// Data stack out:
//
//  u1               UINT64          64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares u1 and u2. If u1 U&lt;= u2, replaces u2 with TRUE.
//    If u1 is not (unsigned) less than or equal u2, replaces u1 and u2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthquerygreaterthan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthquerygreaterthan ( ?&gt; )
//
// C prototype:
//  void dg_forthquerygreaterthan (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n1 n2 -- n1 TRUE | FALSE )
//
// Data stack in:
//
//  n1               INT64           64 bit number to compare
//  n2               INT64           64 bit number to compare
//
// Data stack out:
//
//  n1               INT64           64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares n1 and n2. If n1 &gt; n2, replaces n2 with TRUE.
//    If n1 is not greater than n2, replaces n1 and n2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthquerygreaterthanequal>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthquerygreaterthanequal ( ?&gt;= )
//
// C prototype:
//  void dg_forthquerygreaterthanequal (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( n1 n2 -- n1 TRUE | FALSE )
//
// Data stack in:
//
//  n1               INT64           64 bit number to compare
//  n2               INT64           64 bit number to compare
//
// Data stack out:
//
//  n1               INT64           64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares n1 and n2. If n1 &gt;= n2, replaces n2 with TRUE.
//    If n1 is greater less than or equal n2, replaces n1 and n2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthqueryugreaterthan>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthqueryugreaterthan ( ?U&gt; )
//
// C prototype:
//  void dg_forthqueryugreaterthan (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( u1 u2 -- u1 TRUE | FALSE )
//
// Data stack in:
//
//  u1               UINT64          64 bit number to compare
//  u2               UINT64          64 bit number to compare
//
// Data stack out:
//
//  u1               UINT64          64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares u1 and u2. If u1 U&gt; u2, replaces u2 with TRUE.
//    If u1 is not (unsigned) greater than u2, replaces u1 and u2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthqueryugreaterthanequal>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthqueryugreaterthanequal ( ?U&gt;= )
//
// C prototype:
//  void dg_forthqueryugreaterthanequal (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( u1 u2 -- u1 TRUE | FALSE )
//
// Data stack in:
//
//  u1               UINT64          64 bit number to compare
//  u2               UINT64          64 bit number to compare
//
// Data stack out:
//
//  u1               UINT64          64 bit number that was compared
//  flag             UINT64          TRUE if not equal, FALSE if equal
//                                     
//
// Action:
//
//  Compares u1 and u2. If u1 U&gt;= u2, replaces u2 with TRUE.
//    If u1 is not (unsigned) greater than or equal u2, replaces u1 and u2 with FALSE.
//
// Note:
//
//  Designed for use with UNTIL for building a CASE statements.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcleftbracket>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcleftbracket ( C[ )
//
// C prototype:
//  void dg_forthcleftbracket (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( -- )                             
//
// Action:
//
//   Sets the colorstate to color execute. In color state execute, everything is
//     executed. Words found in the search order are executed, integer numbers
//     converted are pushed to the data stack, and floating point numbers converted
//     are pushed to the floating point stack. Words in the color immediate wordlist
//     are executed.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcrightbracket>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcrightbracket ( C] )
//
// C prototype:
//  void dg_forthcrightbracket (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( -- )                             
//
// Action:
//
//   Sets the colorstate to color compiled. In color state compile, except for words
//     in the color immediate wordlist, does the compile action of everything. 
//     Words found in their search order have their compile state action done. When 
//     integer numbers are parsed, a compile to push the number to the data stack is 
//     done. When floating point numbers are parsed, a compile to push the number to 
//     the floating point stack is done. Words found in the color immediate wordlist
//     are executed.
//   There is one difference from the regular compile state, in color compile state
//     immediate words are not executed. Instead, the color compile state compiles a
//     call to the immediate word's subroutine.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcp>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcp ( CP )
//
// C prototype:
//  void dg_forthcp (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( -- )                             
//
// Action:
//
//   Sets the colorstate to color postpone. In color state postpone, except for words
//     in the color immediate wordlist, compiles a call to do the compile action of 
//     everything. When words found in their search order, the interpreter compiles
//     a call to do the compile state action of the word. When integer numbers are 
//     parsed, the interpreter compiles a call to compile pushing the number to the 
//     data stack is done. When floating point numbers are parsed, the interpreter
//     compiles a call to push the number to the floating point stack is done. Words 
//     found in the color immediate wordlist are executed.
//   There is one difference from a regular postpone, in color postpone state
//     immediate word's are treated the same as regular words. The color postpone 
//     state compiles a call to compile a call to the immediate word's subroutine.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthci>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthci ( CI )
//
// C prototype:
//  void dg_forthci (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( -- )                             
//
// Action:
//
//   Sets the colorstate to forth interpret. In forth interpret, except for words in
//     the color immediate wordlist, the normal forth interpretation is done, which 
//     is where the interpreter uses the state variable to decide whether to do the 
//     execute or compile action of a found word. Words found in the color immediate
//     wordlist are executed.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


      <div class=word id=dg_forthcleftparen>
<pre>
// //////////////////////////////////////////////////////////////////////////////////////
//
// dg_forthcleftparen ( C( )
//
// C prototype:
//  void dg_forthcleftparen (Bufferhandle* pBHarrayhead)
//
// Inputs:
//  Bufferhandle*  pBHarrayhead      pointer to a Bufferhandle structure which is 
//                                    used as the bufferhandle for the array where the  
//                                    other bufferhandles are stored          
//
// Stack action shorthand:
//  ( -- )                             
//
// Action:
//
//   Sets the colorstate to color comment. In color comment, everything parsed except 
//     words in the color immediate wordlist are ignored. Words in the color immediate
//     wordlist are executed.
//   
// //////////////////////////////////////////////////////////////////////////////////////
</pre>
      </div>


    </div>

  </div></body>
</html>
